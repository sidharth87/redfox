// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: KernelIR.proto

#ifndef PROTOBUF_KernelIR_2eproto__INCLUDED
#define PROTOBUF_KernelIR_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/io/zero_copy_stream_impl.h>
// @@protoc_insertion_point(includes)

namespace harmony {
namespace hir {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_KernelIR_2eproto();
void protobuf_AssignDesc_KernelIR_2eproto();
void protobuf_ShutdownFile_KernelIR_2eproto();

class KernelControlFlowGraph;
class Variable;
class Operand;
class Kernel;
class BasicBlock;
class Test;

enum DataType {
  I8 = 1,
  I16 = 2,
  I32 = 3,
  I64 = 4,
  I128 = 5,
  F32 = 6,
  F64 = 7
};
bool DataType_IsValid(int value);
const DataType DataType_MIN = I8;
const DataType DataType_MAX = F64;
const int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataType_descriptor();
inline const ::std::string& DataType_Name(DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataType_descriptor(), value);
}
inline bool DataType_Parse(
    const ::std::string& name, DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
enum AccessMode {
  In = 1,
  Out = 2,
  InOut = 3
};
bool AccessMode_IsValid(int value);
const AccessMode AccessMode_MIN = In;
const AccessMode AccessMode_MAX = InOut;
const int AccessMode_ARRAYSIZE = AccessMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccessMode_descriptor();
inline const ::std::string& AccessMode_Name(AccessMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccessMode_descriptor(), value);
}
inline bool AccessMode_Parse(
    const ::std::string& name, AccessMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccessMode>(
    AccessMode_descriptor(), name, value);
}
enum KernelType {
  ComputeKernel = 1,
  BinaryKernel = 2,
  ControlDecision = 3,
  UnconditionalBranch = 4,
  GetSize = 5,
  Resize = 6,
  UpdateSize = 7,
  Exit = 8
};
bool KernelType_IsValid(int value);
const KernelType KernelType_MIN = ComputeKernel;
const KernelType KernelType_MAX = Exit;
const int KernelType_ARRAYSIZE = KernelType_MAX + 1;

const ::google::protobuf::EnumDescriptor* KernelType_descriptor();
inline const ::std::string& KernelType_Name(KernelType value) {
  return ::google::protobuf::internal::NameOfEnum(
    KernelType_descriptor(), value);
}
inline bool KernelType_Parse(
    const ::std::string& name, KernelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KernelType>(
    KernelType_descriptor(), name, value);
}
// ===================================================================

class KernelControlFlowGraph : public ::google::protobuf::Message {
 public:
  KernelControlFlowGraph();
  virtual ~KernelControlFlowGraph();
  
  KernelControlFlowGraph(const KernelControlFlowGraph& from);
  
  inline KernelControlFlowGraph& operator=(const KernelControlFlowGraph& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KernelControlFlowGraph& default_instance();
  
  void Swap(KernelControlFlowGraph* other);
  
  // implements Message ----------------------------------------------
  
  KernelControlFlowGraph* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KernelControlFlowGraph& from);
  void MergeFrom(const KernelControlFlowGraph& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .harmony.hir.pb.BasicBlock blocks = 2;
  inline int blocks_size() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 2;
  inline const ::harmony::hir::pb::BasicBlock& blocks(int index) const;
  inline ::harmony::hir::pb::BasicBlock* mutable_blocks(int index);
  inline ::harmony::hir::pb::BasicBlock* add_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::BasicBlock >&
      blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::BasicBlock >*
      mutable_blocks();
  
  // repeated .harmony.hir.pb.Variable variables = 3;
  inline int variables_size() const;
  inline void clear_variables();
  static const int kVariablesFieldNumber = 3;
  inline const ::harmony::hir::pb::Variable& variables(int index) const;
  inline ::harmony::hir::pb::Variable* mutable_variables(int index);
  inline ::harmony::hir::pb::Variable* add_variables();
  inline const ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable >&
      variables() const;
  inline ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable >*
      mutable_variables();
  
  // required uint32 entry = 4;
  inline bool has_entry() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 4;
  inline ::google::protobuf::uint32 entry() const;
  inline void set_entry(::google::protobuf::uint32 value);
  
  // required uint32 exit = 5;
  inline bool has_exit() const;
  inline void clear_exit();
  static const int kExitFieldNumber = 5;
  inline ::google::protobuf::uint32 exit() const;
  inline void set_exit(::google::protobuf::uint32 value);
  
  // required uint32 testCount = 6;
  inline bool has_testcount() const;
  inline void clear_testcount();
  static const int kTestCountFieldNumber = 6;
  inline ::google::protobuf::uint32 testcount() const;
  inline void set_testcount(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:harmony.hir.pb.KernelControlFlowGraph)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_entry();
  inline void clear_has_entry();
  inline void set_has_exit();
  inline void clear_has_exit();
  inline void set_has_testcount();
  inline void clear_has_testcount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::BasicBlock > blocks_;
  ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable > variables_;
  ::google::protobuf::uint32 entry_;
  ::google::protobuf::uint32 exit_;
  ::google::protobuf::uint32 testcount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_KernelIR_2eproto();
  friend void protobuf_AssignDesc_KernelIR_2eproto();
  friend void protobuf_ShutdownFile_KernelIR_2eproto();
  
  void InitAsDefaultInstance();
  static KernelControlFlowGraph* default_instance_;
};
// -------------------------------------------------------------------

class Variable : public ::google::protobuf::Message {
 public:
  Variable();
  virtual ~Variable();
  
  Variable(const Variable& from);
  
  inline Variable& operator=(const Variable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Variable& default_instance();
  
  void Swap(Variable* other);
  
  // implements Message ----------------------------------------------
  
  Variable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Variable& from);
  void MergeFrom(const Variable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);
  
  // required .harmony.hir.pb.DataType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline harmony::hir::pb::DataType type() const;
  inline void set_type(harmony::hir::pb::DataType value);
  
  // required uint64 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);
  
  // required bool output = 4;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 4;
  inline bool output() const;
  inline void set_output(bool value);
  
  // required bool input = 5;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 5;
  inline bool input() const;
  inline void set_input(bool value);
  
  // optional bytes data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // optional string filename = 7;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 7;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // @@protoc_insertion_point(class_scope:harmony.hir.pb.Variable)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_output();
  inline void clear_has_output();
  inline void set_has_input();
  inline void clear_has_input();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_filename();
  inline void clear_has_filename();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 name_;
  int type_;
  ::google::protobuf::uint64 size_;
  ::std::string* data_;
  ::std::string* filename_;
  bool output_;
  bool input_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_KernelIR_2eproto();
  friend void protobuf_AssignDesc_KernelIR_2eproto();
  friend void protobuf_ShutdownFile_KernelIR_2eproto();
  
  void InitAsDefaultInstance();
  static Variable* default_instance_;
};
// -------------------------------------------------------------------

class Operand : public ::google::protobuf::Message {
 public:
  Operand();
  virtual ~Operand();
  
  Operand(const Operand& from);
  
  inline Operand& operator=(const Operand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Operand& default_instance();
  
  void Swap(Operand* other);
  
  // implements Message ----------------------------------------------
  
  Operand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operand& from);
  void MergeFrom(const Operand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .harmony.hir.pb.AccessMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline harmony::hir::pb::AccessMode mode() const;
  inline void set_mode(harmony::hir::pb::AccessMode value);
  
  // required uint32 variable = 2;
  inline bool has_variable() const;
  inline void clear_variable();
  static const int kVariableFieldNumber = 2;
  inline ::google::protobuf::uint32 variable() const;
  inline void set_variable(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:harmony.hir.pb.Operand)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_variable();
  inline void clear_has_variable();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int mode_;
  ::google::protobuf::uint32 variable_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_KernelIR_2eproto();
  friend void protobuf_AssignDesc_KernelIR_2eproto();
  friend void protobuf_ShutdownFile_KernelIR_2eproto();
  
  void InitAsDefaultInstance();
  static Operand* default_instance_;
};
// -------------------------------------------------------------------

class Kernel : public ::google::protobuf::Message {
 public:
  Kernel();
  virtual ~Kernel();
  
  Kernel(const Kernel& from);
  
  inline Kernel& operator=(const Kernel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Kernel& default_instance();
  
  void Swap(Kernel* other);
  
  // implements Message ----------------------------------------------
  
  Kernel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Kernel& from);
  void MergeFrom(const Kernel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required bytes code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const void* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  
  // required .harmony.hir.pb.KernelType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline harmony::hir::pb::KernelType type() const;
  inline void set_type(harmony::hir::pb::KernelType value);
  
  // repeated .harmony.hir.pb.Operand operands = 4;
  inline int operands_size() const;
  inline void clear_operands();
  static const int kOperandsFieldNumber = 4;
  inline const ::harmony::hir::pb::Operand& operands(int index) const;
  inline ::harmony::hir::pb::Operand* mutable_operands(int index);
  inline ::harmony::hir::pb::Operand* add_operands();
  inline const ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Operand >&
      operands() const;
  inline ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Operand >*
      mutable_operands();
  
  // repeated uint32 targets = 5;
  inline int targets_size() const;
  inline void clear_targets();
  static const int kTargetsFieldNumber = 5;
  inline ::google::protobuf::uint32 targets(int index) const;
  inline void set_targets(int index, ::google::protobuf::uint32 value);
  inline void add_targets(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      targets() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_targets();
  
  // @@protoc_insertion_point(class_scope:harmony.hir.pb.Kernel)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* code_;
  ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Operand > operands_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > targets_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_KernelIR_2eproto();
  friend void protobuf_AssignDesc_KernelIR_2eproto();
  friend void protobuf_ShutdownFile_KernelIR_2eproto();
  
  void InitAsDefaultInstance();
  static Kernel* default_instance_;
};
// -------------------------------------------------------------------

class BasicBlock : public ::google::protobuf::Message {
 public:
  BasicBlock();
  virtual ~BasicBlock();
  
  BasicBlock(const BasicBlock& from);
  
  inline BasicBlock& operator=(const BasicBlock& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BasicBlock& default_instance();
  
  void Swap(BasicBlock* other);
  
  // implements Message ----------------------------------------------
  
  BasicBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BasicBlock& from);
  void MergeFrom(const BasicBlock& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // repeated .harmony.hir.pb.Kernel kernels = 2;
  inline int kernels_size() const;
  inline void clear_kernels();
  static const int kKernelsFieldNumber = 2;
  inline const ::harmony::hir::pb::Kernel& kernels(int index) const;
  inline ::harmony::hir::pb::Kernel* mutable_kernels(int index);
  inline ::harmony::hir::pb::Kernel* add_kernels();
  inline const ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Kernel >&
      kernels() const;
  inline ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Kernel >*
      mutable_kernels();
  
  // required .harmony.hir.pb.Kernel control = 3;
  inline bool has_control() const;
  inline void clear_control();
  static const int kControlFieldNumber = 3;
  inline const ::harmony::hir::pb::Kernel& control() const;
  inline ::harmony::hir::pb::Kernel* mutable_control();
  inline ::harmony::hir::pb::Kernel* release_control();
  
  // @@protoc_insertion_point(class_scope:harmony.hir.pb.BasicBlock)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_control();
  inline void clear_has_control();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Kernel > kernels_;
  ::harmony::hir::pb::Kernel* control_;
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_KernelIR_2eproto();
  friend void protobuf_AssignDesc_KernelIR_2eproto();
  friend void protobuf_ShutdownFile_KernelIR_2eproto();
  
  void InitAsDefaultInstance();
  static BasicBlock* default_instance_;
};
// -------------------------------------------------------------------

class Test : public ::google::protobuf::Message {
 public:
  Test();
  virtual ~Test();
  
  Test(const Test& from);
  
  inline Test& operator=(const Test& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Test& default_instance();
  
  void Swap(Test* other);
  
  // implements Message ----------------------------------------------
  
  Test* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Test& from);
  void MergeFrom(const Test& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string programName = 3;
  inline bool has_programname() const;
  inline void clear_programname();
  static const int kProgramNameFieldNumber = 3;
  inline const ::std::string& programname() const;
  inline void set_programname(const ::std::string& value);
  inline void set_programname(const char* value);
  inline void set_programname(const char* value, size_t size);
  inline ::std::string* mutable_programname();
  inline ::std::string* release_programname();
  
  // repeated .harmony.hir.pb.Variable inputs = 1;
  inline int inputs_size() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 1;
  inline const ::harmony::hir::pb::Variable& inputs(int index) const;
  inline ::harmony::hir::pb::Variable* mutable_inputs(int index);
  inline ::harmony::hir::pb::Variable* add_inputs();
  inline const ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable >&
      inputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable >*
      mutable_inputs();
  
  // repeated .harmony.hir.pb.Variable outputs = 2;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  inline const ::harmony::hir::pb::Variable& outputs(int index) const;
  inline ::harmony::hir::pb::Variable* mutable_outputs(int index);
  inline ::harmony::hir::pb::Variable* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable >*
      mutable_outputs();
  
  // repeated uint32 features = 5;
  inline int features_size() const;
  inline void clear_features();
  static const int kFeaturesFieldNumber = 5;
  inline ::google::protobuf::uint32 features(int index) const;
  inline void set_features(int index, ::google::protobuf::uint32 value);
  inline void add_features(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      features() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_features();
  
  // @@protoc_insertion_point(class_scope:harmony.hir.pb.Test)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_programname();
  inline void clear_has_programname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* programname_;
  ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable > inputs_;
  ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable > outputs_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > features_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_KernelIR_2eproto();
  friend void protobuf_AssignDesc_KernelIR_2eproto();
  friend void protobuf_ShutdownFile_KernelIR_2eproto();
  
  void InitAsDefaultInstance();
  static Test* default_instance_;
};
// ===================================================================


// ===================================================================

// KernelControlFlowGraph

// required string name = 1;
inline bool KernelControlFlowGraph::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KernelControlFlowGraph::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KernelControlFlowGraph::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KernelControlFlowGraph::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& KernelControlFlowGraph::name() const {
  return *name_;
}
inline void KernelControlFlowGraph::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void KernelControlFlowGraph::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void KernelControlFlowGraph::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KernelControlFlowGraph::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* KernelControlFlowGraph::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .harmony.hir.pb.BasicBlock blocks = 2;
inline int KernelControlFlowGraph::blocks_size() const {
  return blocks_.size();
}
inline void KernelControlFlowGraph::clear_blocks() {
  blocks_.Clear();
}
inline const ::harmony::hir::pb::BasicBlock& KernelControlFlowGraph::blocks(int index) const {
  return blocks_.Get(index);
}
inline ::harmony::hir::pb::BasicBlock* KernelControlFlowGraph::mutable_blocks(int index) {
  return blocks_.Mutable(index);
}
inline ::harmony::hir::pb::BasicBlock* KernelControlFlowGraph::add_blocks() {
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::BasicBlock >&
KernelControlFlowGraph::blocks() const {
  return blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::BasicBlock >*
KernelControlFlowGraph::mutable_blocks() {
  return &blocks_;
}

// repeated .harmony.hir.pb.Variable variables = 3;
inline int KernelControlFlowGraph::variables_size() const {
  return variables_.size();
}
inline void KernelControlFlowGraph::clear_variables() {
  variables_.Clear();
}
inline const ::harmony::hir::pb::Variable& KernelControlFlowGraph::variables(int index) const {
  return variables_.Get(index);
}
inline ::harmony::hir::pb::Variable* KernelControlFlowGraph::mutable_variables(int index) {
  return variables_.Mutable(index);
}
inline ::harmony::hir::pb::Variable* KernelControlFlowGraph::add_variables() {
  return variables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable >&
KernelControlFlowGraph::variables() const {
  return variables_;
}
inline ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable >*
KernelControlFlowGraph::mutable_variables() {
  return &variables_;
}

// required uint32 entry = 4;
inline bool KernelControlFlowGraph::has_entry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KernelControlFlowGraph::set_has_entry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KernelControlFlowGraph::clear_has_entry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KernelControlFlowGraph::clear_entry() {
  entry_ = 0u;
  clear_has_entry();
}
inline ::google::protobuf::uint32 KernelControlFlowGraph::entry() const {
  return entry_;
}
inline void KernelControlFlowGraph::set_entry(::google::protobuf::uint32 value) {
  set_has_entry();
  entry_ = value;
}

// required uint32 exit = 5;
inline bool KernelControlFlowGraph::has_exit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KernelControlFlowGraph::set_has_exit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KernelControlFlowGraph::clear_has_exit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KernelControlFlowGraph::clear_exit() {
  exit_ = 0u;
  clear_has_exit();
}
inline ::google::protobuf::uint32 KernelControlFlowGraph::exit() const {
  return exit_;
}
inline void KernelControlFlowGraph::set_exit(::google::protobuf::uint32 value) {
  set_has_exit();
  exit_ = value;
}

// required uint32 testCount = 6;
inline bool KernelControlFlowGraph::has_testcount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KernelControlFlowGraph::set_has_testcount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void KernelControlFlowGraph::clear_has_testcount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void KernelControlFlowGraph::clear_testcount() {
  testcount_ = 0u;
  clear_has_testcount();
}
inline ::google::protobuf::uint32 KernelControlFlowGraph::testcount() const {
  return testcount_;
}
inline void KernelControlFlowGraph::set_testcount(::google::protobuf::uint32 value) {
  set_has_testcount();
  testcount_ = value;
}

// -------------------------------------------------------------------

// Variable

// required uint32 name = 1;
inline bool Variable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Variable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Variable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Variable::clear_name() {
  name_ = 0u;
  clear_has_name();
}
inline ::google::protobuf::uint32 Variable::name() const {
  return name_;
}
inline void Variable::set_name(::google::protobuf::uint32 value) {
  set_has_name();
  name_ = value;
}

// required .harmony.hir.pb.DataType type = 2;
inline bool Variable::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Variable::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Variable::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Variable::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline harmony::hir::pb::DataType Variable::type() const {
  return static_cast< harmony::hir::pb::DataType >(type_);
}
inline void Variable::set_type(harmony::hir::pb::DataType value) {
  GOOGLE_DCHECK(harmony::hir::pb::DataType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required uint64 size = 3;
inline bool Variable::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Variable::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Variable::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Variable::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 Variable::size() const {
  return size_;
}
inline void Variable::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// required bool output = 4;
inline bool Variable::has_output() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Variable::set_has_output() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Variable::clear_has_output() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Variable::clear_output() {
  output_ = false;
  clear_has_output();
}
inline bool Variable::output() const {
  return output_;
}
inline void Variable::set_output(bool value) {
  set_has_output();
  output_ = value;
}

// required bool input = 5;
inline bool Variable::has_input() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Variable::set_has_input() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Variable::clear_has_input() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Variable::clear_input() {
  input_ = false;
  clear_has_input();
}
inline bool Variable::input() const {
  return input_;
}
inline void Variable::set_input(bool value) {
  set_has_input();
  input_ = value;
}

// optional bytes data = 6;
inline bool Variable::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Variable::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Variable::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Variable::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Variable::data() const {
  return *data_;
}
inline void Variable::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Variable::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Variable::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Variable::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Variable::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string filename = 7;
inline bool Variable::has_filename() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Variable::set_has_filename() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Variable::clear_has_filename() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Variable::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& Variable::filename() const {
  return *filename_;
}
inline void Variable::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Variable::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Variable::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Variable::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* Variable::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Operand

// required .harmony.hir.pb.AccessMode mode = 1;
inline bool Operand::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operand::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operand::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operand::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline harmony::hir::pb::AccessMode Operand::mode() const {
  return static_cast< harmony::hir::pb::AccessMode >(mode_);
}
inline void Operand::set_mode(harmony::hir::pb::AccessMode value) {
  GOOGLE_DCHECK(harmony::hir::pb::AccessMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// required uint32 variable = 2;
inline bool Operand::has_variable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Operand::set_has_variable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Operand::clear_has_variable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Operand::clear_variable() {
  variable_ = 0u;
  clear_has_variable();
}
inline ::google::protobuf::uint32 Operand::variable() const {
  return variable_;
}
inline void Operand::set_variable(::google::protobuf::uint32 value) {
  set_has_variable();
  variable_ = value;
}

// -------------------------------------------------------------------

// Kernel

// required string name = 1;
inline bool Kernel::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Kernel::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Kernel::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Kernel::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Kernel::name() const {
  return *name_;
}
inline void Kernel::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Kernel::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Kernel::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Kernel::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Kernel::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes code = 2;
inline bool Kernel::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Kernel::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Kernel::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Kernel::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& Kernel::code() const {
  return *code_;
}
inline void Kernel::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void Kernel::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void Kernel::set_code(const void* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Kernel::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* Kernel::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .harmony.hir.pb.KernelType type = 3;
inline bool Kernel::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Kernel::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Kernel::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Kernel::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline harmony::hir::pb::KernelType Kernel::type() const {
  return static_cast< harmony::hir::pb::KernelType >(type_);
}
inline void Kernel::set_type(harmony::hir::pb::KernelType value) {
  GOOGLE_DCHECK(harmony::hir::pb::KernelType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .harmony.hir.pb.Operand operands = 4;
inline int Kernel::operands_size() const {
  return operands_.size();
}
inline void Kernel::clear_operands() {
  operands_.Clear();
}
inline const ::harmony::hir::pb::Operand& Kernel::operands(int index) const {
  return operands_.Get(index);
}
inline ::harmony::hir::pb::Operand* Kernel::mutable_operands(int index) {
  return operands_.Mutable(index);
}
inline ::harmony::hir::pb::Operand* Kernel::add_operands() {
  return operands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Operand >&
Kernel::operands() const {
  return operands_;
}
inline ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Operand >*
Kernel::mutable_operands() {
  return &operands_;
}

// repeated uint32 targets = 5;
inline int Kernel::targets_size() const {
  return targets_.size();
}
inline void Kernel::clear_targets() {
  targets_.Clear();
}
inline ::google::protobuf::uint32 Kernel::targets(int index) const {
  return targets_.Get(index);
}
inline void Kernel::set_targets(int index, ::google::protobuf::uint32 value) {
  targets_.Set(index, value);
}
inline void Kernel::add_targets(::google::protobuf::uint32 value) {
  targets_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Kernel::targets() const {
  return targets_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Kernel::mutable_targets() {
  return &targets_;
}

// -------------------------------------------------------------------

// BasicBlock

// required uint32 id = 1;
inline bool BasicBlock::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasicBlock::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasicBlock::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasicBlock::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 BasicBlock::id() const {
  return id_;
}
inline void BasicBlock::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// repeated .harmony.hir.pb.Kernel kernels = 2;
inline int BasicBlock::kernels_size() const {
  return kernels_.size();
}
inline void BasicBlock::clear_kernels() {
  kernels_.Clear();
}
inline const ::harmony::hir::pb::Kernel& BasicBlock::kernels(int index) const {
  return kernels_.Get(index);
}
inline ::harmony::hir::pb::Kernel* BasicBlock::mutable_kernels(int index) {
  return kernels_.Mutable(index);
}
inline ::harmony::hir::pb::Kernel* BasicBlock::add_kernels() {
  return kernels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Kernel >&
BasicBlock::kernels() const {
  return kernels_;
}
inline ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Kernel >*
BasicBlock::mutable_kernels() {
  return &kernels_;
}

// required .harmony.hir.pb.Kernel control = 3;
inline bool BasicBlock::has_control() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BasicBlock::set_has_control() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BasicBlock::clear_has_control() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BasicBlock::clear_control() {
  if (control_ != NULL) control_->::harmony::hir::pb::Kernel::Clear();
  clear_has_control();
}
inline const ::harmony::hir::pb::Kernel& BasicBlock::control() const {
  return control_ != NULL ? *control_ : *default_instance_->control_;
}
inline ::harmony::hir::pb::Kernel* BasicBlock::mutable_control() {
  set_has_control();
  if (control_ == NULL) control_ = new ::harmony::hir::pb::Kernel;
  return control_;
}
inline ::harmony::hir::pb::Kernel* BasicBlock::release_control() {
  clear_has_control();
  ::harmony::hir::pb::Kernel* temp = control_;
  control_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Test

// required string name = 4;
inline bool Test::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Test::name() const {
  return *name_;
}
inline void Test::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Test::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Test::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Test::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Test::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string programName = 3;
inline bool Test::has_programname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test::set_has_programname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test::clear_has_programname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test::clear_programname() {
  if (programname_ != &::google::protobuf::internal::kEmptyString) {
    programname_->clear();
  }
  clear_has_programname();
}
inline const ::std::string& Test::programname() const {
  return *programname_;
}
inline void Test::set_programname(const ::std::string& value) {
  set_has_programname();
  if (programname_ == &::google::protobuf::internal::kEmptyString) {
    programname_ = new ::std::string;
  }
  programname_->assign(value);
}
inline void Test::set_programname(const char* value) {
  set_has_programname();
  if (programname_ == &::google::protobuf::internal::kEmptyString) {
    programname_ = new ::std::string;
  }
  programname_->assign(value);
}
inline void Test::set_programname(const char* value, size_t size) {
  set_has_programname();
  if (programname_ == &::google::protobuf::internal::kEmptyString) {
    programname_ = new ::std::string;
  }
  programname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Test::mutable_programname() {
  set_has_programname();
  if (programname_ == &::google::protobuf::internal::kEmptyString) {
    programname_ = new ::std::string;
  }
  return programname_;
}
inline ::std::string* Test::release_programname() {
  clear_has_programname();
  if (programname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = programname_;
    programname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .harmony.hir.pb.Variable inputs = 1;
inline int Test::inputs_size() const {
  return inputs_.size();
}
inline void Test::clear_inputs() {
  inputs_.Clear();
}
inline const ::harmony::hir::pb::Variable& Test::inputs(int index) const {
  return inputs_.Get(index);
}
inline ::harmony::hir::pb::Variable* Test::mutable_inputs(int index) {
  return inputs_.Mutable(index);
}
inline ::harmony::hir::pb::Variable* Test::add_inputs() {
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable >&
Test::inputs() const {
  return inputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable >*
Test::mutable_inputs() {
  return &inputs_;
}

// repeated .harmony.hir.pb.Variable outputs = 2;
inline int Test::outputs_size() const {
  return outputs_.size();
}
inline void Test::clear_outputs() {
  outputs_.Clear();
}
inline const ::harmony::hir::pb::Variable& Test::outputs(int index) const {
  return outputs_.Get(index);
}
inline ::harmony::hir::pb::Variable* Test::mutable_outputs(int index) {
  return outputs_.Mutable(index);
}
inline ::harmony::hir::pb::Variable* Test::add_outputs() {
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable >&
Test::outputs() const {
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::harmony::hir::pb::Variable >*
Test::mutable_outputs() {
  return &outputs_;
}

// repeated uint32 features = 5;
inline int Test::features_size() const {
  return features_.size();
}
inline void Test::clear_features() {
  features_.Clear();
}
inline ::google::protobuf::uint32 Test::features(int index) const {
  return features_.Get(index);
}
inline void Test::set_features(int index, ::google::protobuf::uint32 value) {
  features_.Set(index, value);
}
inline void Test::add_features(::google::protobuf::uint32 value) {
  features_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Test::features() const {
  return features_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Test::mutable_features() {
  return &features_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hir
}  // namespace harmony

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< harmony::hir::pb::DataType>() {
  return harmony::hir::pb::DataType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< harmony::hir::pb::AccessMode>() {
  return harmony::hir::pb::AccessMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< harmony::hir::pb::KernelType>() {
  return harmony::hir::pb::KernelType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_KernelIR_2eproto__INCLUDED

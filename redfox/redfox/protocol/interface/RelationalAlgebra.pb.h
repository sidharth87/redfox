// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RelationalAlgebra.proto

#ifndef PROTOBUF_RelationalAlgebra_2eproto__INCLUDED
#define PROTOBUF_RelationalAlgebra_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "BloxCompiler.pb.h"
// @@protoc_insertion_point(includes)

namespace blox {
namespace compiler {
namespace gpu {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_RelationalAlgebra_2eproto();
void protobuf_AssignDesc_RelationalAlgebra_2eproto();
void protobuf_ShutdownFile_RelationalAlgebra_2eproto();

class GPUGraph;
class GPUVariable;
class GPUUnion;
class GPUIntersection;
class GPUProduct;
class GPUSingle;
class GPUDifference;
class GPUJoin;
class GPUMapFilter;
class GPUAgg;
class GPUOperator;
class GPUAssign;
class GPUCond;
class GPUGoto;
class GPUMove;
class GPUCommand;
class Address;
class GPUCompare;
class GPUSequence;
class NumType;
class Univ;
class ConstExp;
class Name;
class Index;
class ArithExp;
class Convert;
class Mixed;
class Call;
class Exp;
class Comp;
class Test;
class And;
class Compare;
class Count;
class Total;
class Min;
class Max;
class Agg;

enum OperatorTag {
  UNION = 2,
  INTERSECTION = 3,
  PRODUCT = 4,
  SINGLE = 5,
  DIFFERENCE = 6,
  JOIN = 7,
  MAPFILTER = 10,
  AGG = 11
};
bool OperatorTag_IsValid(int value);
const OperatorTag OperatorTag_MIN = UNION;
const OperatorTag OperatorTag_MAX = AGG;
const int OperatorTag_ARRAYSIZE = OperatorTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* OperatorTag_descriptor();
inline const ::std::string& OperatorTag_Name(OperatorTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    OperatorTag_descriptor(), value);
}
inline bool OperatorTag_Parse(
    const ::std::string& name, OperatorTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OperatorTag>(
    OperatorTag_descriptor(), name, value);
}
enum CommandTag {
  ASSIGN = 2,
  COND = 3,
  GOTO = 4,
  MOVE = 5,
  HALT = 6
};
bool CommandTag_IsValid(int value);
const CommandTag CommandTag_MIN = ASSIGN;
const CommandTag CommandTag_MAX = HALT;
const int CommandTag_ARRAYSIZE = CommandTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommandTag_descriptor();
inline const ::std::string& CommandTag_Name(CommandTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommandTag_descriptor(), value);
}
inline bool CommandTag_Parse(
    const ::std::string& name, CommandTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandTag>(
    CommandTag_descriptor(), name, value);
}
enum Comparison {
  Eq = 0,
  Ne = 1,
  Lt = 2,
  Le = 3,
  Gt = 4,
  Ge = 5
};
bool Comparison_IsValid(int value);
const Comparison Comparison_MIN = Eq;
const Comparison Comparison_MAX = Ge;
const int Comparison_ARRAYSIZE = Comparison_MAX + 1;

const ::google::protobuf::EnumDescriptor* Comparison_descriptor();
inline const ::std::string& Comparison_Name(Comparison value) {
  return ::google::protobuf::internal::NameOfEnum(
    Comparison_descriptor(), value);
}
inline bool Comparison_Parse(
    const ::std::string& name, Comparison* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Comparison>(
    Comparison_descriptor(), name, value);
}
enum AddressTag {
  VARADDR = 2,
  CONSTADDR = 3
};
bool AddressTag_IsValid(int value);
const AddressTag AddressTag_MIN = VARADDR;
const AddressTag AddressTag_MAX = CONSTADDR;
const int AddressTag_ARRAYSIZE = AddressTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* AddressTag_descriptor();
inline const ::std::string& AddressTag_Name(AddressTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    AddressTag_descriptor(), value);
}
inline bool AddressTag_Parse(
    const ::std::string& name, AddressTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AddressTag>(
    AddressTag_descriptor(), name, value);
}
enum ArithmeticOp {
  Add = 0,
  Multiply = 1,
  Subtract = 2,
  Divide = 3,
  Mod = 4
};
bool ArithmeticOp_IsValid(int value);
const ArithmeticOp ArithmeticOp_MIN = Add;
const ArithmeticOp ArithmeticOp_MAX = Mod;
const int ArithmeticOp_ARRAYSIZE = ArithmeticOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* ArithmeticOp_descriptor();
inline const ::std::string& ArithmeticOp_Name(ArithmeticOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    ArithmeticOp_descriptor(), value);
}
inline bool ArithmeticOp_Parse(
    const ::std::string& name, ArithmeticOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ArithmeticOp>(
    ArithmeticOp_descriptor(), name, value);
}
enum Numeric {
  NInt = 0,
  NUInt = 1,
  NFloat = 2,
  NDecimal = 3
};
bool Numeric_IsValid(int value);
const Numeric Numeric_MIN = NInt;
const Numeric Numeric_MAX = NDecimal;
const int Numeric_ARRAYSIZE = Numeric_MAX + 1;

const ::google::protobuf::EnumDescriptor* Numeric_descriptor();
inline const ::std::string& Numeric_Name(Numeric value) {
  return ::google::protobuf::internal::NameOfEnum(
    Numeric_descriptor(), value);
}
inline bool Numeric_Parse(
    const ::std::string& name, Numeric* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Numeric>(
    Numeric_descriptor(), name, value);
}
enum Fixed {
  FString = 0,
  FBool = 1,
  FDatetime = 2,
  FColor = 3
};
bool Fixed_IsValid(int value);
const Fixed Fixed_MIN = FString;
const Fixed Fixed_MAX = FColor;
const int Fixed_ARRAYSIZE = Fixed_MAX + 1;

const ::google::protobuf::EnumDescriptor* Fixed_descriptor();
inline const ::std::string& Fixed_Name(Fixed value) {
  return ::google::protobuf::internal::NameOfEnum(
    Fixed_descriptor(), value);
}
inline bool Fixed_Parse(
    const ::std::string& name, Fixed* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Fixed>(
    Fixed_descriptor(), name, value);
}
enum UnivTag {
  Ntag = 0,
  Ftag = 1
};
bool UnivTag_IsValid(int value);
const UnivTag UnivTag_MIN = Ntag;
const UnivTag UnivTag_MAX = Ftag;
const int UnivTag_ARRAYSIZE = UnivTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnivTag_descriptor();
inline const ::std::string& UnivTag_Name(UnivTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnivTag_descriptor(), value);
}
inline bool UnivTag_Parse(
    const ::std::string& name, UnivTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnivTag>(
    UnivTag_descriptor(), name, value);
}
enum ExpTag {
  CONSTEXP = 0,
  INDEX = 1,
  NAME = 2,
  ARITHEXP = 3,
  CONVERT = 4,
  MIXED = 5,
  CALL = 6
};
bool ExpTag_IsValid(int value);
const ExpTag ExpTag_MIN = CONSTEXP;
const ExpTag ExpTag_MAX = CALL;
const int ExpTag_ARRAYSIZE = ExpTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExpTag_descriptor();
inline const ::std::string& ExpTag_Name(ExpTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExpTag_descriptor(), value);
}
inline bool ExpTag_Parse(
    const ::std::string& name, ExpTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExpTag>(
    ExpTag_descriptor(), name, value);
}
enum CompareTag {
  COMP = 0,
  TEST = 1,
  AND = 2,
  ALWAYS = 3
};
bool CompareTag_IsValid(int value);
const CompareTag CompareTag_MIN = COMP;
const CompareTag CompareTag_MAX = ALWAYS;
const int CompareTag_ARRAYSIZE = CompareTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* CompareTag_descriptor();
inline const ::std::string& CompareTag_Name(CompareTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    CompareTag_descriptor(), value);
}
inline bool CompareTag_Parse(
    const ::std::string& name, CompareTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompareTag>(
    CompareTag_descriptor(), name, value);
}
enum AggTag {
  COUNT = 0,
  TOTAL = 1,
  MIN = 2,
  MAX = 3
};
bool AggTag_IsValid(int value);
const AggTag AggTag_MIN = COUNT;
const AggTag AggTag_MAX = MAX;
const int AggTag_ARRAYSIZE = AggTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* AggTag_descriptor();
inline const ::std::string& AggTag_Name(AggTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    AggTag_descriptor(), value);
}
inline bool AggTag_Parse(
    const ::std::string& name, AggTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AggTag>(
    AggTag_descriptor(), name, value);
}
// ===================================================================

class GPUGraph : public ::google::protobuf::Message {
 public:
  GPUGraph();
  virtual ~GPUGraph();
  
  GPUGraph(const GPUGraph& from);
  
  inline GPUGraph& operator=(const GPUGraph& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUGraph& default_instance();
  
  void Swap(GPUGraph* other);
  
  // implements Message ----------------------------------------------
  
  GPUGraph* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUGraph& from);
  void MergeFrom(const GPUGraph& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string graphName = 1;
  inline bool has_graphname() const;
  inline void clear_graphname();
  static const int kGraphNameFieldNumber = 1;
  inline const ::std::string& graphname() const;
  inline void set_graphname(const ::std::string& value);
  inline void set_graphname(const char* value);
  inline void set_graphname(const char* value, size_t size);
  inline ::std::string* mutable_graphname();
  inline ::std::string* release_graphname();
  
  // repeated .blox.compiler.gpu.GPUVariable variables = 2;
  inline int variables_size() const;
  inline void clear_variables();
  static const int kVariablesFieldNumber = 2;
  inline const ::blox::compiler::gpu::GPUVariable& variables(int index) const;
  inline ::blox::compiler::gpu::GPUVariable* mutable_variables(int index);
  inline ::blox::compiler::gpu::GPUVariable* add_variables();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUVariable >&
      variables() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUVariable >*
      mutable_variables();
  
  // repeated .blox.compiler.gpu.GPUSequence sequences = 3;
  inline int sequences_size() const;
  inline void clear_sequences();
  static const int kSequencesFieldNumber = 3;
  inline const ::blox::compiler::gpu::GPUSequence& sequences(int index) const;
  inline ::blox::compiler::gpu::GPUSequence* mutable_sequences(int index);
  inline ::blox::compiler::gpu::GPUSequence* add_sequences();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUSequence >&
      sequences() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUSequence >*
      mutable_sequences();
  
  // required int32 entry = 4;
  inline bool has_entry() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 4;
  inline ::google::protobuf::int32 entry() const;
  inline void set_entry(::google::protobuf::int32 value);
  
  // required int32 exit = 5;
  inline bool has_exit() const;
  inline void clear_exit();
  static const int kExitFieldNumber = 5;
  inline ::google::protobuf::int32 exit() const;
  inline void set_exit(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUGraph)
 private:
  inline void set_has_graphname();
  inline void clear_has_graphname();
  inline void set_has_entry();
  inline void clear_has_entry();
  inline void set_has_exit();
  inline void clear_has_exit();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* graphname_;
  ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUVariable > variables_;
  ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUSequence > sequences_;
  ::google::protobuf::int32 entry_;
  ::google::protobuf::int32 exit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUGraph* default_instance_;
};
// -------------------------------------------------------------------

class GPUVariable : public ::google::protobuf::Message {
 public:
  GPUVariable();
  virtual ~GPUVariable();
  
  GPUVariable(const GPUVariable& from);
  
  inline GPUVariable& operator=(const GPUVariable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUVariable& default_instance();
  
  void Swap(GPUVariable* other);
  
  // implements Message ----------------------------------------------
  
  GPUVariable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUVariable& from);
  void MergeFrom(const GPUVariable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string varName = 1;
  inline bool has_varname() const;
  inline void clear_varname();
  static const int kVarNameFieldNumber = 1;
  inline const ::std::string& varname() const;
  inline void set_varname(const ::std::string& value);
  inline void set_varname(const char* value);
  inline void set_varname(const char* value, size_t size);
  inline ::std::string* mutable_varname();
  inline ::std::string* release_varname();
  
  // repeated .blox.common.protocol.Type keys = 2;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 2;
  inline const ::blox::common::protocol::Type& keys(int index) const;
  inline ::blox::common::protocol::Type* mutable_keys(int index);
  inline ::blox::common::protocol::Type* add_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Type >&
      keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Type >*
      mutable_keys();
  
  // repeated .blox.common.protocol.Type fields = 3;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 3;
  inline const ::blox::common::protocol::Type& fields(int index) const;
  inline ::blox::common::protocol::Type* mutable_fields(int index);
  inline ::blox::common::protocol::Type* add_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Type >&
      fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Type >*
      mutable_fields();
  
  // required bytes initialData = 4;
  inline bool has_initialdata() const;
  inline void clear_initialdata();
  static const int kInitialDataFieldNumber = 4;
  inline const ::std::string& initialdata() const;
  inline void set_initialdata(const ::std::string& value);
  inline void set_initialdata(const char* value);
  inline void set_initialdata(const void* value, size_t size);
  inline ::std::string* mutable_initialdata();
  inline ::std::string* release_initialdata();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUVariable)
 private:
  inline void set_has_varname();
  inline void clear_has_varname();
  inline void set_has_initialdata();
  inline void clear_has_initialdata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* varname_;
  ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Type > keys_;
  ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Type > fields_;
  ::std::string* initialdata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUVariable* default_instance_;
};
// -------------------------------------------------------------------

class GPUUnion : public ::google::protobuf::Message {
 public:
  GPUUnion();
  virtual ~GPUUnion();
  
  GPUUnion(const GPUUnion& from);
  
  inline GPUUnion& operator=(const GPUUnion& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUUnion& default_instance();
  
  void Swap(GPUUnion* other);
  
  // implements Message ----------------------------------------------
  
  GPUUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUUnion& from);
  void MergeFrom(const GPUUnion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string srcA = 2;
  inline bool has_srca() const;
  inline void clear_srca();
  static const int kSrcAFieldNumber = 2;
  inline const ::std::string& srca() const;
  inline void set_srca(const ::std::string& value);
  inline void set_srca(const char* value);
  inline void set_srca(const char* value, size_t size);
  inline ::std::string* mutable_srca();
  inline ::std::string* release_srca();
  
  // required string srcB = 3;
  inline bool has_srcb() const;
  inline void clear_srcb();
  static const int kSrcBFieldNumber = 3;
  inline const ::std::string& srcb() const;
  inline void set_srcb(const ::std::string& value);
  inline void set_srcb(const char* value);
  inline void set_srcb(const char* value, size_t size);
  inline ::std::string* mutable_srcb();
  inline ::std::string* release_srcb();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUUnion)
 private:
  inline void set_has_srca();
  inline void clear_has_srca();
  inline void set_has_srcb();
  inline void clear_has_srcb();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* srca_;
  ::std::string* srcb_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUUnion* default_instance_;
};
// -------------------------------------------------------------------

class GPUIntersection : public ::google::protobuf::Message {
 public:
  GPUIntersection();
  virtual ~GPUIntersection();
  
  GPUIntersection(const GPUIntersection& from);
  
  inline GPUIntersection& operator=(const GPUIntersection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUIntersection& default_instance();
  
  void Swap(GPUIntersection* other);
  
  // implements Message ----------------------------------------------
  
  GPUIntersection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUIntersection& from);
  void MergeFrom(const GPUIntersection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string srcA = 2;
  inline bool has_srca() const;
  inline void clear_srca();
  static const int kSrcAFieldNumber = 2;
  inline const ::std::string& srca() const;
  inline void set_srca(const ::std::string& value);
  inline void set_srca(const char* value);
  inline void set_srca(const char* value, size_t size);
  inline ::std::string* mutable_srca();
  inline ::std::string* release_srca();
  
  // required string srcB = 3;
  inline bool has_srcb() const;
  inline void clear_srcb();
  static const int kSrcBFieldNumber = 3;
  inline const ::std::string& srcb() const;
  inline void set_srcb(const ::std::string& value);
  inline void set_srcb(const char* value);
  inline void set_srcb(const char* value, size_t size);
  inline ::std::string* mutable_srcb();
  inline ::std::string* release_srcb();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUIntersection)
 private:
  inline void set_has_srca();
  inline void clear_has_srca();
  inline void set_has_srcb();
  inline void clear_has_srcb();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* srca_;
  ::std::string* srcb_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUIntersection* default_instance_;
};
// -------------------------------------------------------------------

class GPUProduct : public ::google::protobuf::Message {
 public:
  GPUProduct();
  virtual ~GPUProduct();
  
  GPUProduct(const GPUProduct& from);
  
  inline GPUProduct& operator=(const GPUProduct& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUProduct& default_instance();
  
  void Swap(GPUProduct* other);
  
  // implements Message ----------------------------------------------
  
  GPUProduct* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUProduct& from);
  void MergeFrom(const GPUProduct& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string srcA = 2;
  inline bool has_srca() const;
  inline void clear_srca();
  static const int kSrcAFieldNumber = 2;
  inline const ::std::string& srca() const;
  inline void set_srca(const ::std::string& value);
  inline void set_srca(const char* value);
  inline void set_srca(const char* value, size_t size);
  inline ::std::string* mutable_srca();
  inline ::std::string* release_srca();
  
  // required string srcB = 3;
  inline bool has_srcb() const;
  inline void clear_srcb();
  static const int kSrcBFieldNumber = 3;
  inline const ::std::string& srcb() const;
  inline void set_srcb(const ::std::string& value);
  inline void set_srcb(const char* value);
  inline void set_srcb(const char* value, size_t size);
  inline ::std::string* mutable_srcb();
  inline ::std::string* release_srcb();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUProduct)
 private:
  inline void set_has_srca();
  inline void clear_has_srca();
  inline void set_has_srcb();
  inline void clear_has_srcb();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* srca_;
  ::std::string* srcb_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUProduct* default_instance_;
};
// -------------------------------------------------------------------

class GPUSingle : public ::google::protobuf::Message {
 public:
  GPUSingle();
  virtual ~GPUSingle();
  
  GPUSingle(const GPUSingle& from);
  
  inline GPUSingle& operator=(const GPUSingle& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUSingle& default_instance();
  
  void Swap(GPUSingle* other);
  
  // implements Message ----------------------------------------------
  
  GPUSingle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUSingle& from);
  void MergeFrom(const GPUSingle& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .blox.common.protocol.Constant element = 1;
  inline int element_size() const;
  inline void clear_element();
  static const int kElementFieldNumber = 1;
  inline const ::blox::common::protocol::Constant& element(int index) const;
  inline ::blox::common::protocol::Constant* mutable_element(int index);
  inline ::blox::common::protocol::Constant* add_element();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Constant >&
      element() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Constant >*
      mutable_element();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUSingle)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Constant > element_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUSingle* default_instance_;
};
// -------------------------------------------------------------------

class GPUDifference : public ::google::protobuf::Message {
 public:
  GPUDifference();
  virtual ~GPUDifference();
  
  GPUDifference(const GPUDifference& from);
  
  inline GPUDifference& operator=(const GPUDifference& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUDifference& default_instance();
  
  void Swap(GPUDifference* other);
  
  // implements Message ----------------------------------------------
  
  GPUDifference* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUDifference& from);
  void MergeFrom(const GPUDifference& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string srcA = 3;
  inline bool has_srca() const;
  inline void clear_srca();
  static const int kSrcAFieldNumber = 3;
  inline const ::std::string& srca() const;
  inline void set_srca(const ::std::string& value);
  inline void set_srca(const char* value);
  inline void set_srca(const char* value, size_t size);
  inline ::std::string* mutable_srca();
  inline ::std::string* release_srca();
  
  // required string srcB = 4;
  inline bool has_srcb() const;
  inline void clear_srcb();
  static const int kSrcBFieldNumber = 4;
  inline const ::std::string& srcb() const;
  inline void set_srcb(const ::std::string& value);
  inline void set_srcb(const char* value);
  inline void set_srcb(const char* value, size_t size);
  inline ::std::string* mutable_srcb();
  inline ::std::string* release_srcb();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUDifference)
 private:
  inline void set_has_srca();
  inline void clear_has_srca();
  inline void set_has_srcb();
  inline void clear_has_srcb();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* srca_;
  ::std::string* srcb_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUDifference* default_instance_;
};
// -------------------------------------------------------------------

class GPUJoin : public ::google::protobuf::Message {
 public:
  GPUJoin();
  virtual ~GPUJoin();
  
  GPUJoin(const GPUJoin& from);
  
  inline GPUJoin& operator=(const GPUJoin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUJoin& default_instance();
  
  void Swap(GPUJoin* other);
  
  // implements Message ----------------------------------------------
  
  GPUJoin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUJoin& from);
  void MergeFrom(const GPUJoin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 keyCount = 2;
  inline bool has_keycount() const;
  inline void clear_keycount();
  static const int kKeyCountFieldNumber = 2;
  inline ::google::protobuf::int32 keycount() const;
  inline void set_keycount(::google::protobuf::int32 value);
  
  // required string srcA = 3;
  inline bool has_srca() const;
  inline void clear_srca();
  static const int kSrcAFieldNumber = 3;
  inline const ::std::string& srca() const;
  inline void set_srca(const ::std::string& value);
  inline void set_srca(const char* value);
  inline void set_srca(const char* value, size_t size);
  inline ::std::string* mutable_srca();
  inline ::std::string* release_srca();
  
  // required string srcB = 4;
  inline bool has_srcb() const;
  inline void clear_srcb();
  static const int kSrcBFieldNumber = 4;
  inline const ::std::string& srcb() const;
  inline void set_srcb(const ::std::string& value);
  inline void set_srcb(const char* value);
  inline void set_srcb(const char* value, size_t size);
  inline ::std::string* mutable_srcb();
  inline ::std::string* release_srcb();
  
  // repeated .blox.compiler.gpu.Exp args = 5;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 5;
  inline const ::blox::compiler::gpu::Exp& args(int index) const;
  inline ::blox::compiler::gpu::Exp* mutable_args(int index);
  inline ::blox::compiler::gpu::Exp* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUJoin)
 private:
  inline void set_has_keycount();
  inline void clear_has_keycount();
  inline void set_has_srca();
  inline void clear_has_srca();
  inline void set_has_srcb();
  inline void clear_has_srcb();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* srca_;
  ::std::string* srcb_;
  ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp > args_;
  ::google::protobuf::int32 keycount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUJoin* default_instance_;
};
// -------------------------------------------------------------------

class GPUMapFilter : public ::google::protobuf::Message {
 public:
  GPUMapFilter();
  virtual ~GPUMapFilter();
  
  GPUMapFilter(const GPUMapFilter& from);
  
  inline GPUMapFilter& operator=(const GPUMapFilter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUMapFilter& default_instance();
  
  void Swap(GPUMapFilter* other);
  
  // implements Message ----------------------------------------------
  
  GPUMapFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUMapFilter& from);
  void MergeFrom(const GPUMapFilter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 srcWidth = 2;
  inline bool has_srcwidth() const;
  inline void clear_srcwidth();
  static const int kSrcWidthFieldNumber = 2;
  inline ::google::protobuf::int32 srcwidth() const;
  inline void set_srcwidth(::google::protobuf::int32 value);
  
  // required .blox.compiler.gpu.Compare predicate = 3;
  inline bool has_predicate() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 3;
  inline const ::blox::compiler::gpu::Compare& predicate() const;
  inline ::blox::compiler::gpu::Compare* mutable_predicate();
  inline ::blox::compiler::gpu::Compare* release_predicate();
  
  // repeated .blox.compiler.gpu.Exp reordering = 4;
  inline int reordering_size() const;
  inline void clear_reordering();
  static const int kReorderingFieldNumber = 4;
  inline const ::blox::compiler::gpu::Exp& reordering(int index) const;
  inline ::blox::compiler::gpu::Exp* mutable_reordering(int index);
  inline ::blox::compiler::gpu::Exp* add_reordering();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >&
      reordering() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >*
      mutable_reordering();
  
  // required string srcA = 5;
  inline bool has_srca() const;
  inline void clear_srca();
  static const int kSrcAFieldNumber = 5;
  inline const ::std::string& srca() const;
  inline void set_srca(const ::std::string& value);
  inline void set_srca(const char* value);
  inline void set_srca(const char* value, size_t size);
  inline ::std::string* mutable_srca();
  inline ::std::string* release_srca();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUMapFilter)
 private:
  inline void set_has_srcwidth();
  inline void clear_has_srcwidth();
  inline void set_has_predicate();
  inline void clear_has_predicate();
  inline void set_has_srca();
  inline void clear_has_srca();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::compiler::gpu::Compare* predicate_;
  ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp > reordering_;
  ::std::string* srca_;
  ::google::protobuf::int32 srcwidth_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUMapFilter* default_instance_;
};
// -------------------------------------------------------------------

class GPUAgg : public ::google::protobuf::Message {
 public:
  GPUAgg();
  virtual ~GPUAgg();
  
  GPUAgg(const GPUAgg& from);
  
  inline GPUAgg& operator=(const GPUAgg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUAgg& default_instance();
  
  void Swap(GPUAgg* other);
  
  // implements Message ----------------------------------------------
  
  GPUAgg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUAgg& from);
  void MergeFrom(const GPUAgg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 srcWidth = 2;
  inline bool has_srcwidth() const;
  inline void clear_srcwidth();
  static const int kSrcWidthFieldNumber = 2;
  inline ::google::protobuf::int32 srcwidth() const;
  inline void set_srcwidth(::google::protobuf::int32 value);
  
  // repeated int32 domains = 3;
  inline int domains_size() const;
  inline void clear_domains();
  static const int kDomainsFieldNumber = 3;
  inline ::google::protobuf::int32 domains(int index) const;
  inline void set_domains(int index, ::google::protobuf::int32 value);
  inline void add_domains(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      domains() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_domains();
  
  // repeated .blox.compiler.gpu.Agg range = 4;
  inline int range_size() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 4;
  inline const ::blox::compiler::gpu::Agg& range(int index) const;
  inline ::blox::compiler::gpu::Agg* mutable_range(int index);
  inline ::blox::compiler::gpu::Agg* add_range();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Agg >&
      range() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Agg >*
      mutable_range();
  
  // required string srcA = 5;
  inline bool has_srca() const;
  inline void clear_srca();
  static const int kSrcAFieldNumber = 5;
  inline const ::std::string& srca() const;
  inline void set_srca(const ::std::string& value);
  inline void set_srca(const char* value);
  inline void set_srca(const char* value, size_t size);
  inline ::std::string* mutable_srca();
  inline ::std::string* release_srca();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUAgg)
 private:
  inline void set_has_srcwidth();
  inline void clear_has_srcwidth();
  inline void set_has_srca();
  inline void clear_has_srca();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > domains_;
  ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Agg > range_;
  ::std::string* srca_;
  ::google::protobuf::int32 srcwidth_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUAgg* default_instance_;
};
// -------------------------------------------------------------------

class GPUOperator : public ::google::protobuf::Message {
 public:
  GPUOperator();
  virtual ~GPUOperator();
  
  GPUOperator(const GPUOperator& from);
  
  inline GPUOperator& operator=(const GPUOperator& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUOperator& default_instance();
  
  void Swap(GPUOperator* other);
  
  // implements Message ----------------------------------------------
  
  GPUOperator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUOperator& from);
  void MergeFrom(const GPUOperator& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.OperatorTag tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline blox::compiler::gpu::OperatorTag tag() const;
  inline void set_tag(blox::compiler::gpu::OperatorTag value);
  
  // optional .blox.compiler.gpu.GPUUnion unionop = 2;
  inline bool has_unionop() const;
  inline void clear_unionop();
  static const int kUnionopFieldNumber = 2;
  inline const ::blox::compiler::gpu::GPUUnion& unionop() const;
  inline ::blox::compiler::gpu::GPUUnion* mutable_unionop();
  inline ::blox::compiler::gpu::GPUUnion* release_unionop();
  
  // optional .blox.compiler.gpu.GPUIntersection intersection = 3;
  inline bool has_intersection() const;
  inline void clear_intersection();
  static const int kIntersectionFieldNumber = 3;
  inline const ::blox::compiler::gpu::GPUIntersection& intersection() const;
  inline ::blox::compiler::gpu::GPUIntersection* mutable_intersection();
  inline ::blox::compiler::gpu::GPUIntersection* release_intersection();
  
  // optional .blox.compiler.gpu.GPUProduct product = 4;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 4;
  inline const ::blox::compiler::gpu::GPUProduct& product() const;
  inline ::blox::compiler::gpu::GPUProduct* mutable_product();
  inline ::blox::compiler::gpu::GPUProduct* release_product();
  
  // optional .blox.compiler.gpu.GPUSingle single = 5;
  inline bool has_single() const;
  inline void clear_single();
  static const int kSingleFieldNumber = 5;
  inline const ::blox::compiler::gpu::GPUSingle& single() const;
  inline ::blox::compiler::gpu::GPUSingle* mutable_single();
  inline ::blox::compiler::gpu::GPUSingle* release_single();
  
  // optional .blox.compiler.gpu.GPUDifference difference = 6;
  inline bool has_difference() const;
  inline void clear_difference();
  static const int kDifferenceFieldNumber = 6;
  inline const ::blox::compiler::gpu::GPUDifference& difference() const;
  inline ::blox::compiler::gpu::GPUDifference* mutable_difference();
  inline ::blox::compiler::gpu::GPUDifference* release_difference();
  
  // optional .blox.compiler.gpu.GPUJoin join = 7;
  inline bool has_join() const;
  inline void clear_join();
  static const int kJoinFieldNumber = 7;
  inline const ::blox::compiler::gpu::GPUJoin& join() const;
  inline ::blox::compiler::gpu::GPUJoin* mutable_join();
  inline ::blox::compiler::gpu::GPUJoin* release_join();
  
  // optional .blox.compiler.gpu.GPUMapFilter mapfilter = 10;
  inline bool has_mapfilter() const;
  inline void clear_mapfilter();
  static const int kMapfilterFieldNumber = 10;
  inline const ::blox::compiler::gpu::GPUMapFilter& mapfilter() const;
  inline ::blox::compiler::gpu::GPUMapFilter* mutable_mapfilter();
  inline ::blox::compiler::gpu::GPUMapFilter* release_mapfilter();
  
  // optional .blox.compiler.gpu.GPUAgg agg = 11;
  inline bool has_agg() const;
  inline void clear_agg();
  static const int kAggFieldNumber = 11;
  inline const ::blox::compiler::gpu::GPUAgg& agg() const;
  inline ::blox::compiler::gpu::GPUAgg* mutable_agg();
  inline ::blox::compiler::gpu::GPUAgg* release_agg();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUOperator)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_unionop();
  inline void clear_has_unionop();
  inline void set_has_intersection();
  inline void clear_has_intersection();
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_single();
  inline void clear_has_single();
  inline void set_has_difference();
  inline void clear_has_difference();
  inline void set_has_join();
  inline void clear_has_join();
  inline void set_has_mapfilter();
  inline void clear_has_mapfilter();
  inline void set_has_agg();
  inline void clear_has_agg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::compiler::gpu::GPUUnion* unionop_;
  ::blox::compiler::gpu::GPUIntersection* intersection_;
  ::blox::compiler::gpu::GPUProduct* product_;
  ::blox::compiler::gpu::GPUSingle* single_;
  ::blox::compiler::gpu::GPUDifference* difference_;
  ::blox::compiler::gpu::GPUJoin* join_;
  ::blox::compiler::gpu::GPUMapFilter* mapfilter_;
  ::blox::compiler::gpu::GPUAgg* agg_;
  int tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUOperator* default_instance_;
};
// -------------------------------------------------------------------

class GPUAssign : public ::google::protobuf::Message {
 public:
  GPUAssign();
  virtual ~GPUAssign();
  
  GPUAssign(const GPUAssign& from);
  
  inline GPUAssign& operator=(const GPUAssign& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUAssign& default_instance();
  
  void Swap(GPUAssign* other);
  
  // implements Message ----------------------------------------------
  
  GPUAssign* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUAssign& from);
  void MergeFrom(const GPUAssign& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string dest = 1;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 1;
  inline const ::std::string& dest() const;
  inline void set_dest(const ::std::string& value);
  inline void set_dest(const char* value);
  inline void set_dest(const char* value, size_t size);
  inline ::std::string* mutable_dest();
  inline ::std::string* release_dest();
  
  // required .blox.compiler.gpu.GPUOperator op = 2;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 2;
  inline const ::blox::compiler::gpu::GPUOperator& op() const;
  inline ::blox::compiler::gpu::GPUOperator* mutable_op();
  inline ::blox::compiler::gpu::GPUOperator* release_op();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUAssign)
 private:
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_op();
  inline void clear_has_op();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* dest_;
  ::blox::compiler::gpu::GPUOperator* op_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUAssign* default_instance_;
};
// -------------------------------------------------------------------

class GPUCond : public ::google::protobuf::Message {
 public:
  GPUCond();
  virtual ~GPUCond();
  
  GPUCond(const GPUCond& from);
  
  inline GPUCond& operator=(const GPUCond& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUCond& default_instance();
  
  void Swap(GPUCond* other);
  
  // implements Message ----------------------------------------------
  
  GPUCond* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUCond& from);
  void MergeFrom(const GPUCond& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string src1 = 1;
  inline bool has_src1() const;
  inline void clear_src1();
  static const int kSrc1FieldNumber = 1;
  inline const ::std::string& src1() const;
  inline void set_src1(const ::std::string& value);
  inline void set_src1(const char* value);
  inline void set_src1(const char* value, size_t size);
  inline ::std::string* mutable_src1();
  inline ::std::string* release_src1();
  
  // required string src2 = 2;
  inline bool has_src2() const;
  inline void clear_src2();
  static const int kSrc2FieldNumber = 2;
  inline const ::std::string& src2() const;
  inline void set_src2(const ::std::string& value);
  inline void set_src2(const char* value);
  inline void set_src2(const char* value, size_t size);
  inline ::std::string* mutable_src2();
  inline ::std::string* release_src2();
  
  // required int32 yes = 3;
  inline bool has_yes() const;
  inline void clear_yes();
  static const int kYesFieldNumber = 3;
  inline ::google::protobuf::int32 yes() const;
  inline void set_yes(::google::protobuf::int32 value);
  
  // required int32 no = 4;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 4;
  inline ::google::protobuf::int32 no() const;
  inline void set_no(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUCond)
 private:
  inline void set_has_src1();
  inline void clear_has_src1();
  inline void set_has_src2();
  inline void clear_has_src2();
  inline void set_has_yes();
  inline void clear_has_yes();
  inline void set_has_no();
  inline void clear_has_no();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* src1_;
  ::std::string* src2_;
  ::google::protobuf::int32 yes_;
  ::google::protobuf::int32 no_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUCond* default_instance_;
};
// -------------------------------------------------------------------

class GPUGoto : public ::google::protobuf::Message {
 public:
  GPUGoto();
  virtual ~GPUGoto();
  
  GPUGoto(const GPUGoto& from);
  
  inline GPUGoto& operator=(const GPUGoto& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUGoto& default_instance();
  
  void Swap(GPUGoto* other);
  
  // implements Message ----------------------------------------------
  
  GPUGoto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUGoto& from);
  void MergeFrom(const GPUGoto& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline ::google::protobuf::int32 target() const;
  inline void set_target(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUGoto)
 private:
  inline void set_has_target();
  inline void clear_has_target();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 target_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUGoto* default_instance_;
};
// -------------------------------------------------------------------

class GPUMove : public ::google::protobuf::Message {
 public:
  GPUMove();
  virtual ~GPUMove();
  
  GPUMove(const GPUMove& from);
  
  inline GPUMove& operator=(const GPUMove& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUMove& default_instance();
  
  void Swap(GPUMove* other);
  
  // implements Message ----------------------------------------------
  
  GPUMove* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUMove& from);
  void MergeFrom(const GPUMove& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string dest = 1;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 1;
  inline const ::std::string& dest() const;
  inline void set_dest(const ::std::string& value);
  inline void set_dest(const char* value);
  inline void set_dest(const char* value, size_t size);
  inline ::std::string* mutable_dest();
  inline ::std::string* release_dest();
  
  // required string src1 = 2;
  inline bool has_src1() const;
  inline void clear_src1();
  static const int kSrc1FieldNumber = 2;
  inline const ::std::string& src1() const;
  inline void set_src1(const ::std::string& value);
  inline void set_src1(const char* value);
  inline void set_src1(const char* value, size_t size);
  inline ::std::string* mutable_src1();
  inline ::std::string* release_src1();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUMove)
 private:
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_src1();
  inline void clear_has_src1();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* dest_;
  ::std::string* src1_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUMove* default_instance_;
};
// -------------------------------------------------------------------

class GPUCommand : public ::google::protobuf::Message {
 public:
  GPUCommand();
  virtual ~GPUCommand();
  
  GPUCommand(const GPUCommand& from);
  
  inline GPUCommand& operator=(const GPUCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUCommand& default_instance();
  
  void Swap(GPUCommand* other);
  
  // implements Message ----------------------------------------------
  
  GPUCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUCommand& from);
  void MergeFrom(const GPUCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.CommandTag tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline blox::compiler::gpu::CommandTag tag() const;
  inline void set_tag(blox::compiler::gpu::CommandTag value);
  
  // optional .blox.compiler.gpu.GPUAssign assign = 2;
  inline bool has_assign() const;
  inline void clear_assign();
  static const int kAssignFieldNumber = 2;
  inline const ::blox::compiler::gpu::GPUAssign& assign() const;
  inline ::blox::compiler::gpu::GPUAssign* mutable_assign();
  inline ::blox::compiler::gpu::GPUAssign* release_assign();
  
  // optional .blox.compiler.gpu.GPUCond cond = 3;
  inline bool has_cond() const;
  inline void clear_cond();
  static const int kCondFieldNumber = 3;
  inline const ::blox::compiler::gpu::GPUCond& cond() const;
  inline ::blox::compiler::gpu::GPUCond* mutable_cond();
  inline ::blox::compiler::gpu::GPUCond* release_cond();
  
  // optional .blox.compiler.gpu.GPUGoto jump = 4;
  inline bool has_jump() const;
  inline void clear_jump();
  static const int kJumpFieldNumber = 4;
  inline const ::blox::compiler::gpu::GPUGoto& jump() const;
  inline ::blox::compiler::gpu::GPUGoto* mutable_jump();
  inline ::blox::compiler::gpu::GPUGoto* release_jump();
  
  // optional .blox.compiler.gpu.GPUMove move = 5;
  inline bool has_move() const;
  inline void clear_move();
  static const int kMoveFieldNumber = 5;
  inline const ::blox::compiler::gpu::GPUMove& move() const;
  inline ::blox::compiler::gpu::GPUMove* mutable_move();
  inline ::blox::compiler::gpu::GPUMove* release_move();
  
  // optional int32 halt = 6;
  inline bool has_halt() const;
  inline void clear_halt();
  static const int kHaltFieldNumber = 6;
  inline ::google::protobuf::int32 halt() const;
  inline void set_halt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUCommand)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_assign();
  inline void clear_has_assign();
  inline void set_has_cond();
  inline void clear_has_cond();
  inline void set_has_jump();
  inline void clear_has_jump();
  inline void set_has_move();
  inline void clear_has_move();
  inline void set_has_halt();
  inline void clear_has_halt();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::compiler::gpu::GPUAssign* assign_;
  ::blox::compiler::gpu::GPUCond* cond_;
  int tag_;
  ::google::protobuf::int32 halt_;
  ::blox::compiler::gpu::GPUGoto* jump_;
  ::blox::compiler::gpu::GPUMove* move_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUCommand* default_instance_;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();
  
  Address(const Address& from);
  
  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();
  
  void Swap(Address* other);
  
  // implements Message ----------------------------------------------
  
  Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.AddressTag tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline blox::compiler::gpu::AddressTag tag() const;
  inline void set_tag(blox::compiler::gpu::AddressTag value);
  
  // optional int32 varaddr = 2;
  inline bool has_varaddr() const;
  inline void clear_varaddr();
  static const int kVaraddrFieldNumber = 2;
  inline ::google::protobuf::int32 varaddr() const;
  inline void set_varaddr(::google::protobuf::int32 value);
  
  // optional .blox.common.protocol.Constant constaddr = 3;
  inline bool has_constaddr() const;
  inline void clear_constaddr();
  static const int kConstaddrFieldNumber = 3;
  inline const ::blox::common::protocol::Constant& constaddr() const;
  inline ::blox::common::protocol::Constant* mutable_constaddr();
  inline ::blox::common::protocol::Constant* release_constaddr();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Address)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_varaddr();
  inline void clear_has_varaddr();
  inline void set_has_constaddr();
  inline void clear_has_constaddr();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int tag_;
  ::google::protobuf::int32 varaddr_;
  ::blox::common::protocol::Constant* constaddr_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class GPUCompare : public ::google::protobuf::Message {
 public:
  GPUCompare();
  virtual ~GPUCompare();
  
  GPUCompare(const GPUCompare& from);
  
  inline GPUCompare& operator=(const GPUCompare& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUCompare& default_instance();
  
  void Swap(GPUCompare* other);
  
  // implements Message ----------------------------------------------
  
  GPUCompare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUCompare& from);
  void MergeFrom(const GPUCompare& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.Comparison comparison = 1;
  inline bool has_comparison() const;
  inline void clear_comparison();
  static const int kComparisonFieldNumber = 1;
  inline blox::compiler::gpu::Comparison comparison() const;
  inline void set_comparison(blox::compiler::gpu::Comparison value);
  
  // required .blox.common.protocol.PrimitiveType optype = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOptypeFieldNumber = 2;
  inline const ::blox::common::protocol::PrimitiveType& optype() const;
  inline ::blox::common::protocol::PrimitiveType* mutable_optype();
  inline ::blox::common::protocol::PrimitiveType* release_optype();
  
  // required .blox.compiler.gpu.Address addr1 = 3;
  inline bool has_addr1() const;
  inline void clear_addr1();
  static const int kAddr1FieldNumber = 3;
  inline const ::blox::compiler::gpu::Address& addr1() const;
  inline ::blox::compiler::gpu::Address* mutable_addr1();
  inline ::blox::compiler::gpu::Address* release_addr1();
  
  // required .blox.compiler.gpu.Address addr2 = 4;
  inline bool has_addr2() const;
  inline void clear_addr2();
  static const int kAddr2FieldNumber = 4;
  inline const ::blox::compiler::gpu::Address& addr2() const;
  inline ::blox::compiler::gpu::Address* mutable_addr2();
  inline ::blox::compiler::gpu::Address* release_addr2();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUCompare)
 private:
  inline void set_has_comparison();
  inline void clear_has_comparison();
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_addr1();
  inline void clear_has_addr1();
  inline void set_has_addr2();
  inline void clear_has_addr2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::common::protocol::PrimitiveType* optype_;
  ::blox::compiler::gpu::Address* addr1_;
  ::blox::compiler::gpu::Address* addr2_;
  int comparison_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUCompare* default_instance_;
};
// -------------------------------------------------------------------

class GPUSequence : public ::google::protobuf::Message {
 public:
  GPUSequence();
  virtual ~GPUSequence();
  
  GPUSequence(const GPUSequence& from);
  
  inline GPUSequence& operator=(const GPUSequence& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUSequence& default_instance();
  
  void Swap(GPUSequence* other);
  
  // implements Message ----------------------------------------------
  
  GPUSequence* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUSequence& from);
  void MergeFrom(const GPUSequence& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 uniqueIdentifier = 1;
  inline bool has_uniqueidentifier() const;
  inline void clear_uniqueidentifier();
  static const int kUniqueIdentifierFieldNumber = 1;
  inline ::google::protobuf::int32 uniqueidentifier() const;
  inline void set_uniqueidentifier(::google::protobuf::int32 value);
  
  // repeated .blox.compiler.gpu.GPUCommand operators = 2;
  inline int operators_size() const;
  inline void clear_operators();
  static const int kOperatorsFieldNumber = 2;
  inline const ::blox::compiler::gpu::GPUCommand& operators(int index) const;
  inline ::blox::compiler::gpu::GPUCommand* mutable_operators(int index);
  inline ::blox::compiler::gpu::GPUCommand* add_operators();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUCommand >&
      operators() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUCommand >*
      mutable_operators();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.GPUSequence)
 private:
  inline void set_has_uniqueidentifier();
  inline void clear_has_uniqueidentifier();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUCommand > operators_;
  ::google::protobuf::int32 uniqueidentifier_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static GPUSequence* default_instance_;
};
// -------------------------------------------------------------------

class NumType : public ::google::protobuf::Message {
 public:
  NumType();
  virtual ~NumType();
  
  NumType(const NumType& from);
  
  inline NumType& operator=(const NumType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NumType& default_instance();
  
  void Swap(NumType* other);
  
  // implements Message ----------------------------------------------
  
  NumType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NumType& from);
  void MergeFrom(const NumType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.Numeric typ = 1;
  inline bool has_typ() const;
  inline void clear_typ();
  static const int kTypFieldNumber = 1;
  inline blox::compiler::gpu::Numeric typ() const;
  inline void set_typ(blox::compiler::gpu::Numeric value);
  
  // required int32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.NumType)
 private:
  inline void set_has_typ();
  inline void clear_has_typ();
  inline void set_has_size();
  inline void clear_has_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int typ_;
  ::google::protobuf::int32 size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static NumType* default_instance_;
};
// -------------------------------------------------------------------

class Univ : public ::google::protobuf::Message {
 public:
  Univ();
  virtual ~Univ();
  
  Univ(const Univ& from);
  
  inline Univ& operator=(const Univ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Univ& default_instance();
  
  void Swap(Univ* other);
  
  // implements Message ----------------------------------------------
  
  Univ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Univ& from);
  void MergeFrom(const Univ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.UnivTag tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline blox::compiler::gpu::UnivTag tag() const;
  inline void set_tag(blox::compiler::gpu::UnivTag value);
  
  // optional .blox.compiler.gpu.NumType n = 2;
  inline bool has_n() const;
  inline void clear_n();
  static const int kNFieldNumber = 2;
  inline const ::blox::compiler::gpu::NumType& n() const;
  inline ::blox::compiler::gpu::NumType* mutable_n();
  inline ::blox::compiler::gpu::NumType* release_n();
  
  // optional .blox.compiler.gpu.Fixed f = 3;
  inline bool has_f() const;
  inline void clear_f();
  static const int kFFieldNumber = 3;
  inline blox::compiler::gpu::Fixed f() const;
  inline void set_f(blox::compiler::gpu::Fixed value);
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Univ)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_n();
  inline void clear_has_n();
  inline void set_has_f();
  inline void clear_has_f();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::compiler::gpu::NumType* n_;
  int tag_;
  int f_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Univ* default_instance_;
};
// -------------------------------------------------------------------

class ConstExp : public ::google::protobuf::Message {
 public:
  ConstExp();
  virtual ~ConstExp();
  
  ConstExp(const ConstExp& from);
  
  inline ConstExp& operator=(const ConstExp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstExp& default_instance();
  
  void Swap(ConstExp* other);
  
  // implements Message ----------------------------------------------
  
  ConstExp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConstExp& from);
  void MergeFrom(const ConstExp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.common.protocol.Constant literal = 1;
  inline bool has_literal() const;
  inline void clear_literal();
  static const int kLiteralFieldNumber = 1;
  inline const ::blox::common::protocol::Constant& literal() const;
  inline ::blox::common::protocol::Constant* mutable_literal();
  inline ::blox::common::protocol::Constant* release_literal();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.ConstExp)
 private:
  inline void set_has_literal();
  inline void clear_has_literal();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::common::protocol::Constant* literal_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static ConstExp* default_instance_;
};
// -------------------------------------------------------------------

class Name : public ::google::protobuf::Message {
 public:
  Name();
  virtual ~Name();
  
  Name(const Name& from);
  
  inline Name& operator=(const Name& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Name& default_instance();
  
  void Swap(Name* other);
  
  // implements Message ----------------------------------------------
  
  Name* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Name& from);
  void MergeFrom(const Name& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ename = 1;
  inline bool has_ename() const;
  inline void clear_ename();
  static const int kEnameFieldNumber = 1;
  inline const ::std::string& ename() const;
  inline void set_ename(const ::std::string& value);
  inline void set_ename(const char* value);
  inline void set_ename(const char* value, size_t size);
  inline ::std::string* mutable_ename();
  inline ::std::string* release_ename();
  
  // required .blox.common.protocol.Type etype = 2;
  inline bool has_etype() const;
  inline void clear_etype();
  static const int kEtypeFieldNumber = 2;
  inline const ::blox::common::protocol::Type& etype() const;
  inline ::blox::common::protocol::Type* mutable_etype();
  inline ::blox::common::protocol::Type* release_etype();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Name)
 private:
  inline void set_has_ename();
  inline void clear_has_ename();
  inline void set_has_etype();
  inline void clear_has_etype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ename_;
  ::blox::common::protocol::Type* etype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Name* default_instance_;
};
// -------------------------------------------------------------------

class Index : public ::google::protobuf::Message {
 public:
  Index();
  virtual ~Index();
  
  Index(const Index& from);
  
  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Index& default_instance();
  
  void Swap(Index* other);
  
  // implements Message ----------------------------------------------
  
  Index* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Index& from);
  void MergeFrom(const Index& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);
  
  // required .blox.common.protocol.Type etyp = 2;
  inline bool has_etyp() const;
  inline void clear_etyp();
  static const int kEtypFieldNumber = 2;
  inline const ::blox::common::protocol::Type& etyp() const;
  inline ::blox::common::protocol::Type* mutable_etyp();
  inline ::blox::common::protocol::Type* release_etyp();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Index)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_etyp();
  inline void clear_has_etyp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::common::protocol::Type* etyp_;
  ::google::protobuf::int32 offset_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Index* default_instance_;
};
// -------------------------------------------------------------------

class ArithExp : public ::google::protobuf::Message {
 public:
  ArithExp();
  virtual ~ArithExp();
  
  ArithExp(const ArithExp& from);
  
  inline ArithExp& operator=(const ArithExp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArithExp& default_instance();
  
  void Swap(ArithExp* other);
  
  // implements Message ----------------------------------------------
  
  ArithExp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArithExp& from);
  void MergeFrom(const ArithExp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.NumType domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::blox::compiler::gpu::NumType& domain() const;
  inline ::blox::compiler::gpu::NumType* mutable_domain();
  inline ::blox::compiler::gpu::NumType* release_domain();
  
  // required .blox.compiler.gpu.ArithmeticOp op = 2;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 2;
  inline blox::compiler::gpu::ArithmeticOp op() const;
  inline void set_op(blox::compiler::gpu::ArithmeticOp value);
  
  // required .blox.compiler.gpu.Exp exp1 = 3;
  inline bool has_exp1() const;
  inline void clear_exp1();
  static const int kExp1FieldNumber = 3;
  inline const ::blox::compiler::gpu::Exp& exp1() const;
  inline ::blox::compiler::gpu::Exp* mutable_exp1();
  inline ::blox::compiler::gpu::Exp* release_exp1();
  
  // required .blox.compiler.gpu.Exp exp2 = 4;
  inline bool has_exp2() const;
  inline void clear_exp2();
  static const int kExp2FieldNumber = 4;
  inline const ::blox::compiler::gpu::Exp& exp2() const;
  inline ::blox::compiler::gpu::Exp* mutable_exp2();
  inline ::blox::compiler::gpu::Exp* release_exp2();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.ArithExp)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_exp1();
  inline void clear_has_exp1();
  inline void set_has_exp2();
  inline void clear_has_exp2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::compiler::gpu::NumType* domain_;
  ::blox::compiler::gpu::Exp* exp1_;
  ::blox::compiler::gpu::Exp* exp2_;
  int op_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static ArithExp* default_instance_;
};
// -------------------------------------------------------------------

class Convert : public ::google::protobuf::Message {
 public:
  Convert();
  virtual ~Convert();
  
  Convert(const Convert& from);
  
  inline Convert& operator=(const Convert& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Convert& default_instance();
  
  void Swap(Convert* other);
  
  // implements Message ----------------------------------------------
  
  Convert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Convert& from);
  void MergeFrom(const Convert& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.Univ convDom = 1;
  inline bool has_convdom() const;
  inline void clear_convdom();
  static const int kConvDomFieldNumber = 1;
  inline const ::blox::compiler::gpu::Univ& convdom() const;
  inline ::blox::compiler::gpu::Univ* mutable_convdom();
  inline ::blox::compiler::gpu::Univ* release_convdom();
  
  // required .blox.compiler.gpu.Univ convRng = 2;
  inline bool has_convrng() const;
  inline void clear_convrng();
  static const int kConvRngFieldNumber = 2;
  inline const ::blox::compiler::gpu::Univ& convrng() const;
  inline ::blox::compiler::gpu::Univ* mutable_convrng();
  inline ::blox::compiler::gpu::Univ* release_convrng();
  
  // required .blox.compiler.gpu.Exp exp2 = 3;
  inline bool has_exp2() const;
  inline void clear_exp2();
  static const int kExp2FieldNumber = 3;
  inline const ::blox::compiler::gpu::Exp& exp2() const;
  inline ::blox::compiler::gpu::Exp* mutable_exp2();
  inline ::blox::compiler::gpu::Exp* release_exp2();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Convert)
 private:
  inline void set_has_convdom();
  inline void clear_has_convdom();
  inline void set_has_convrng();
  inline void clear_has_convrng();
  inline void set_has_exp2();
  inline void clear_has_exp2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::compiler::gpu::Univ* convdom_;
  ::blox::compiler::gpu::Univ* convrng_;
  ::blox::compiler::gpu::Exp* exp2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Convert* default_instance_;
};
// -------------------------------------------------------------------

class Mixed : public ::google::protobuf::Message {
 public:
  Mixed();
  virtual ~Mixed();
  
  Mixed(const Mixed& from);
  
  inline Mixed& operator=(const Mixed& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mixed& default_instance();
  
  void Swap(Mixed* other);
  
  // implements Message ----------------------------------------------
  
  Mixed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mixed& from);
  void MergeFrom(const Mixed& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.NumType domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::blox::compiler::gpu::NumType& domain() const;
  inline ::blox::compiler::gpu::NumType* mutable_domain();
  inline ::blox::compiler::gpu::NumType* release_domain();
  
  // required .blox.compiler.gpu.NumType range = 2;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 2;
  inline const ::blox::compiler::gpu::NumType& range() const;
  inline ::blox::compiler::gpu::NumType* mutable_range();
  inline ::blox::compiler::gpu::NumType* release_range();
  
  // required .blox.compiler.gpu.Exp exp1 = 3;
  inline bool has_exp1() const;
  inline void clear_exp1();
  static const int kExp1FieldNumber = 3;
  inline const ::blox::compiler::gpu::Exp& exp1() const;
  inline ::blox::compiler::gpu::Exp* mutable_exp1();
  inline ::blox::compiler::gpu::Exp* release_exp1();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Mixed)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_exp1();
  inline void clear_has_exp1();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::compiler::gpu::NumType* domain_;
  ::blox::compiler::gpu::NumType* range_;
  ::blox::compiler::gpu::Exp* exp1_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Mixed* default_instance_;
};
// -------------------------------------------------------------------

class Call : public ::google::protobuf::Message {
 public:
  Call();
  virtual ~Call();
  
  Call(const Call& from);
  
  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call& default_instance();
  
  void Swap(Call* other);
  
  // implements Message ----------------------------------------------
  
  Call* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call& from);
  void MergeFrom(const Call& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.Fixed calltype = 1;
  inline bool has_calltype() const;
  inline void clear_calltype();
  static const int kCalltypeFieldNumber = 1;
  inline blox::compiler::gpu::Fixed calltype() const;
  inline void set_calltype(blox::compiler::gpu::Fixed value);
  
  // required string callname = 2;
  inline bool has_callname() const;
  inline void clear_callname();
  static const int kCallnameFieldNumber = 2;
  inline const ::std::string& callname() const;
  inline void set_callname(const ::std::string& value);
  inline void set_callname(const char* value);
  inline void set_callname(const char* value, size_t size);
  inline ::std::string* mutable_callname();
  inline ::std::string* release_callname();
  
  // repeated .blox.compiler.gpu.Exp args = 3;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 3;
  inline const ::blox::compiler::gpu::Exp& args(int index) const;
  inline ::blox::compiler::gpu::Exp* mutable_args(int index);
  inline ::blox::compiler::gpu::Exp* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Call)
 private:
  inline void set_has_calltype();
  inline void clear_has_calltype();
  inline void set_has_callname();
  inline void clear_has_callname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* callname_;
  ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp > args_;
  int calltype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Call* default_instance_;
};
// -------------------------------------------------------------------

class Exp : public ::google::protobuf::Message {
 public:
  Exp();
  virtual ~Exp();
  
  Exp(const Exp& from);
  
  inline Exp& operator=(const Exp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Exp& default_instance();
  
  void Swap(Exp* other);
  
  // implements Message ----------------------------------------------
  
  Exp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Exp& from);
  void MergeFrom(const Exp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.ExpTag tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline blox::compiler::gpu::ExpTag tag() const;
  inline void set_tag(blox::compiler::gpu::ExpTag value);
  
  // optional .blox.compiler.gpu.ConstExp constExp = 2;
  inline bool has_constexp() const;
  inline void clear_constexp();
  static const int kConstExpFieldNumber = 2;
  inline const ::blox::compiler::gpu::ConstExp& constexp() const;
  inline ::blox::compiler::gpu::ConstExp* mutable_constexp();
  inline ::blox::compiler::gpu::ConstExp* release_constexp();
  
  // optional .blox.compiler.gpu.Index index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline const ::blox::compiler::gpu::Index& index() const;
  inline ::blox::compiler::gpu::Index* mutable_index();
  inline ::blox::compiler::gpu::Index* release_index();
  
  // optional .blox.compiler.gpu.Name name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::blox::compiler::gpu::Name& name() const;
  inline ::blox::compiler::gpu::Name* mutable_name();
  inline ::blox::compiler::gpu::Name* release_name();
  
  // optional .blox.compiler.gpu.ArithExp arithexp = 5;
  inline bool has_arithexp() const;
  inline void clear_arithexp();
  static const int kArithexpFieldNumber = 5;
  inline const ::blox::compiler::gpu::ArithExp& arithexp() const;
  inline ::blox::compiler::gpu::ArithExp* mutable_arithexp();
  inline ::blox::compiler::gpu::ArithExp* release_arithexp();
  
  // optional .blox.compiler.gpu.Convert convert = 6;
  inline bool has_convert() const;
  inline void clear_convert();
  static const int kConvertFieldNumber = 6;
  inline const ::blox::compiler::gpu::Convert& convert() const;
  inline ::blox::compiler::gpu::Convert* mutable_convert();
  inline ::blox::compiler::gpu::Convert* release_convert();
  
  // optional .blox.compiler.gpu.Mixed mixed = 7;
  inline bool has_mixed() const;
  inline void clear_mixed();
  static const int kMixedFieldNumber = 7;
  inline const ::blox::compiler::gpu::Mixed& mixed() const;
  inline ::blox::compiler::gpu::Mixed* mutable_mixed();
  inline ::blox::compiler::gpu::Mixed* release_mixed();
  
  // optional .blox.compiler.gpu.Call call = 8;
  inline bool has_call() const;
  inline void clear_call();
  static const int kCallFieldNumber = 8;
  inline const ::blox::compiler::gpu::Call& call() const;
  inline ::blox::compiler::gpu::Call* mutable_call();
  inline ::blox::compiler::gpu::Call* release_call();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Exp)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_constexp();
  inline void clear_has_constexp();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_arithexp();
  inline void clear_has_arithexp();
  inline void set_has_convert();
  inline void clear_has_convert();
  inline void set_has_mixed();
  inline void clear_has_mixed();
  inline void set_has_call();
  inline void clear_has_call();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::compiler::gpu::ConstExp* constexp_;
  ::blox::compiler::gpu::Index* index_;
  ::blox::compiler::gpu::Name* name_;
  ::blox::compiler::gpu::ArithExp* arithexp_;
  ::blox::compiler::gpu::Convert* convert_;
  ::blox::compiler::gpu::Mixed* mixed_;
  ::blox::compiler::gpu::Call* call_;
  int tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Exp* default_instance_;
};
// -------------------------------------------------------------------

class Comp : public ::google::protobuf::Message {
 public:
  Comp();
  virtual ~Comp();
  
  Comp(const Comp& from);
  
  inline Comp& operator=(const Comp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Comp& default_instance();
  
  void Swap(Comp* other);
  
  // implements Message ----------------------------------------------
  
  Comp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Comp& from);
  void MergeFrom(const Comp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.Comparison comparison = 1;
  inline bool has_comparison() const;
  inline void clear_comparison();
  static const int kComparisonFieldNumber = 1;
  inline blox::compiler::gpu::Comparison comparison() const;
  inline void set_comparison(blox::compiler::gpu::Comparison value);
  
  // required .blox.compiler.gpu.Exp op1 = 2;
  inline bool has_op1() const;
  inline void clear_op1();
  static const int kOp1FieldNumber = 2;
  inline const ::blox::compiler::gpu::Exp& op1() const;
  inline ::blox::compiler::gpu::Exp* mutable_op1();
  inline ::blox::compiler::gpu::Exp* release_op1();
  
  // required .blox.compiler.gpu.Exp op2 = 3;
  inline bool has_op2() const;
  inline void clear_op2();
  static const int kOp2FieldNumber = 3;
  inline const ::blox::compiler::gpu::Exp& op2() const;
  inline ::blox::compiler::gpu::Exp* mutable_op2();
  inline ::blox::compiler::gpu::Exp* release_op2();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Comp)
 private:
  inline void set_has_comparison();
  inline void clear_has_comparison();
  inline void set_has_op1();
  inline void clear_has_op1();
  inline void set_has_op2();
  inline void clear_has_op2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::compiler::gpu::Exp* op1_;
  ::blox::compiler::gpu::Exp* op2_;
  int comparison_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Comp* default_instance_;
};
// -------------------------------------------------------------------

class Test : public ::google::protobuf::Message {
 public:
  Test();
  virtual ~Test();
  
  Test(const Test& from);
  
  inline Test& operator=(const Test& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Test& default_instance();
  
  void Swap(Test* other);
  
  // implements Message ----------------------------------------------
  
  Test* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Test& from);
  void MergeFrom(const Test& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.Fixed testtype = 1;
  inline bool has_testtype() const;
  inline void clear_testtype();
  static const int kTesttypeFieldNumber = 1;
  inline blox::compiler::gpu::Fixed testtype() const;
  inline void set_testtype(blox::compiler::gpu::Fixed value);
  
  // required string testname = 2;
  inline bool has_testname() const;
  inline void clear_testname();
  static const int kTestnameFieldNumber = 2;
  inline const ::std::string& testname() const;
  inline void set_testname(const ::std::string& value);
  inline void set_testname(const char* value);
  inline void set_testname(const char* value, size_t size);
  inline ::std::string* mutable_testname();
  inline ::std::string* release_testname();
  
  // repeated .blox.compiler.gpu.Exp ops = 3;
  inline int ops_size() const;
  inline void clear_ops();
  static const int kOpsFieldNumber = 3;
  inline const ::blox::compiler::gpu::Exp& ops(int index) const;
  inline ::blox::compiler::gpu::Exp* mutable_ops(int index);
  inline ::blox::compiler::gpu::Exp* add_ops();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >&
      ops() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >*
      mutable_ops();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Test)
 private:
  inline void set_has_testtype();
  inline void clear_has_testtype();
  inline void set_has_testname();
  inline void clear_has_testname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* testname_;
  ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp > ops_;
  int testtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Test* default_instance_;
};
// -------------------------------------------------------------------

class And : public ::google::protobuf::Message {
 public:
  And();
  virtual ~And();
  
  And(const And& from);
  
  inline And& operator=(const And& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const And& default_instance();
  
  void Swap(And* other);
  
  // implements Message ----------------------------------------------
  
  And* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const And& from);
  void MergeFrom(const And& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.Compare and1 = 1;
  inline bool has_and1() const;
  inline void clear_and1();
  static const int kAnd1FieldNumber = 1;
  inline const ::blox::compiler::gpu::Compare& and1() const;
  inline ::blox::compiler::gpu::Compare* mutable_and1();
  inline ::blox::compiler::gpu::Compare* release_and1();
  
  // required .blox.compiler.gpu.Compare and2 = 2;
  inline bool has_and2() const;
  inline void clear_and2();
  static const int kAnd2FieldNumber = 2;
  inline const ::blox::compiler::gpu::Compare& and2() const;
  inline ::blox::compiler::gpu::Compare* mutable_and2();
  inline ::blox::compiler::gpu::Compare* release_and2();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.And)
 private:
  inline void set_has_and1();
  inline void clear_has_and1();
  inline void set_has_and2();
  inline void clear_has_and2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::compiler::gpu::Compare* and1_;
  ::blox::compiler::gpu::Compare* and2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static And* default_instance_;
};
// -------------------------------------------------------------------

class Compare : public ::google::protobuf::Message {
 public:
  Compare();
  virtual ~Compare();
  
  Compare(const Compare& from);
  
  inline Compare& operator=(const Compare& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Compare& default_instance();
  
  void Swap(Compare* other);
  
  // implements Message ----------------------------------------------
  
  Compare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Compare& from);
  void MergeFrom(const Compare& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.CompareTag tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline blox::compiler::gpu::CompareTag tag() const;
  inline void set_tag(blox::compiler::gpu::CompareTag value);
  
  // optional .blox.compiler.gpu.Comp comp = 2;
  inline bool has_comp() const;
  inline void clear_comp();
  static const int kCompFieldNumber = 2;
  inline const ::blox::compiler::gpu::Comp& comp() const;
  inline ::blox::compiler::gpu::Comp* mutable_comp();
  inline ::blox::compiler::gpu::Comp* release_comp();
  
  // optional .blox.compiler.gpu.Test test = 3;
  inline bool has_test() const;
  inline void clear_test();
  static const int kTestFieldNumber = 3;
  inline const ::blox::compiler::gpu::Test& test() const;
  inline ::blox::compiler::gpu::Test* mutable_test();
  inline ::blox::compiler::gpu::Test* release_test();
  
  // optional .blox.compiler.gpu.And andComp = 4;
  inline bool has_andcomp() const;
  inline void clear_andcomp();
  static const int kAndCompFieldNumber = 4;
  inline const ::blox::compiler::gpu::And& andcomp() const;
  inline ::blox::compiler::gpu::And* mutable_andcomp();
  inline ::blox::compiler::gpu::And* release_andcomp();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Compare)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_comp();
  inline void clear_has_comp();
  inline void set_has_test();
  inline void clear_has_test();
  inline void set_has_andcomp();
  inline void clear_has_andcomp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::compiler::gpu::Comp* comp_;
  ::blox::compiler::gpu::Test* test_;
  ::blox::compiler::gpu::And* andcomp_;
  int tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Compare* default_instance_;
};
// -------------------------------------------------------------------

class Count : public ::google::protobuf::Message {
 public:
  Count();
  virtual ~Count();
  
  Count(const Count& from);
  
  inline Count& operator=(const Count& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Count& default_instance();
  
  void Swap(Count* other);
  
  // implements Message ----------------------------------------------
  
  Count* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Count& from);
  void MergeFrom(const Count& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 aggrng = 1;
  inline bool has_aggrng() const;
  inline void clear_aggrng();
  static const int kAggrngFieldNumber = 1;
  inline ::google::protobuf::int32 aggrng() const;
  inline void set_aggrng(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Count)
 private:
  inline void set_has_aggrng();
  inline void clear_has_aggrng();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 aggrng_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Count* default_instance_;
};
// -------------------------------------------------------------------

class Total : public ::google::protobuf::Message {
 public:
  Total();
  virtual ~Total();
  
  Total(const Total& from);
  
  inline Total& operator=(const Total& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Total& default_instance();
  
  void Swap(Total* other);
  
  // implements Message ----------------------------------------------
  
  Total* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Total& from);
  void MergeFrom(const Total& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 aggdom = 1;
  inline bool has_aggdom() const;
  inline void clear_aggdom();
  static const int kAggdomFieldNumber = 1;
  inline ::google::protobuf::int32 aggdom() const;
  inline void set_aggdom(::google::protobuf::int32 value);
  
  // required int32 aggrng = 2;
  inline bool has_aggrng() const;
  inline void clear_aggrng();
  static const int kAggrngFieldNumber = 2;
  inline ::google::protobuf::int32 aggrng() const;
  inline void set_aggrng(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Total)
 private:
  inline void set_has_aggdom();
  inline void clear_has_aggdom();
  inline void set_has_aggrng();
  inline void clear_has_aggrng();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 aggdom_;
  ::google::protobuf::int32 aggrng_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Total* default_instance_;
};
// -------------------------------------------------------------------

class Min : public ::google::protobuf::Message {
 public:
  Min();
  virtual ~Min();
  
  Min(const Min& from);
  
  inline Min& operator=(const Min& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Min& default_instance();
  
  void Swap(Min* other);
  
  // implements Message ----------------------------------------------
  
  Min* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Min& from);
  void MergeFrom(const Min& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 aggdom = 1;
  inline bool has_aggdom() const;
  inline void clear_aggdom();
  static const int kAggdomFieldNumber = 1;
  inline ::google::protobuf::int32 aggdom() const;
  inline void set_aggdom(::google::protobuf::int32 value);
  
  // required int32 aggrng = 2;
  inline bool has_aggrng() const;
  inline void clear_aggrng();
  static const int kAggrngFieldNumber = 2;
  inline ::google::protobuf::int32 aggrng() const;
  inline void set_aggrng(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Min)
 private:
  inline void set_has_aggdom();
  inline void clear_has_aggdom();
  inline void set_has_aggrng();
  inline void clear_has_aggrng();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 aggdom_;
  ::google::protobuf::int32 aggrng_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Min* default_instance_;
};
// -------------------------------------------------------------------

class Max : public ::google::protobuf::Message {
 public:
  Max();
  virtual ~Max();
  
  Max(const Max& from);
  
  inline Max& operator=(const Max& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Max& default_instance();
  
  void Swap(Max* other);
  
  // implements Message ----------------------------------------------
  
  Max* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Max& from);
  void MergeFrom(const Max& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 aggdom = 1;
  inline bool has_aggdom() const;
  inline void clear_aggdom();
  static const int kAggdomFieldNumber = 1;
  inline ::google::protobuf::int32 aggdom() const;
  inline void set_aggdom(::google::protobuf::int32 value);
  
  // required int32 aggrng = 2;
  inline bool has_aggrng() const;
  inline void clear_aggrng();
  static const int kAggrngFieldNumber = 2;
  inline ::google::protobuf::int32 aggrng() const;
  inline void set_aggrng(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Max)
 private:
  inline void set_has_aggdom();
  inline void clear_has_aggdom();
  inline void set_has_aggrng();
  inline void clear_has_aggrng();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 aggdom_;
  ::google::protobuf::int32 aggrng_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Max* default_instance_;
};
// -------------------------------------------------------------------

class Agg : public ::google::protobuf::Message {
 public:
  Agg();
  virtual ~Agg();
  
  Agg(const Agg& from);
  
  inline Agg& operator=(const Agg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Agg& default_instance();
  
  void Swap(Agg* other);
  
  // implements Message ----------------------------------------------
  
  Agg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Agg& from);
  void MergeFrom(const Agg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .blox.compiler.gpu.AggTag tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline blox::compiler::gpu::AggTag tag() const;
  inline void set_tag(blox::compiler::gpu::AggTag value);
  
  // optional .blox.compiler.gpu.Count count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline const ::blox::compiler::gpu::Count& count() const;
  inline ::blox::compiler::gpu::Count* mutable_count();
  inline ::blox::compiler::gpu::Count* release_count();
  
  // optional .blox.compiler.gpu.Total total = 3;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 3;
  inline const ::blox::compiler::gpu::Total& total() const;
  inline ::blox::compiler::gpu::Total* mutable_total();
  inline ::blox::compiler::gpu::Total* release_total();
  
  // optional .blox.compiler.gpu.Min min = 4;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 4;
  inline const ::blox::compiler::gpu::Min& min() const;
  inline ::blox::compiler::gpu::Min* mutable_min();
  inline ::blox::compiler::gpu::Min* release_min();
  
  // optional .blox.compiler.gpu.Max max = 5;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 5;
  inline const ::blox::compiler::gpu::Max& max() const;
  inline ::blox::compiler::gpu::Max* mutable_max();
  inline ::blox::compiler::gpu::Max* release_max();
  
  // @@protoc_insertion_point(class_scope:blox.compiler.gpu.Agg)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::compiler::gpu::Count* count_;
  ::blox::compiler::gpu::Total* total_;
  ::blox::compiler::gpu::Min* min_;
  ::blox::compiler::gpu::Max* max_;
  int tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_RelationalAlgebra_2eproto();
  friend void protobuf_AssignDesc_RelationalAlgebra_2eproto();
  friend void protobuf_ShutdownFile_RelationalAlgebra_2eproto();
  
  void InitAsDefaultInstance();
  static Agg* default_instance_;
};
// ===================================================================


// ===================================================================

// GPUGraph

// required string graphName = 1;
inline bool GPUGraph::has_graphname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUGraph::set_has_graphname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUGraph::clear_has_graphname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUGraph::clear_graphname() {
  if (graphname_ != &::google::protobuf::internal::kEmptyString) {
    graphname_->clear();
  }
  clear_has_graphname();
}
inline const ::std::string& GPUGraph::graphname() const {
  return *graphname_;
}
inline void GPUGraph::set_graphname(const ::std::string& value) {
  set_has_graphname();
  if (graphname_ == &::google::protobuf::internal::kEmptyString) {
    graphname_ = new ::std::string;
  }
  graphname_->assign(value);
}
inline void GPUGraph::set_graphname(const char* value) {
  set_has_graphname();
  if (graphname_ == &::google::protobuf::internal::kEmptyString) {
    graphname_ = new ::std::string;
  }
  graphname_->assign(value);
}
inline void GPUGraph::set_graphname(const char* value, size_t size) {
  set_has_graphname();
  if (graphname_ == &::google::protobuf::internal::kEmptyString) {
    graphname_ = new ::std::string;
  }
  graphname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUGraph::mutable_graphname() {
  set_has_graphname();
  if (graphname_ == &::google::protobuf::internal::kEmptyString) {
    graphname_ = new ::std::string;
  }
  return graphname_;
}
inline ::std::string* GPUGraph::release_graphname() {
  clear_has_graphname();
  if (graphname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = graphname_;
    graphname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .blox.compiler.gpu.GPUVariable variables = 2;
inline int GPUGraph::variables_size() const {
  return variables_.size();
}
inline void GPUGraph::clear_variables() {
  variables_.Clear();
}
inline const ::blox::compiler::gpu::GPUVariable& GPUGraph::variables(int index) const {
  return variables_.Get(index);
}
inline ::blox::compiler::gpu::GPUVariable* GPUGraph::mutable_variables(int index) {
  return variables_.Mutable(index);
}
inline ::blox::compiler::gpu::GPUVariable* GPUGraph::add_variables() {
  return variables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUVariable >&
GPUGraph::variables() const {
  return variables_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUVariable >*
GPUGraph::mutable_variables() {
  return &variables_;
}

// repeated .blox.compiler.gpu.GPUSequence sequences = 3;
inline int GPUGraph::sequences_size() const {
  return sequences_.size();
}
inline void GPUGraph::clear_sequences() {
  sequences_.Clear();
}
inline const ::blox::compiler::gpu::GPUSequence& GPUGraph::sequences(int index) const {
  return sequences_.Get(index);
}
inline ::blox::compiler::gpu::GPUSequence* GPUGraph::mutable_sequences(int index) {
  return sequences_.Mutable(index);
}
inline ::blox::compiler::gpu::GPUSequence* GPUGraph::add_sequences() {
  return sequences_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUSequence >&
GPUGraph::sequences() const {
  return sequences_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUSequence >*
GPUGraph::mutable_sequences() {
  return &sequences_;
}

// required int32 entry = 4;
inline bool GPUGraph::has_entry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPUGraph::set_has_entry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPUGraph::clear_has_entry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPUGraph::clear_entry() {
  entry_ = 0;
  clear_has_entry();
}
inline ::google::protobuf::int32 GPUGraph::entry() const {
  return entry_;
}
inline void GPUGraph::set_entry(::google::protobuf::int32 value) {
  set_has_entry();
  entry_ = value;
}

// required int32 exit = 5;
inline bool GPUGraph::has_exit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GPUGraph::set_has_exit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GPUGraph::clear_has_exit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GPUGraph::clear_exit() {
  exit_ = 0;
  clear_has_exit();
}
inline ::google::protobuf::int32 GPUGraph::exit() const {
  return exit_;
}
inline void GPUGraph::set_exit(::google::protobuf::int32 value) {
  set_has_exit();
  exit_ = value;
}

// -------------------------------------------------------------------

// GPUVariable

// required string varName = 1;
inline bool GPUVariable::has_varname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUVariable::set_has_varname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUVariable::clear_has_varname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUVariable::clear_varname() {
  if (varname_ != &::google::protobuf::internal::kEmptyString) {
    varname_->clear();
  }
  clear_has_varname();
}
inline const ::std::string& GPUVariable::varname() const {
  return *varname_;
}
inline void GPUVariable::set_varname(const ::std::string& value) {
  set_has_varname();
  if (varname_ == &::google::protobuf::internal::kEmptyString) {
    varname_ = new ::std::string;
  }
  varname_->assign(value);
}
inline void GPUVariable::set_varname(const char* value) {
  set_has_varname();
  if (varname_ == &::google::protobuf::internal::kEmptyString) {
    varname_ = new ::std::string;
  }
  varname_->assign(value);
}
inline void GPUVariable::set_varname(const char* value, size_t size) {
  set_has_varname();
  if (varname_ == &::google::protobuf::internal::kEmptyString) {
    varname_ = new ::std::string;
  }
  varname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUVariable::mutable_varname() {
  set_has_varname();
  if (varname_ == &::google::protobuf::internal::kEmptyString) {
    varname_ = new ::std::string;
  }
  return varname_;
}
inline ::std::string* GPUVariable::release_varname() {
  clear_has_varname();
  if (varname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = varname_;
    varname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .blox.common.protocol.Type keys = 2;
inline int GPUVariable::keys_size() const {
  return keys_.size();
}
inline void GPUVariable::clear_keys() {
  keys_.Clear();
}
inline const ::blox::common::protocol::Type& GPUVariable::keys(int index) const {
  return keys_.Get(index);
}
inline ::blox::common::protocol::Type* GPUVariable::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline ::blox::common::protocol::Type* GPUVariable::add_keys() {
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Type >&
GPUVariable::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Type >*
GPUVariable::mutable_keys() {
  return &keys_;
}

// repeated .blox.common.protocol.Type fields = 3;
inline int GPUVariable::fields_size() const {
  return fields_.size();
}
inline void GPUVariable::clear_fields() {
  fields_.Clear();
}
inline const ::blox::common::protocol::Type& GPUVariable::fields(int index) const {
  return fields_.Get(index);
}
inline ::blox::common::protocol::Type* GPUVariable::mutable_fields(int index) {
  return fields_.Mutable(index);
}
inline ::blox::common::protocol::Type* GPUVariable::add_fields() {
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Type >&
GPUVariable::fields() const {
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Type >*
GPUVariable::mutable_fields() {
  return &fields_;
}

// required bytes initialData = 4;
inline bool GPUVariable::has_initialdata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPUVariable::set_has_initialdata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPUVariable::clear_has_initialdata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPUVariable::clear_initialdata() {
  if (initialdata_ != &::google::protobuf::internal::kEmptyString) {
    initialdata_->clear();
  }
  clear_has_initialdata();
}
inline const ::std::string& GPUVariable::initialdata() const {
  return *initialdata_;
}
inline void GPUVariable::set_initialdata(const ::std::string& value) {
  set_has_initialdata();
  if (initialdata_ == &::google::protobuf::internal::kEmptyString) {
    initialdata_ = new ::std::string;
  }
  initialdata_->assign(value);
}
inline void GPUVariable::set_initialdata(const char* value) {
  set_has_initialdata();
  if (initialdata_ == &::google::protobuf::internal::kEmptyString) {
    initialdata_ = new ::std::string;
  }
  initialdata_->assign(value);
}
inline void GPUVariable::set_initialdata(const void* value, size_t size) {
  set_has_initialdata();
  if (initialdata_ == &::google::protobuf::internal::kEmptyString) {
    initialdata_ = new ::std::string;
  }
  initialdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUVariable::mutable_initialdata() {
  set_has_initialdata();
  if (initialdata_ == &::google::protobuf::internal::kEmptyString) {
    initialdata_ = new ::std::string;
  }
  return initialdata_;
}
inline ::std::string* GPUVariable::release_initialdata() {
  clear_has_initialdata();
  if (initialdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = initialdata_;
    initialdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GPUUnion

// required string srcA = 2;
inline bool GPUUnion::has_srca() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUUnion::set_has_srca() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUUnion::clear_has_srca() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUUnion::clear_srca() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    srca_->clear();
  }
  clear_has_srca();
}
inline const ::std::string& GPUUnion::srca() const {
  return *srca_;
}
inline void GPUUnion::set_srca(const ::std::string& value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUUnion::set_srca(const char* value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUUnion::set_srca(const char* value, size_t size) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUUnion::mutable_srca() {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  return srca_;
}
inline ::std::string* GPUUnion::release_srca() {
  clear_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srca_;
    srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string srcB = 3;
inline bool GPUUnion::has_srcb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUUnion::set_has_srcb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUUnion::clear_has_srcb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUUnion::clear_srcb() {
  if (srcb_ != &::google::protobuf::internal::kEmptyString) {
    srcb_->clear();
  }
  clear_has_srcb();
}
inline const ::std::string& GPUUnion::srcb() const {
  return *srcb_;
}
inline void GPUUnion::set_srcb(const ::std::string& value) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(value);
}
inline void GPUUnion::set_srcb(const char* value) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(value);
}
inline void GPUUnion::set_srcb(const char* value, size_t size) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUUnion::mutable_srcb() {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  return srcb_;
}
inline ::std::string* GPUUnion::release_srcb() {
  clear_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcb_;
    srcb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GPUIntersection

// required string srcA = 2;
inline bool GPUIntersection::has_srca() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUIntersection::set_has_srca() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUIntersection::clear_has_srca() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUIntersection::clear_srca() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    srca_->clear();
  }
  clear_has_srca();
}
inline const ::std::string& GPUIntersection::srca() const {
  return *srca_;
}
inline void GPUIntersection::set_srca(const ::std::string& value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUIntersection::set_srca(const char* value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUIntersection::set_srca(const char* value, size_t size) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUIntersection::mutable_srca() {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  return srca_;
}
inline ::std::string* GPUIntersection::release_srca() {
  clear_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srca_;
    srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string srcB = 3;
inline bool GPUIntersection::has_srcb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUIntersection::set_has_srcb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUIntersection::clear_has_srcb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUIntersection::clear_srcb() {
  if (srcb_ != &::google::protobuf::internal::kEmptyString) {
    srcb_->clear();
  }
  clear_has_srcb();
}
inline const ::std::string& GPUIntersection::srcb() const {
  return *srcb_;
}
inline void GPUIntersection::set_srcb(const ::std::string& value) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(value);
}
inline void GPUIntersection::set_srcb(const char* value) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(value);
}
inline void GPUIntersection::set_srcb(const char* value, size_t size) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUIntersection::mutable_srcb() {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  return srcb_;
}
inline ::std::string* GPUIntersection::release_srcb() {
  clear_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcb_;
    srcb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GPUProduct

// required string srcA = 2;
inline bool GPUProduct::has_srca() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUProduct::set_has_srca() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUProduct::clear_has_srca() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUProduct::clear_srca() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    srca_->clear();
  }
  clear_has_srca();
}
inline const ::std::string& GPUProduct::srca() const {
  return *srca_;
}
inline void GPUProduct::set_srca(const ::std::string& value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUProduct::set_srca(const char* value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUProduct::set_srca(const char* value, size_t size) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUProduct::mutable_srca() {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  return srca_;
}
inline ::std::string* GPUProduct::release_srca() {
  clear_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srca_;
    srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string srcB = 3;
inline bool GPUProduct::has_srcb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUProduct::set_has_srcb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUProduct::clear_has_srcb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUProduct::clear_srcb() {
  if (srcb_ != &::google::protobuf::internal::kEmptyString) {
    srcb_->clear();
  }
  clear_has_srcb();
}
inline const ::std::string& GPUProduct::srcb() const {
  return *srcb_;
}
inline void GPUProduct::set_srcb(const ::std::string& value) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(value);
}
inline void GPUProduct::set_srcb(const char* value) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(value);
}
inline void GPUProduct::set_srcb(const char* value, size_t size) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUProduct::mutable_srcb() {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  return srcb_;
}
inline ::std::string* GPUProduct::release_srcb() {
  clear_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcb_;
    srcb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GPUSingle

// repeated .blox.common.protocol.Constant element = 1;
inline int GPUSingle::element_size() const {
  return element_.size();
}
inline void GPUSingle::clear_element() {
  element_.Clear();
}
inline const ::blox::common::protocol::Constant& GPUSingle::element(int index) const {
  return element_.Get(index);
}
inline ::blox::common::protocol::Constant* GPUSingle::mutable_element(int index) {
  return element_.Mutable(index);
}
inline ::blox::common::protocol::Constant* GPUSingle::add_element() {
  return element_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Constant >&
GPUSingle::element() const {
  return element_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Constant >*
GPUSingle::mutable_element() {
  return &element_;
}

// -------------------------------------------------------------------

// GPUDifference

// required string srcA = 3;
inline bool GPUDifference::has_srca() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUDifference::set_has_srca() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUDifference::clear_has_srca() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUDifference::clear_srca() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    srca_->clear();
  }
  clear_has_srca();
}
inline const ::std::string& GPUDifference::srca() const {
  return *srca_;
}
inline void GPUDifference::set_srca(const ::std::string& value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUDifference::set_srca(const char* value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUDifference::set_srca(const char* value, size_t size) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUDifference::mutable_srca() {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  return srca_;
}
inline ::std::string* GPUDifference::release_srca() {
  clear_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srca_;
    srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string srcB = 4;
inline bool GPUDifference::has_srcb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUDifference::set_has_srcb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUDifference::clear_has_srcb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUDifference::clear_srcb() {
  if (srcb_ != &::google::protobuf::internal::kEmptyString) {
    srcb_->clear();
  }
  clear_has_srcb();
}
inline const ::std::string& GPUDifference::srcb() const {
  return *srcb_;
}
inline void GPUDifference::set_srcb(const ::std::string& value) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(value);
}
inline void GPUDifference::set_srcb(const char* value) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(value);
}
inline void GPUDifference::set_srcb(const char* value, size_t size) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUDifference::mutable_srcb() {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  return srcb_;
}
inline ::std::string* GPUDifference::release_srcb() {
  clear_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcb_;
    srcb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GPUJoin

// required int32 keyCount = 2;
inline bool GPUJoin::has_keycount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUJoin::set_has_keycount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUJoin::clear_has_keycount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUJoin::clear_keycount() {
  keycount_ = 0;
  clear_has_keycount();
}
inline ::google::protobuf::int32 GPUJoin::keycount() const {
  return keycount_;
}
inline void GPUJoin::set_keycount(::google::protobuf::int32 value) {
  set_has_keycount();
  keycount_ = value;
}

// required string srcA = 3;
inline bool GPUJoin::has_srca() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUJoin::set_has_srca() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUJoin::clear_has_srca() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUJoin::clear_srca() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    srca_->clear();
  }
  clear_has_srca();
}
inline const ::std::string& GPUJoin::srca() const {
  return *srca_;
}
inline void GPUJoin::set_srca(const ::std::string& value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUJoin::set_srca(const char* value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUJoin::set_srca(const char* value, size_t size) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUJoin::mutable_srca() {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  return srca_;
}
inline ::std::string* GPUJoin::release_srca() {
  clear_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srca_;
    srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string srcB = 4;
inline bool GPUJoin::has_srcb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPUJoin::set_has_srcb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPUJoin::clear_has_srcb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPUJoin::clear_srcb() {
  if (srcb_ != &::google::protobuf::internal::kEmptyString) {
    srcb_->clear();
  }
  clear_has_srcb();
}
inline const ::std::string& GPUJoin::srcb() const {
  return *srcb_;
}
inline void GPUJoin::set_srcb(const ::std::string& value) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(value);
}
inline void GPUJoin::set_srcb(const char* value) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(value);
}
inline void GPUJoin::set_srcb(const char* value, size_t size) {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  srcb_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUJoin::mutable_srcb() {
  set_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    srcb_ = new ::std::string;
  }
  return srcb_;
}
inline ::std::string* GPUJoin::release_srcb() {
  clear_has_srcb();
  if (srcb_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcb_;
    srcb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .blox.compiler.gpu.Exp args = 5;
inline int GPUJoin::args_size() const {
  return args_.size();
}
inline void GPUJoin::clear_args() {
  args_.Clear();
}
inline const ::blox::compiler::gpu::Exp& GPUJoin::args(int index) const {
  return args_.Get(index);
}
inline ::blox::compiler::gpu::Exp* GPUJoin::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::blox::compiler::gpu::Exp* GPUJoin::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >&
GPUJoin::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >*
GPUJoin::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// GPUMapFilter

// required int32 srcWidth = 2;
inline bool GPUMapFilter::has_srcwidth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUMapFilter::set_has_srcwidth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUMapFilter::clear_has_srcwidth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUMapFilter::clear_srcwidth() {
  srcwidth_ = 0;
  clear_has_srcwidth();
}
inline ::google::protobuf::int32 GPUMapFilter::srcwidth() const {
  return srcwidth_;
}
inline void GPUMapFilter::set_srcwidth(::google::protobuf::int32 value) {
  set_has_srcwidth();
  srcwidth_ = value;
}

// required .blox.compiler.gpu.Compare predicate = 3;
inline bool GPUMapFilter::has_predicate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUMapFilter::set_has_predicate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUMapFilter::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUMapFilter::clear_predicate() {
  if (predicate_ != NULL) predicate_->::blox::compiler::gpu::Compare::Clear();
  clear_has_predicate();
}
inline const ::blox::compiler::gpu::Compare& GPUMapFilter::predicate() const {
  return predicate_ != NULL ? *predicate_ : *default_instance_->predicate_;
}
inline ::blox::compiler::gpu::Compare* GPUMapFilter::mutable_predicate() {
  set_has_predicate();
  if (predicate_ == NULL) predicate_ = new ::blox::compiler::gpu::Compare;
  return predicate_;
}
inline ::blox::compiler::gpu::Compare* GPUMapFilter::release_predicate() {
  clear_has_predicate();
  ::blox::compiler::gpu::Compare* temp = predicate_;
  predicate_ = NULL;
  return temp;
}

// repeated .blox.compiler.gpu.Exp reordering = 4;
inline int GPUMapFilter::reordering_size() const {
  return reordering_.size();
}
inline void GPUMapFilter::clear_reordering() {
  reordering_.Clear();
}
inline const ::blox::compiler::gpu::Exp& GPUMapFilter::reordering(int index) const {
  return reordering_.Get(index);
}
inline ::blox::compiler::gpu::Exp* GPUMapFilter::mutable_reordering(int index) {
  return reordering_.Mutable(index);
}
inline ::blox::compiler::gpu::Exp* GPUMapFilter::add_reordering() {
  return reordering_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >&
GPUMapFilter::reordering() const {
  return reordering_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >*
GPUMapFilter::mutable_reordering() {
  return &reordering_;
}

// required string srcA = 5;
inline bool GPUMapFilter::has_srca() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPUMapFilter::set_has_srca() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPUMapFilter::clear_has_srca() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPUMapFilter::clear_srca() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    srca_->clear();
  }
  clear_has_srca();
}
inline const ::std::string& GPUMapFilter::srca() const {
  return *srca_;
}
inline void GPUMapFilter::set_srca(const ::std::string& value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUMapFilter::set_srca(const char* value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUMapFilter::set_srca(const char* value, size_t size) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUMapFilter::mutable_srca() {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  return srca_;
}
inline ::std::string* GPUMapFilter::release_srca() {
  clear_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srca_;
    srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GPUAgg

// required int32 srcWidth = 2;
inline bool GPUAgg::has_srcwidth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUAgg::set_has_srcwidth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUAgg::clear_has_srcwidth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUAgg::clear_srcwidth() {
  srcwidth_ = 0;
  clear_has_srcwidth();
}
inline ::google::protobuf::int32 GPUAgg::srcwidth() const {
  return srcwidth_;
}
inline void GPUAgg::set_srcwidth(::google::protobuf::int32 value) {
  set_has_srcwidth();
  srcwidth_ = value;
}

// repeated int32 domains = 3;
inline int GPUAgg::domains_size() const {
  return domains_.size();
}
inline void GPUAgg::clear_domains() {
  domains_.Clear();
}
inline ::google::protobuf::int32 GPUAgg::domains(int index) const {
  return domains_.Get(index);
}
inline void GPUAgg::set_domains(int index, ::google::protobuf::int32 value) {
  domains_.Set(index, value);
}
inline void GPUAgg::add_domains(::google::protobuf::int32 value) {
  domains_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GPUAgg::domains() const {
  return domains_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GPUAgg::mutable_domains() {
  return &domains_;
}

// repeated .blox.compiler.gpu.Agg range = 4;
inline int GPUAgg::range_size() const {
  return range_.size();
}
inline void GPUAgg::clear_range() {
  range_.Clear();
}
inline const ::blox::compiler::gpu::Agg& GPUAgg::range(int index) const {
  return range_.Get(index);
}
inline ::blox::compiler::gpu::Agg* GPUAgg::mutable_range(int index) {
  return range_.Mutable(index);
}
inline ::blox::compiler::gpu::Agg* GPUAgg::add_range() {
  return range_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Agg >&
GPUAgg::range() const {
  return range_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Agg >*
GPUAgg::mutable_range() {
  return &range_;
}

// required string srcA = 5;
inline bool GPUAgg::has_srca() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPUAgg::set_has_srca() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPUAgg::clear_has_srca() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPUAgg::clear_srca() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    srca_->clear();
  }
  clear_has_srca();
}
inline const ::std::string& GPUAgg::srca() const {
  return *srca_;
}
inline void GPUAgg::set_srca(const ::std::string& value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUAgg::set_srca(const char* value) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(value);
}
inline void GPUAgg::set_srca(const char* value, size_t size) {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  srca_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUAgg::mutable_srca() {
  set_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    srca_ = new ::std::string;
  }
  return srca_;
}
inline ::std::string* GPUAgg::release_srca() {
  clear_has_srca();
  if (srca_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srca_;
    srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GPUOperator

// required .blox.compiler.gpu.OperatorTag tag = 1;
inline bool GPUOperator::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUOperator::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUOperator::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUOperator::clear_tag() {
  tag_ = 2;
  clear_has_tag();
}
inline blox::compiler::gpu::OperatorTag GPUOperator::tag() const {
  return static_cast< blox::compiler::gpu::OperatorTag >(tag_);
}
inline void GPUOperator::set_tag(blox::compiler::gpu::OperatorTag value) {
  GOOGLE_DCHECK(blox::compiler::gpu::OperatorTag_IsValid(value));
  set_has_tag();
  tag_ = value;
}

// optional .blox.compiler.gpu.GPUUnion unionop = 2;
inline bool GPUOperator::has_unionop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUOperator::set_has_unionop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUOperator::clear_has_unionop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUOperator::clear_unionop() {
  if (unionop_ != NULL) unionop_->::blox::compiler::gpu::GPUUnion::Clear();
  clear_has_unionop();
}
inline const ::blox::compiler::gpu::GPUUnion& GPUOperator::unionop() const {
  return unionop_ != NULL ? *unionop_ : *default_instance_->unionop_;
}
inline ::blox::compiler::gpu::GPUUnion* GPUOperator::mutable_unionop() {
  set_has_unionop();
  if (unionop_ == NULL) unionop_ = new ::blox::compiler::gpu::GPUUnion;
  return unionop_;
}
inline ::blox::compiler::gpu::GPUUnion* GPUOperator::release_unionop() {
  clear_has_unionop();
  ::blox::compiler::gpu::GPUUnion* temp = unionop_;
  unionop_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.GPUIntersection intersection = 3;
inline bool GPUOperator::has_intersection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPUOperator::set_has_intersection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPUOperator::clear_has_intersection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPUOperator::clear_intersection() {
  if (intersection_ != NULL) intersection_->::blox::compiler::gpu::GPUIntersection::Clear();
  clear_has_intersection();
}
inline const ::blox::compiler::gpu::GPUIntersection& GPUOperator::intersection() const {
  return intersection_ != NULL ? *intersection_ : *default_instance_->intersection_;
}
inline ::blox::compiler::gpu::GPUIntersection* GPUOperator::mutable_intersection() {
  set_has_intersection();
  if (intersection_ == NULL) intersection_ = new ::blox::compiler::gpu::GPUIntersection;
  return intersection_;
}
inline ::blox::compiler::gpu::GPUIntersection* GPUOperator::release_intersection() {
  clear_has_intersection();
  ::blox::compiler::gpu::GPUIntersection* temp = intersection_;
  intersection_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.GPUProduct product = 4;
inline bool GPUOperator::has_product() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPUOperator::set_has_product() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPUOperator::clear_has_product() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPUOperator::clear_product() {
  if (product_ != NULL) product_->::blox::compiler::gpu::GPUProduct::Clear();
  clear_has_product();
}
inline const ::blox::compiler::gpu::GPUProduct& GPUOperator::product() const {
  return product_ != NULL ? *product_ : *default_instance_->product_;
}
inline ::blox::compiler::gpu::GPUProduct* GPUOperator::mutable_product() {
  set_has_product();
  if (product_ == NULL) product_ = new ::blox::compiler::gpu::GPUProduct;
  return product_;
}
inline ::blox::compiler::gpu::GPUProduct* GPUOperator::release_product() {
  clear_has_product();
  ::blox::compiler::gpu::GPUProduct* temp = product_;
  product_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.GPUSingle single = 5;
inline bool GPUOperator::has_single() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GPUOperator::set_has_single() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GPUOperator::clear_has_single() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GPUOperator::clear_single() {
  if (single_ != NULL) single_->::blox::compiler::gpu::GPUSingle::Clear();
  clear_has_single();
}
inline const ::blox::compiler::gpu::GPUSingle& GPUOperator::single() const {
  return single_ != NULL ? *single_ : *default_instance_->single_;
}
inline ::blox::compiler::gpu::GPUSingle* GPUOperator::mutable_single() {
  set_has_single();
  if (single_ == NULL) single_ = new ::blox::compiler::gpu::GPUSingle;
  return single_;
}
inline ::blox::compiler::gpu::GPUSingle* GPUOperator::release_single() {
  clear_has_single();
  ::blox::compiler::gpu::GPUSingle* temp = single_;
  single_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.GPUDifference difference = 6;
inline bool GPUOperator::has_difference() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GPUOperator::set_has_difference() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GPUOperator::clear_has_difference() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GPUOperator::clear_difference() {
  if (difference_ != NULL) difference_->::blox::compiler::gpu::GPUDifference::Clear();
  clear_has_difference();
}
inline const ::blox::compiler::gpu::GPUDifference& GPUOperator::difference() const {
  return difference_ != NULL ? *difference_ : *default_instance_->difference_;
}
inline ::blox::compiler::gpu::GPUDifference* GPUOperator::mutable_difference() {
  set_has_difference();
  if (difference_ == NULL) difference_ = new ::blox::compiler::gpu::GPUDifference;
  return difference_;
}
inline ::blox::compiler::gpu::GPUDifference* GPUOperator::release_difference() {
  clear_has_difference();
  ::blox::compiler::gpu::GPUDifference* temp = difference_;
  difference_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.GPUJoin join = 7;
inline bool GPUOperator::has_join() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GPUOperator::set_has_join() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GPUOperator::clear_has_join() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GPUOperator::clear_join() {
  if (join_ != NULL) join_->::blox::compiler::gpu::GPUJoin::Clear();
  clear_has_join();
}
inline const ::blox::compiler::gpu::GPUJoin& GPUOperator::join() const {
  return join_ != NULL ? *join_ : *default_instance_->join_;
}
inline ::blox::compiler::gpu::GPUJoin* GPUOperator::mutable_join() {
  set_has_join();
  if (join_ == NULL) join_ = new ::blox::compiler::gpu::GPUJoin;
  return join_;
}
inline ::blox::compiler::gpu::GPUJoin* GPUOperator::release_join() {
  clear_has_join();
  ::blox::compiler::gpu::GPUJoin* temp = join_;
  join_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.GPUMapFilter mapfilter = 10;
inline bool GPUOperator::has_mapfilter() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GPUOperator::set_has_mapfilter() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GPUOperator::clear_has_mapfilter() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GPUOperator::clear_mapfilter() {
  if (mapfilter_ != NULL) mapfilter_->::blox::compiler::gpu::GPUMapFilter::Clear();
  clear_has_mapfilter();
}
inline const ::blox::compiler::gpu::GPUMapFilter& GPUOperator::mapfilter() const {
  return mapfilter_ != NULL ? *mapfilter_ : *default_instance_->mapfilter_;
}
inline ::blox::compiler::gpu::GPUMapFilter* GPUOperator::mutable_mapfilter() {
  set_has_mapfilter();
  if (mapfilter_ == NULL) mapfilter_ = new ::blox::compiler::gpu::GPUMapFilter;
  return mapfilter_;
}
inline ::blox::compiler::gpu::GPUMapFilter* GPUOperator::release_mapfilter() {
  clear_has_mapfilter();
  ::blox::compiler::gpu::GPUMapFilter* temp = mapfilter_;
  mapfilter_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.GPUAgg agg = 11;
inline bool GPUOperator::has_agg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GPUOperator::set_has_agg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GPUOperator::clear_has_agg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GPUOperator::clear_agg() {
  if (agg_ != NULL) agg_->::blox::compiler::gpu::GPUAgg::Clear();
  clear_has_agg();
}
inline const ::blox::compiler::gpu::GPUAgg& GPUOperator::agg() const {
  return agg_ != NULL ? *agg_ : *default_instance_->agg_;
}
inline ::blox::compiler::gpu::GPUAgg* GPUOperator::mutable_agg() {
  set_has_agg();
  if (agg_ == NULL) agg_ = new ::blox::compiler::gpu::GPUAgg;
  return agg_;
}
inline ::blox::compiler::gpu::GPUAgg* GPUOperator::release_agg() {
  clear_has_agg();
  ::blox::compiler::gpu::GPUAgg* temp = agg_;
  agg_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GPUAssign

// required string dest = 1;
inline bool GPUAssign::has_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUAssign::set_has_dest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUAssign::clear_has_dest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUAssign::clear_dest() {
  if (dest_ != &::google::protobuf::internal::kEmptyString) {
    dest_->clear();
  }
  clear_has_dest();
}
inline const ::std::string& GPUAssign::dest() const {
  return *dest_;
}
inline void GPUAssign::set_dest(const ::std::string& value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
}
inline void GPUAssign::set_dest(const char* value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
}
inline void GPUAssign::set_dest(const char* value, size_t size) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUAssign::mutable_dest() {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  return dest_;
}
inline ::std::string* GPUAssign::release_dest() {
  clear_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dest_;
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .blox.compiler.gpu.GPUOperator op = 2;
inline bool GPUAssign::has_op() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUAssign::set_has_op() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUAssign::clear_has_op() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUAssign::clear_op() {
  if (op_ != NULL) op_->::blox::compiler::gpu::GPUOperator::Clear();
  clear_has_op();
}
inline const ::blox::compiler::gpu::GPUOperator& GPUAssign::op() const {
  return op_ != NULL ? *op_ : *default_instance_->op_;
}
inline ::blox::compiler::gpu::GPUOperator* GPUAssign::mutable_op() {
  set_has_op();
  if (op_ == NULL) op_ = new ::blox::compiler::gpu::GPUOperator;
  return op_;
}
inline ::blox::compiler::gpu::GPUOperator* GPUAssign::release_op() {
  clear_has_op();
  ::blox::compiler::gpu::GPUOperator* temp = op_;
  op_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GPUCond

// required string src1 = 1;
inline bool GPUCond::has_src1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUCond::set_has_src1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUCond::clear_has_src1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUCond::clear_src1() {
  if (src1_ != &::google::protobuf::internal::kEmptyString) {
    src1_->clear();
  }
  clear_has_src1();
}
inline const ::std::string& GPUCond::src1() const {
  return *src1_;
}
inline void GPUCond::set_src1(const ::std::string& value) {
  set_has_src1();
  if (src1_ == &::google::protobuf::internal::kEmptyString) {
    src1_ = new ::std::string;
  }
  src1_->assign(value);
}
inline void GPUCond::set_src1(const char* value) {
  set_has_src1();
  if (src1_ == &::google::protobuf::internal::kEmptyString) {
    src1_ = new ::std::string;
  }
  src1_->assign(value);
}
inline void GPUCond::set_src1(const char* value, size_t size) {
  set_has_src1();
  if (src1_ == &::google::protobuf::internal::kEmptyString) {
    src1_ = new ::std::string;
  }
  src1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUCond::mutable_src1() {
  set_has_src1();
  if (src1_ == &::google::protobuf::internal::kEmptyString) {
    src1_ = new ::std::string;
  }
  return src1_;
}
inline ::std::string* GPUCond::release_src1() {
  clear_has_src1();
  if (src1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src1_;
    src1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string src2 = 2;
inline bool GPUCond::has_src2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUCond::set_has_src2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUCond::clear_has_src2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUCond::clear_src2() {
  if (src2_ != &::google::protobuf::internal::kEmptyString) {
    src2_->clear();
  }
  clear_has_src2();
}
inline const ::std::string& GPUCond::src2() const {
  return *src2_;
}
inline void GPUCond::set_src2(const ::std::string& value) {
  set_has_src2();
  if (src2_ == &::google::protobuf::internal::kEmptyString) {
    src2_ = new ::std::string;
  }
  src2_->assign(value);
}
inline void GPUCond::set_src2(const char* value) {
  set_has_src2();
  if (src2_ == &::google::protobuf::internal::kEmptyString) {
    src2_ = new ::std::string;
  }
  src2_->assign(value);
}
inline void GPUCond::set_src2(const char* value, size_t size) {
  set_has_src2();
  if (src2_ == &::google::protobuf::internal::kEmptyString) {
    src2_ = new ::std::string;
  }
  src2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUCond::mutable_src2() {
  set_has_src2();
  if (src2_ == &::google::protobuf::internal::kEmptyString) {
    src2_ = new ::std::string;
  }
  return src2_;
}
inline ::std::string* GPUCond::release_src2() {
  clear_has_src2();
  if (src2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src2_;
    src2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 yes = 3;
inline bool GPUCond::has_yes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPUCond::set_has_yes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPUCond::clear_has_yes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPUCond::clear_yes() {
  yes_ = 0;
  clear_has_yes();
}
inline ::google::protobuf::int32 GPUCond::yes() const {
  return yes_;
}
inline void GPUCond::set_yes(::google::protobuf::int32 value) {
  set_has_yes();
  yes_ = value;
}

// required int32 no = 4;
inline bool GPUCond::has_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPUCond::set_has_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPUCond::clear_has_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPUCond::clear_no() {
  no_ = 0;
  clear_has_no();
}
inline ::google::protobuf::int32 GPUCond::no() const {
  return no_;
}
inline void GPUCond::set_no(::google::protobuf::int32 value) {
  set_has_no();
  no_ = value;
}

// -------------------------------------------------------------------

// GPUGoto

// required int32 target = 1;
inline bool GPUGoto::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUGoto::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUGoto::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUGoto::clear_target() {
  target_ = 0;
  clear_has_target();
}
inline ::google::protobuf::int32 GPUGoto::target() const {
  return target_;
}
inline void GPUGoto::set_target(::google::protobuf::int32 value) {
  set_has_target();
  target_ = value;
}

// -------------------------------------------------------------------

// GPUMove

// required string dest = 1;
inline bool GPUMove::has_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUMove::set_has_dest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUMove::clear_has_dest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUMove::clear_dest() {
  if (dest_ != &::google::protobuf::internal::kEmptyString) {
    dest_->clear();
  }
  clear_has_dest();
}
inline const ::std::string& GPUMove::dest() const {
  return *dest_;
}
inline void GPUMove::set_dest(const ::std::string& value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
}
inline void GPUMove::set_dest(const char* value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
}
inline void GPUMove::set_dest(const char* value, size_t size) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUMove::mutable_dest() {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  return dest_;
}
inline ::std::string* GPUMove::release_dest() {
  clear_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dest_;
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string src1 = 2;
inline bool GPUMove::has_src1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUMove::set_has_src1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUMove::clear_has_src1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUMove::clear_src1() {
  if (src1_ != &::google::protobuf::internal::kEmptyString) {
    src1_->clear();
  }
  clear_has_src1();
}
inline const ::std::string& GPUMove::src1() const {
  return *src1_;
}
inline void GPUMove::set_src1(const ::std::string& value) {
  set_has_src1();
  if (src1_ == &::google::protobuf::internal::kEmptyString) {
    src1_ = new ::std::string;
  }
  src1_->assign(value);
}
inline void GPUMove::set_src1(const char* value) {
  set_has_src1();
  if (src1_ == &::google::protobuf::internal::kEmptyString) {
    src1_ = new ::std::string;
  }
  src1_->assign(value);
}
inline void GPUMove::set_src1(const char* value, size_t size) {
  set_has_src1();
  if (src1_ == &::google::protobuf::internal::kEmptyString) {
    src1_ = new ::std::string;
  }
  src1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUMove::mutable_src1() {
  set_has_src1();
  if (src1_ == &::google::protobuf::internal::kEmptyString) {
    src1_ = new ::std::string;
  }
  return src1_;
}
inline ::std::string* GPUMove::release_src1() {
  clear_has_src1();
  if (src1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src1_;
    src1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GPUCommand

// required .blox.compiler.gpu.CommandTag tag = 1;
inline bool GPUCommand::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUCommand::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUCommand::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUCommand::clear_tag() {
  tag_ = 2;
  clear_has_tag();
}
inline blox::compiler::gpu::CommandTag GPUCommand::tag() const {
  return static_cast< blox::compiler::gpu::CommandTag >(tag_);
}
inline void GPUCommand::set_tag(blox::compiler::gpu::CommandTag value) {
  GOOGLE_DCHECK(blox::compiler::gpu::CommandTag_IsValid(value));
  set_has_tag();
  tag_ = value;
}

// optional .blox.compiler.gpu.GPUAssign assign = 2;
inline bool GPUCommand::has_assign() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUCommand::set_has_assign() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUCommand::clear_has_assign() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUCommand::clear_assign() {
  if (assign_ != NULL) assign_->::blox::compiler::gpu::GPUAssign::Clear();
  clear_has_assign();
}
inline const ::blox::compiler::gpu::GPUAssign& GPUCommand::assign() const {
  return assign_ != NULL ? *assign_ : *default_instance_->assign_;
}
inline ::blox::compiler::gpu::GPUAssign* GPUCommand::mutable_assign() {
  set_has_assign();
  if (assign_ == NULL) assign_ = new ::blox::compiler::gpu::GPUAssign;
  return assign_;
}
inline ::blox::compiler::gpu::GPUAssign* GPUCommand::release_assign() {
  clear_has_assign();
  ::blox::compiler::gpu::GPUAssign* temp = assign_;
  assign_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.GPUCond cond = 3;
inline bool GPUCommand::has_cond() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPUCommand::set_has_cond() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPUCommand::clear_has_cond() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPUCommand::clear_cond() {
  if (cond_ != NULL) cond_->::blox::compiler::gpu::GPUCond::Clear();
  clear_has_cond();
}
inline const ::blox::compiler::gpu::GPUCond& GPUCommand::cond() const {
  return cond_ != NULL ? *cond_ : *default_instance_->cond_;
}
inline ::blox::compiler::gpu::GPUCond* GPUCommand::mutable_cond() {
  set_has_cond();
  if (cond_ == NULL) cond_ = new ::blox::compiler::gpu::GPUCond;
  return cond_;
}
inline ::blox::compiler::gpu::GPUCond* GPUCommand::release_cond() {
  clear_has_cond();
  ::blox::compiler::gpu::GPUCond* temp = cond_;
  cond_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.GPUGoto jump = 4;
inline bool GPUCommand::has_jump() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPUCommand::set_has_jump() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPUCommand::clear_has_jump() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPUCommand::clear_jump() {
  if (jump_ != NULL) jump_->::blox::compiler::gpu::GPUGoto::Clear();
  clear_has_jump();
}
inline const ::blox::compiler::gpu::GPUGoto& GPUCommand::jump() const {
  return jump_ != NULL ? *jump_ : *default_instance_->jump_;
}
inline ::blox::compiler::gpu::GPUGoto* GPUCommand::mutable_jump() {
  set_has_jump();
  if (jump_ == NULL) jump_ = new ::blox::compiler::gpu::GPUGoto;
  return jump_;
}
inline ::blox::compiler::gpu::GPUGoto* GPUCommand::release_jump() {
  clear_has_jump();
  ::blox::compiler::gpu::GPUGoto* temp = jump_;
  jump_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.GPUMove move = 5;
inline bool GPUCommand::has_move() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GPUCommand::set_has_move() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GPUCommand::clear_has_move() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GPUCommand::clear_move() {
  if (move_ != NULL) move_->::blox::compiler::gpu::GPUMove::Clear();
  clear_has_move();
}
inline const ::blox::compiler::gpu::GPUMove& GPUCommand::move() const {
  return move_ != NULL ? *move_ : *default_instance_->move_;
}
inline ::blox::compiler::gpu::GPUMove* GPUCommand::mutable_move() {
  set_has_move();
  if (move_ == NULL) move_ = new ::blox::compiler::gpu::GPUMove;
  return move_;
}
inline ::blox::compiler::gpu::GPUMove* GPUCommand::release_move() {
  clear_has_move();
  ::blox::compiler::gpu::GPUMove* temp = move_;
  move_ = NULL;
  return temp;
}

// optional int32 halt = 6;
inline bool GPUCommand::has_halt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GPUCommand::set_has_halt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GPUCommand::clear_has_halt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GPUCommand::clear_halt() {
  halt_ = 0;
  clear_has_halt();
}
inline ::google::protobuf::int32 GPUCommand::halt() const {
  return halt_;
}
inline void GPUCommand::set_halt(::google::protobuf::int32 value) {
  set_has_halt();
  halt_ = value;
}

// -------------------------------------------------------------------

// Address

// required .blox.compiler.gpu.AddressTag tag = 1;
inline bool Address::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_tag() {
  tag_ = 2;
  clear_has_tag();
}
inline blox::compiler::gpu::AddressTag Address::tag() const {
  return static_cast< blox::compiler::gpu::AddressTag >(tag_);
}
inline void Address::set_tag(blox::compiler::gpu::AddressTag value) {
  GOOGLE_DCHECK(blox::compiler::gpu::AddressTag_IsValid(value));
  set_has_tag();
  tag_ = value;
}

// optional int32 varaddr = 2;
inline bool Address::has_varaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address::set_has_varaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address::clear_has_varaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address::clear_varaddr() {
  varaddr_ = 0;
  clear_has_varaddr();
}
inline ::google::protobuf::int32 Address::varaddr() const {
  return varaddr_;
}
inline void Address::set_varaddr(::google::protobuf::int32 value) {
  set_has_varaddr();
  varaddr_ = value;
}

// optional .blox.common.protocol.Constant constaddr = 3;
inline bool Address::has_constaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Address::set_has_constaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Address::clear_has_constaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Address::clear_constaddr() {
  if (constaddr_ != NULL) constaddr_->::blox::common::protocol::Constant::Clear();
  clear_has_constaddr();
}
inline const ::blox::common::protocol::Constant& Address::constaddr() const {
  return constaddr_ != NULL ? *constaddr_ : *default_instance_->constaddr_;
}
inline ::blox::common::protocol::Constant* Address::mutable_constaddr() {
  set_has_constaddr();
  if (constaddr_ == NULL) constaddr_ = new ::blox::common::protocol::Constant;
  return constaddr_;
}
inline ::blox::common::protocol::Constant* Address::release_constaddr() {
  clear_has_constaddr();
  ::blox::common::protocol::Constant* temp = constaddr_;
  constaddr_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GPUCompare

// required .blox.compiler.gpu.Comparison comparison = 1;
inline bool GPUCompare::has_comparison() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUCompare::set_has_comparison() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUCompare::clear_has_comparison() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUCompare::clear_comparison() {
  comparison_ = 0;
  clear_has_comparison();
}
inline blox::compiler::gpu::Comparison GPUCompare::comparison() const {
  return static_cast< blox::compiler::gpu::Comparison >(comparison_);
}
inline void GPUCompare::set_comparison(blox::compiler::gpu::Comparison value) {
  GOOGLE_DCHECK(blox::compiler::gpu::Comparison_IsValid(value));
  set_has_comparison();
  comparison_ = value;
}

// required .blox.common.protocol.PrimitiveType optype = 2;
inline bool GPUCompare::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUCompare::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUCompare::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUCompare::clear_optype() {
  if (optype_ != NULL) optype_->::blox::common::protocol::PrimitiveType::Clear();
  clear_has_optype();
}
inline const ::blox::common::protocol::PrimitiveType& GPUCompare::optype() const {
  return optype_ != NULL ? *optype_ : *default_instance_->optype_;
}
inline ::blox::common::protocol::PrimitiveType* GPUCompare::mutable_optype() {
  set_has_optype();
  if (optype_ == NULL) optype_ = new ::blox::common::protocol::PrimitiveType;
  return optype_;
}
inline ::blox::common::protocol::PrimitiveType* GPUCompare::release_optype() {
  clear_has_optype();
  ::blox::common::protocol::PrimitiveType* temp = optype_;
  optype_ = NULL;
  return temp;
}

// required .blox.compiler.gpu.Address addr1 = 3;
inline bool GPUCompare::has_addr1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPUCompare::set_has_addr1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPUCompare::clear_has_addr1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPUCompare::clear_addr1() {
  if (addr1_ != NULL) addr1_->::blox::compiler::gpu::Address::Clear();
  clear_has_addr1();
}
inline const ::blox::compiler::gpu::Address& GPUCompare::addr1() const {
  return addr1_ != NULL ? *addr1_ : *default_instance_->addr1_;
}
inline ::blox::compiler::gpu::Address* GPUCompare::mutable_addr1() {
  set_has_addr1();
  if (addr1_ == NULL) addr1_ = new ::blox::compiler::gpu::Address;
  return addr1_;
}
inline ::blox::compiler::gpu::Address* GPUCompare::release_addr1() {
  clear_has_addr1();
  ::blox::compiler::gpu::Address* temp = addr1_;
  addr1_ = NULL;
  return temp;
}

// required .blox.compiler.gpu.Address addr2 = 4;
inline bool GPUCompare::has_addr2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPUCompare::set_has_addr2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPUCompare::clear_has_addr2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPUCompare::clear_addr2() {
  if (addr2_ != NULL) addr2_->::blox::compiler::gpu::Address::Clear();
  clear_has_addr2();
}
inline const ::blox::compiler::gpu::Address& GPUCompare::addr2() const {
  return addr2_ != NULL ? *addr2_ : *default_instance_->addr2_;
}
inline ::blox::compiler::gpu::Address* GPUCompare::mutable_addr2() {
  set_has_addr2();
  if (addr2_ == NULL) addr2_ = new ::blox::compiler::gpu::Address;
  return addr2_;
}
inline ::blox::compiler::gpu::Address* GPUCompare::release_addr2() {
  clear_has_addr2();
  ::blox::compiler::gpu::Address* temp = addr2_;
  addr2_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GPUSequence

// required int32 uniqueIdentifier = 1;
inline bool GPUSequence::has_uniqueidentifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUSequence::set_has_uniqueidentifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUSequence::clear_has_uniqueidentifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUSequence::clear_uniqueidentifier() {
  uniqueidentifier_ = 0;
  clear_has_uniqueidentifier();
}
inline ::google::protobuf::int32 GPUSequence::uniqueidentifier() const {
  return uniqueidentifier_;
}
inline void GPUSequence::set_uniqueidentifier(::google::protobuf::int32 value) {
  set_has_uniqueidentifier();
  uniqueidentifier_ = value;
}

// repeated .blox.compiler.gpu.GPUCommand operators = 2;
inline int GPUSequence::operators_size() const {
  return operators_.size();
}
inline void GPUSequence::clear_operators() {
  operators_.Clear();
}
inline const ::blox::compiler::gpu::GPUCommand& GPUSequence::operators(int index) const {
  return operators_.Get(index);
}
inline ::blox::compiler::gpu::GPUCommand* GPUSequence::mutable_operators(int index) {
  return operators_.Mutable(index);
}
inline ::blox::compiler::gpu::GPUCommand* GPUSequence::add_operators() {
  return operators_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUCommand >&
GPUSequence::operators() const {
  return operators_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::GPUCommand >*
GPUSequence::mutable_operators() {
  return &operators_;
}

// -------------------------------------------------------------------

// NumType

// required .blox.compiler.gpu.Numeric typ = 1;
inline bool NumType::has_typ() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NumType::set_has_typ() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NumType::clear_has_typ() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NumType::clear_typ() {
  typ_ = 0;
  clear_has_typ();
}
inline blox::compiler::gpu::Numeric NumType::typ() const {
  return static_cast< blox::compiler::gpu::Numeric >(typ_);
}
inline void NumType::set_typ(blox::compiler::gpu::Numeric value) {
  GOOGLE_DCHECK(blox::compiler::gpu::Numeric_IsValid(value));
  set_has_typ();
  typ_ = value;
}

// required int32 size = 2;
inline bool NumType::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NumType::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NumType::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NumType::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 NumType::size() const {
  return size_;
}
inline void NumType::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// Univ

// required .blox.compiler.gpu.UnivTag tag = 1;
inline bool Univ::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Univ::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Univ::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Univ::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline blox::compiler::gpu::UnivTag Univ::tag() const {
  return static_cast< blox::compiler::gpu::UnivTag >(tag_);
}
inline void Univ::set_tag(blox::compiler::gpu::UnivTag value) {
  GOOGLE_DCHECK(blox::compiler::gpu::UnivTag_IsValid(value));
  set_has_tag();
  tag_ = value;
}

// optional .blox.compiler.gpu.NumType n = 2;
inline bool Univ::has_n() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Univ::set_has_n() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Univ::clear_has_n() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Univ::clear_n() {
  if (n_ != NULL) n_->::blox::compiler::gpu::NumType::Clear();
  clear_has_n();
}
inline const ::blox::compiler::gpu::NumType& Univ::n() const {
  return n_ != NULL ? *n_ : *default_instance_->n_;
}
inline ::blox::compiler::gpu::NumType* Univ::mutable_n() {
  set_has_n();
  if (n_ == NULL) n_ = new ::blox::compiler::gpu::NumType;
  return n_;
}
inline ::blox::compiler::gpu::NumType* Univ::release_n() {
  clear_has_n();
  ::blox::compiler::gpu::NumType* temp = n_;
  n_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.Fixed f = 3;
inline bool Univ::has_f() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Univ::set_has_f() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Univ::clear_has_f() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Univ::clear_f() {
  f_ = 0;
  clear_has_f();
}
inline blox::compiler::gpu::Fixed Univ::f() const {
  return static_cast< blox::compiler::gpu::Fixed >(f_);
}
inline void Univ::set_f(blox::compiler::gpu::Fixed value) {
  GOOGLE_DCHECK(blox::compiler::gpu::Fixed_IsValid(value));
  set_has_f();
  f_ = value;
}

// -------------------------------------------------------------------

// ConstExp

// required .blox.common.protocol.Constant literal = 1;
inline bool ConstExp::has_literal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConstExp::set_has_literal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConstExp::clear_has_literal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConstExp::clear_literal() {
  if (literal_ != NULL) literal_->::blox::common::protocol::Constant::Clear();
  clear_has_literal();
}
inline const ::blox::common::protocol::Constant& ConstExp::literal() const {
  return literal_ != NULL ? *literal_ : *default_instance_->literal_;
}
inline ::blox::common::protocol::Constant* ConstExp::mutable_literal() {
  set_has_literal();
  if (literal_ == NULL) literal_ = new ::blox::common::protocol::Constant;
  return literal_;
}
inline ::blox::common::protocol::Constant* ConstExp::release_literal() {
  clear_has_literal();
  ::blox::common::protocol::Constant* temp = literal_;
  literal_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Name

// required string ename = 1;
inline bool Name::has_ename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Name::set_has_ename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Name::clear_has_ename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Name::clear_ename() {
  if (ename_ != &::google::protobuf::internal::kEmptyString) {
    ename_->clear();
  }
  clear_has_ename();
}
inline const ::std::string& Name::ename() const {
  return *ename_;
}
inline void Name::set_ename(const ::std::string& value) {
  set_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    ename_ = new ::std::string;
  }
  ename_->assign(value);
}
inline void Name::set_ename(const char* value) {
  set_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    ename_ = new ::std::string;
  }
  ename_->assign(value);
}
inline void Name::set_ename(const char* value, size_t size) {
  set_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    ename_ = new ::std::string;
  }
  ename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Name::mutable_ename() {
  set_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    ename_ = new ::std::string;
  }
  return ename_;
}
inline ::std::string* Name::release_ename() {
  clear_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ename_;
    ename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .blox.common.protocol.Type etype = 2;
inline bool Name::has_etype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Name::set_has_etype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Name::clear_has_etype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Name::clear_etype() {
  if (etype_ != NULL) etype_->::blox::common::protocol::Type::Clear();
  clear_has_etype();
}
inline const ::blox::common::protocol::Type& Name::etype() const {
  return etype_ != NULL ? *etype_ : *default_instance_->etype_;
}
inline ::blox::common::protocol::Type* Name::mutable_etype() {
  set_has_etype();
  if (etype_ == NULL) etype_ = new ::blox::common::protocol::Type;
  return etype_;
}
inline ::blox::common::protocol::Type* Name::release_etype() {
  clear_has_etype();
  ::blox::common::protocol::Type* temp = etype_;
  etype_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Index

// required int32 offset = 1;
inline bool Index::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Index::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Index::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Index::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 Index::offset() const {
  return offset_;
}
inline void Index::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// required .blox.common.protocol.Type etyp = 2;
inline bool Index::has_etyp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Index::set_has_etyp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Index::clear_has_etyp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Index::clear_etyp() {
  if (etyp_ != NULL) etyp_->::blox::common::protocol::Type::Clear();
  clear_has_etyp();
}
inline const ::blox::common::protocol::Type& Index::etyp() const {
  return etyp_ != NULL ? *etyp_ : *default_instance_->etyp_;
}
inline ::blox::common::protocol::Type* Index::mutable_etyp() {
  set_has_etyp();
  if (etyp_ == NULL) etyp_ = new ::blox::common::protocol::Type;
  return etyp_;
}
inline ::blox::common::protocol::Type* Index::release_etyp() {
  clear_has_etyp();
  ::blox::common::protocol::Type* temp = etyp_;
  etyp_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ArithExp

// required .blox.compiler.gpu.NumType domain = 1;
inline bool ArithExp::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArithExp::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArithExp::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArithExp::clear_domain() {
  if (domain_ != NULL) domain_->::blox::compiler::gpu::NumType::Clear();
  clear_has_domain();
}
inline const ::blox::compiler::gpu::NumType& ArithExp::domain() const {
  return domain_ != NULL ? *domain_ : *default_instance_->domain_;
}
inline ::blox::compiler::gpu::NumType* ArithExp::mutable_domain() {
  set_has_domain();
  if (domain_ == NULL) domain_ = new ::blox::compiler::gpu::NumType;
  return domain_;
}
inline ::blox::compiler::gpu::NumType* ArithExp::release_domain() {
  clear_has_domain();
  ::blox::compiler::gpu::NumType* temp = domain_;
  domain_ = NULL;
  return temp;
}

// required .blox.compiler.gpu.ArithmeticOp op = 2;
inline bool ArithExp::has_op() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArithExp::set_has_op() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArithExp::clear_has_op() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArithExp::clear_op() {
  op_ = 0;
  clear_has_op();
}
inline blox::compiler::gpu::ArithmeticOp ArithExp::op() const {
  return static_cast< blox::compiler::gpu::ArithmeticOp >(op_);
}
inline void ArithExp::set_op(blox::compiler::gpu::ArithmeticOp value) {
  GOOGLE_DCHECK(blox::compiler::gpu::ArithmeticOp_IsValid(value));
  set_has_op();
  op_ = value;
}

// required .blox.compiler.gpu.Exp exp1 = 3;
inline bool ArithExp::has_exp1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArithExp::set_has_exp1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArithExp::clear_has_exp1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArithExp::clear_exp1() {
  if (exp1_ != NULL) exp1_->::blox::compiler::gpu::Exp::Clear();
  clear_has_exp1();
}
inline const ::blox::compiler::gpu::Exp& ArithExp::exp1() const {
  return exp1_ != NULL ? *exp1_ : *default_instance_->exp1_;
}
inline ::blox::compiler::gpu::Exp* ArithExp::mutable_exp1() {
  set_has_exp1();
  if (exp1_ == NULL) exp1_ = new ::blox::compiler::gpu::Exp;
  return exp1_;
}
inline ::blox::compiler::gpu::Exp* ArithExp::release_exp1() {
  clear_has_exp1();
  ::blox::compiler::gpu::Exp* temp = exp1_;
  exp1_ = NULL;
  return temp;
}

// required .blox.compiler.gpu.Exp exp2 = 4;
inline bool ArithExp::has_exp2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArithExp::set_has_exp2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArithExp::clear_has_exp2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArithExp::clear_exp2() {
  if (exp2_ != NULL) exp2_->::blox::compiler::gpu::Exp::Clear();
  clear_has_exp2();
}
inline const ::blox::compiler::gpu::Exp& ArithExp::exp2() const {
  return exp2_ != NULL ? *exp2_ : *default_instance_->exp2_;
}
inline ::blox::compiler::gpu::Exp* ArithExp::mutable_exp2() {
  set_has_exp2();
  if (exp2_ == NULL) exp2_ = new ::blox::compiler::gpu::Exp;
  return exp2_;
}
inline ::blox::compiler::gpu::Exp* ArithExp::release_exp2() {
  clear_has_exp2();
  ::blox::compiler::gpu::Exp* temp = exp2_;
  exp2_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Convert

// required .blox.compiler.gpu.Univ convDom = 1;
inline bool Convert::has_convdom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Convert::set_has_convdom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Convert::clear_has_convdom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Convert::clear_convdom() {
  if (convdom_ != NULL) convdom_->::blox::compiler::gpu::Univ::Clear();
  clear_has_convdom();
}
inline const ::blox::compiler::gpu::Univ& Convert::convdom() const {
  return convdom_ != NULL ? *convdom_ : *default_instance_->convdom_;
}
inline ::blox::compiler::gpu::Univ* Convert::mutable_convdom() {
  set_has_convdom();
  if (convdom_ == NULL) convdom_ = new ::blox::compiler::gpu::Univ;
  return convdom_;
}
inline ::blox::compiler::gpu::Univ* Convert::release_convdom() {
  clear_has_convdom();
  ::blox::compiler::gpu::Univ* temp = convdom_;
  convdom_ = NULL;
  return temp;
}

// required .blox.compiler.gpu.Univ convRng = 2;
inline bool Convert::has_convrng() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Convert::set_has_convrng() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Convert::clear_has_convrng() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Convert::clear_convrng() {
  if (convrng_ != NULL) convrng_->::blox::compiler::gpu::Univ::Clear();
  clear_has_convrng();
}
inline const ::blox::compiler::gpu::Univ& Convert::convrng() const {
  return convrng_ != NULL ? *convrng_ : *default_instance_->convrng_;
}
inline ::blox::compiler::gpu::Univ* Convert::mutable_convrng() {
  set_has_convrng();
  if (convrng_ == NULL) convrng_ = new ::blox::compiler::gpu::Univ;
  return convrng_;
}
inline ::blox::compiler::gpu::Univ* Convert::release_convrng() {
  clear_has_convrng();
  ::blox::compiler::gpu::Univ* temp = convrng_;
  convrng_ = NULL;
  return temp;
}

// required .blox.compiler.gpu.Exp exp2 = 3;
inline bool Convert::has_exp2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Convert::set_has_exp2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Convert::clear_has_exp2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Convert::clear_exp2() {
  if (exp2_ != NULL) exp2_->::blox::compiler::gpu::Exp::Clear();
  clear_has_exp2();
}
inline const ::blox::compiler::gpu::Exp& Convert::exp2() const {
  return exp2_ != NULL ? *exp2_ : *default_instance_->exp2_;
}
inline ::blox::compiler::gpu::Exp* Convert::mutable_exp2() {
  set_has_exp2();
  if (exp2_ == NULL) exp2_ = new ::blox::compiler::gpu::Exp;
  return exp2_;
}
inline ::blox::compiler::gpu::Exp* Convert::release_exp2() {
  clear_has_exp2();
  ::blox::compiler::gpu::Exp* temp = exp2_;
  exp2_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Mixed

// required .blox.compiler.gpu.NumType domain = 1;
inline bool Mixed::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mixed::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mixed::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mixed::clear_domain() {
  if (domain_ != NULL) domain_->::blox::compiler::gpu::NumType::Clear();
  clear_has_domain();
}
inline const ::blox::compiler::gpu::NumType& Mixed::domain() const {
  return domain_ != NULL ? *domain_ : *default_instance_->domain_;
}
inline ::blox::compiler::gpu::NumType* Mixed::mutable_domain() {
  set_has_domain();
  if (domain_ == NULL) domain_ = new ::blox::compiler::gpu::NumType;
  return domain_;
}
inline ::blox::compiler::gpu::NumType* Mixed::release_domain() {
  clear_has_domain();
  ::blox::compiler::gpu::NumType* temp = domain_;
  domain_ = NULL;
  return temp;
}

// required .blox.compiler.gpu.NumType range = 2;
inline bool Mixed::has_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mixed::set_has_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mixed::clear_has_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mixed::clear_range() {
  if (range_ != NULL) range_->::blox::compiler::gpu::NumType::Clear();
  clear_has_range();
}
inline const ::blox::compiler::gpu::NumType& Mixed::range() const {
  return range_ != NULL ? *range_ : *default_instance_->range_;
}
inline ::blox::compiler::gpu::NumType* Mixed::mutable_range() {
  set_has_range();
  if (range_ == NULL) range_ = new ::blox::compiler::gpu::NumType;
  return range_;
}
inline ::blox::compiler::gpu::NumType* Mixed::release_range() {
  clear_has_range();
  ::blox::compiler::gpu::NumType* temp = range_;
  range_ = NULL;
  return temp;
}

// required .blox.compiler.gpu.Exp exp1 = 3;
inline bool Mixed::has_exp1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mixed::set_has_exp1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mixed::clear_has_exp1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mixed::clear_exp1() {
  if (exp1_ != NULL) exp1_->::blox::compiler::gpu::Exp::Clear();
  clear_has_exp1();
}
inline const ::blox::compiler::gpu::Exp& Mixed::exp1() const {
  return exp1_ != NULL ? *exp1_ : *default_instance_->exp1_;
}
inline ::blox::compiler::gpu::Exp* Mixed::mutable_exp1() {
  set_has_exp1();
  if (exp1_ == NULL) exp1_ = new ::blox::compiler::gpu::Exp;
  return exp1_;
}
inline ::blox::compiler::gpu::Exp* Mixed::release_exp1() {
  clear_has_exp1();
  ::blox::compiler::gpu::Exp* temp = exp1_;
  exp1_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Call

// required .blox.compiler.gpu.Fixed calltype = 1;
inline bool Call::has_calltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call::set_has_calltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call::clear_has_calltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call::clear_calltype() {
  calltype_ = 0;
  clear_has_calltype();
}
inline blox::compiler::gpu::Fixed Call::calltype() const {
  return static_cast< blox::compiler::gpu::Fixed >(calltype_);
}
inline void Call::set_calltype(blox::compiler::gpu::Fixed value) {
  GOOGLE_DCHECK(blox::compiler::gpu::Fixed_IsValid(value));
  set_has_calltype();
  calltype_ = value;
}

// required string callname = 2;
inline bool Call::has_callname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call::set_has_callname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call::clear_has_callname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call::clear_callname() {
  if (callname_ != &::google::protobuf::internal::kEmptyString) {
    callname_->clear();
  }
  clear_has_callname();
}
inline const ::std::string& Call::callname() const {
  return *callname_;
}
inline void Call::set_callname(const ::std::string& value) {
  set_has_callname();
  if (callname_ == &::google::protobuf::internal::kEmptyString) {
    callname_ = new ::std::string;
  }
  callname_->assign(value);
}
inline void Call::set_callname(const char* value) {
  set_has_callname();
  if (callname_ == &::google::protobuf::internal::kEmptyString) {
    callname_ = new ::std::string;
  }
  callname_->assign(value);
}
inline void Call::set_callname(const char* value, size_t size) {
  set_has_callname();
  if (callname_ == &::google::protobuf::internal::kEmptyString) {
    callname_ = new ::std::string;
  }
  callname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Call::mutable_callname() {
  set_has_callname();
  if (callname_ == &::google::protobuf::internal::kEmptyString) {
    callname_ = new ::std::string;
  }
  return callname_;
}
inline ::std::string* Call::release_callname() {
  clear_has_callname();
  if (callname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callname_;
    callname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .blox.compiler.gpu.Exp args = 3;
inline int Call::args_size() const {
  return args_.size();
}
inline void Call::clear_args() {
  args_.Clear();
}
inline const ::blox::compiler::gpu::Exp& Call::args(int index) const {
  return args_.Get(index);
}
inline ::blox::compiler::gpu::Exp* Call::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::blox::compiler::gpu::Exp* Call::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >&
Call::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >*
Call::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// Exp

// required .blox.compiler.gpu.ExpTag tag = 1;
inline bool Exp::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Exp::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Exp::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Exp::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline blox::compiler::gpu::ExpTag Exp::tag() const {
  return static_cast< blox::compiler::gpu::ExpTag >(tag_);
}
inline void Exp::set_tag(blox::compiler::gpu::ExpTag value) {
  GOOGLE_DCHECK(blox::compiler::gpu::ExpTag_IsValid(value));
  set_has_tag();
  tag_ = value;
}

// optional .blox.compiler.gpu.ConstExp constExp = 2;
inline bool Exp::has_constexp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Exp::set_has_constexp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Exp::clear_has_constexp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Exp::clear_constexp() {
  if (constexp_ != NULL) constexp_->::blox::compiler::gpu::ConstExp::Clear();
  clear_has_constexp();
}
inline const ::blox::compiler::gpu::ConstExp& Exp::constexp() const {
  return constexp_ != NULL ? *constexp_ : *default_instance_->constexp_;
}
inline ::blox::compiler::gpu::ConstExp* Exp::mutable_constexp() {
  set_has_constexp();
  if (constexp_ == NULL) constexp_ = new ::blox::compiler::gpu::ConstExp;
  return constexp_;
}
inline ::blox::compiler::gpu::ConstExp* Exp::release_constexp() {
  clear_has_constexp();
  ::blox::compiler::gpu::ConstExp* temp = constexp_;
  constexp_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.Index index = 3;
inline bool Exp::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Exp::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Exp::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Exp::clear_index() {
  if (index_ != NULL) index_->::blox::compiler::gpu::Index::Clear();
  clear_has_index();
}
inline const ::blox::compiler::gpu::Index& Exp::index() const {
  return index_ != NULL ? *index_ : *default_instance_->index_;
}
inline ::blox::compiler::gpu::Index* Exp::mutable_index() {
  set_has_index();
  if (index_ == NULL) index_ = new ::blox::compiler::gpu::Index;
  return index_;
}
inline ::blox::compiler::gpu::Index* Exp::release_index() {
  clear_has_index();
  ::blox::compiler::gpu::Index* temp = index_;
  index_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.Name name = 4;
inline bool Exp::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Exp::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Exp::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Exp::clear_name() {
  if (name_ != NULL) name_->::blox::compiler::gpu::Name::Clear();
  clear_has_name();
}
inline const ::blox::compiler::gpu::Name& Exp::name() const {
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::blox::compiler::gpu::Name* Exp::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::blox::compiler::gpu::Name;
  return name_;
}
inline ::blox::compiler::gpu::Name* Exp::release_name() {
  clear_has_name();
  ::blox::compiler::gpu::Name* temp = name_;
  name_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.ArithExp arithexp = 5;
inline bool Exp::has_arithexp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Exp::set_has_arithexp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Exp::clear_has_arithexp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Exp::clear_arithexp() {
  if (arithexp_ != NULL) arithexp_->::blox::compiler::gpu::ArithExp::Clear();
  clear_has_arithexp();
}
inline const ::blox::compiler::gpu::ArithExp& Exp::arithexp() const {
  return arithexp_ != NULL ? *arithexp_ : *default_instance_->arithexp_;
}
inline ::blox::compiler::gpu::ArithExp* Exp::mutable_arithexp() {
  set_has_arithexp();
  if (arithexp_ == NULL) arithexp_ = new ::blox::compiler::gpu::ArithExp;
  return arithexp_;
}
inline ::blox::compiler::gpu::ArithExp* Exp::release_arithexp() {
  clear_has_arithexp();
  ::blox::compiler::gpu::ArithExp* temp = arithexp_;
  arithexp_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.Convert convert = 6;
inline bool Exp::has_convert() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Exp::set_has_convert() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Exp::clear_has_convert() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Exp::clear_convert() {
  if (convert_ != NULL) convert_->::blox::compiler::gpu::Convert::Clear();
  clear_has_convert();
}
inline const ::blox::compiler::gpu::Convert& Exp::convert() const {
  return convert_ != NULL ? *convert_ : *default_instance_->convert_;
}
inline ::blox::compiler::gpu::Convert* Exp::mutable_convert() {
  set_has_convert();
  if (convert_ == NULL) convert_ = new ::blox::compiler::gpu::Convert;
  return convert_;
}
inline ::blox::compiler::gpu::Convert* Exp::release_convert() {
  clear_has_convert();
  ::blox::compiler::gpu::Convert* temp = convert_;
  convert_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.Mixed mixed = 7;
inline bool Exp::has_mixed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Exp::set_has_mixed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Exp::clear_has_mixed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Exp::clear_mixed() {
  if (mixed_ != NULL) mixed_->::blox::compiler::gpu::Mixed::Clear();
  clear_has_mixed();
}
inline const ::blox::compiler::gpu::Mixed& Exp::mixed() const {
  return mixed_ != NULL ? *mixed_ : *default_instance_->mixed_;
}
inline ::blox::compiler::gpu::Mixed* Exp::mutable_mixed() {
  set_has_mixed();
  if (mixed_ == NULL) mixed_ = new ::blox::compiler::gpu::Mixed;
  return mixed_;
}
inline ::blox::compiler::gpu::Mixed* Exp::release_mixed() {
  clear_has_mixed();
  ::blox::compiler::gpu::Mixed* temp = mixed_;
  mixed_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.Call call = 8;
inline bool Exp::has_call() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Exp::set_has_call() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Exp::clear_has_call() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Exp::clear_call() {
  if (call_ != NULL) call_->::blox::compiler::gpu::Call::Clear();
  clear_has_call();
}
inline const ::blox::compiler::gpu::Call& Exp::call() const {
  return call_ != NULL ? *call_ : *default_instance_->call_;
}
inline ::blox::compiler::gpu::Call* Exp::mutable_call() {
  set_has_call();
  if (call_ == NULL) call_ = new ::blox::compiler::gpu::Call;
  return call_;
}
inline ::blox::compiler::gpu::Call* Exp::release_call() {
  clear_has_call();
  ::blox::compiler::gpu::Call* temp = call_;
  call_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Comp

// required .blox.compiler.gpu.Comparison comparison = 1;
inline bool Comp::has_comparison() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Comp::set_has_comparison() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Comp::clear_has_comparison() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Comp::clear_comparison() {
  comparison_ = 0;
  clear_has_comparison();
}
inline blox::compiler::gpu::Comparison Comp::comparison() const {
  return static_cast< blox::compiler::gpu::Comparison >(comparison_);
}
inline void Comp::set_comparison(blox::compiler::gpu::Comparison value) {
  GOOGLE_DCHECK(blox::compiler::gpu::Comparison_IsValid(value));
  set_has_comparison();
  comparison_ = value;
}

// required .blox.compiler.gpu.Exp op1 = 2;
inline bool Comp::has_op1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Comp::set_has_op1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Comp::clear_has_op1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Comp::clear_op1() {
  if (op1_ != NULL) op1_->::blox::compiler::gpu::Exp::Clear();
  clear_has_op1();
}
inline const ::blox::compiler::gpu::Exp& Comp::op1() const {
  return op1_ != NULL ? *op1_ : *default_instance_->op1_;
}
inline ::blox::compiler::gpu::Exp* Comp::mutable_op1() {
  set_has_op1();
  if (op1_ == NULL) op1_ = new ::blox::compiler::gpu::Exp;
  return op1_;
}
inline ::blox::compiler::gpu::Exp* Comp::release_op1() {
  clear_has_op1();
  ::blox::compiler::gpu::Exp* temp = op1_;
  op1_ = NULL;
  return temp;
}

// required .blox.compiler.gpu.Exp op2 = 3;
inline bool Comp::has_op2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Comp::set_has_op2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Comp::clear_has_op2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Comp::clear_op2() {
  if (op2_ != NULL) op2_->::blox::compiler::gpu::Exp::Clear();
  clear_has_op2();
}
inline const ::blox::compiler::gpu::Exp& Comp::op2() const {
  return op2_ != NULL ? *op2_ : *default_instance_->op2_;
}
inline ::blox::compiler::gpu::Exp* Comp::mutable_op2() {
  set_has_op2();
  if (op2_ == NULL) op2_ = new ::blox::compiler::gpu::Exp;
  return op2_;
}
inline ::blox::compiler::gpu::Exp* Comp::release_op2() {
  clear_has_op2();
  ::blox::compiler::gpu::Exp* temp = op2_;
  op2_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Test

// required .blox.compiler.gpu.Fixed testtype = 1;
inline bool Test::has_testtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test::set_has_testtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test::clear_has_testtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test::clear_testtype() {
  testtype_ = 0;
  clear_has_testtype();
}
inline blox::compiler::gpu::Fixed Test::testtype() const {
  return static_cast< blox::compiler::gpu::Fixed >(testtype_);
}
inline void Test::set_testtype(blox::compiler::gpu::Fixed value) {
  GOOGLE_DCHECK(blox::compiler::gpu::Fixed_IsValid(value));
  set_has_testtype();
  testtype_ = value;
}

// required string testname = 2;
inline bool Test::has_testname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test::set_has_testname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test::clear_has_testname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test::clear_testname() {
  if (testname_ != &::google::protobuf::internal::kEmptyString) {
    testname_->clear();
  }
  clear_has_testname();
}
inline const ::std::string& Test::testname() const {
  return *testname_;
}
inline void Test::set_testname(const ::std::string& value) {
  set_has_testname();
  if (testname_ == &::google::protobuf::internal::kEmptyString) {
    testname_ = new ::std::string;
  }
  testname_->assign(value);
}
inline void Test::set_testname(const char* value) {
  set_has_testname();
  if (testname_ == &::google::protobuf::internal::kEmptyString) {
    testname_ = new ::std::string;
  }
  testname_->assign(value);
}
inline void Test::set_testname(const char* value, size_t size) {
  set_has_testname();
  if (testname_ == &::google::protobuf::internal::kEmptyString) {
    testname_ = new ::std::string;
  }
  testname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Test::mutable_testname() {
  set_has_testname();
  if (testname_ == &::google::protobuf::internal::kEmptyString) {
    testname_ = new ::std::string;
  }
  return testname_;
}
inline ::std::string* Test::release_testname() {
  clear_has_testname();
  if (testname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = testname_;
    testname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .blox.compiler.gpu.Exp ops = 3;
inline int Test::ops_size() const {
  return ops_.size();
}
inline void Test::clear_ops() {
  ops_.Clear();
}
inline const ::blox::compiler::gpu::Exp& Test::ops(int index) const {
  return ops_.Get(index);
}
inline ::blox::compiler::gpu::Exp* Test::mutable_ops(int index) {
  return ops_.Mutable(index);
}
inline ::blox::compiler::gpu::Exp* Test::add_ops() {
  return ops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >&
Test::ops() const {
  return ops_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::compiler::gpu::Exp >*
Test::mutable_ops() {
  return &ops_;
}

// -------------------------------------------------------------------

// And

// required .blox.compiler.gpu.Compare and1 = 1;
inline bool And::has_and1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void And::set_has_and1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void And::clear_has_and1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void And::clear_and1() {
  if (and1_ != NULL) and1_->::blox::compiler::gpu::Compare::Clear();
  clear_has_and1();
}
inline const ::blox::compiler::gpu::Compare& And::and1() const {
  return and1_ != NULL ? *and1_ : *default_instance_->and1_;
}
inline ::blox::compiler::gpu::Compare* And::mutable_and1() {
  set_has_and1();
  if (and1_ == NULL) and1_ = new ::blox::compiler::gpu::Compare;
  return and1_;
}
inline ::blox::compiler::gpu::Compare* And::release_and1() {
  clear_has_and1();
  ::blox::compiler::gpu::Compare* temp = and1_;
  and1_ = NULL;
  return temp;
}

// required .blox.compiler.gpu.Compare and2 = 2;
inline bool And::has_and2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void And::set_has_and2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void And::clear_has_and2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void And::clear_and2() {
  if (and2_ != NULL) and2_->::blox::compiler::gpu::Compare::Clear();
  clear_has_and2();
}
inline const ::blox::compiler::gpu::Compare& And::and2() const {
  return and2_ != NULL ? *and2_ : *default_instance_->and2_;
}
inline ::blox::compiler::gpu::Compare* And::mutable_and2() {
  set_has_and2();
  if (and2_ == NULL) and2_ = new ::blox::compiler::gpu::Compare;
  return and2_;
}
inline ::blox::compiler::gpu::Compare* And::release_and2() {
  clear_has_and2();
  ::blox::compiler::gpu::Compare* temp = and2_;
  and2_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Compare

// required .blox.compiler.gpu.CompareTag tag = 1;
inline bool Compare::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Compare::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Compare::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Compare::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline blox::compiler::gpu::CompareTag Compare::tag() const {
  return static_cast< blox::compiler::gpu::CompareTag >(tag_);
}
inline void Compare::set_tag(blox::compiler::gpu::CompareTag value) {
  GOOGLE_DCHECK(blox::compiler::gpu::CompareTag_IsValid(value));
  set_has_tag();
  tag_ = value;
}

// optional .blox.compiler.gpu.Comp comp = 2;
inline bool Compare::has_comp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Compare::set_has_comp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Compare::clear_has_comp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Compare::clear_comp() {
  if (comp_ != NULL) comp_->::blox::compiler::gpu::Comp::Clear();
  clear_has_comp();
}
inline const ::blox::compiler::gpu::Comp& Compare::comp() const {
  return comp_ != NULL ? *comp_ : *default_instance_->comp_;
}
inline ::blox::compiler::gpu::Comp* Compare::mutable_comp() {
  set_has_comp();
  if (comp_ == NULL) comp_ = new ::blox::compiler::gpu::Comp;
  return comp_;
}
inline ::blox::compiler::gpu::Comp* Compare::release_comp() {
  clear_has_comp();
  ::blox::compiler::gpu::Comp* temp = comp_;
  comp_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.Test test = 3;
inline bool Compare::has_test() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Compare::set_has_test() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Compare::clear_has_test() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Compare::clear_test() {
  if (test_ != NULL) test_->::blox::compiler::gpu::Test::Clear();
  clear_has_test();
}
inline const ::blox::compiler::gpu::Test& Compare::test() const {
  return test_ != NULL ? *test_ : *default_instance_->test_;
}
inline ::blox::compiler::gpu::Test* Compare::mutable_test() {
  set_has_test();
  if (test_ == NULL) test_ = new ::blox::compiler::gpu::Test;
  return test_;
}
inline ::blox::compiler::gpu::Test* Compare::release_test() {
  clear_has_test();
  ::blox::compiler::gpu::Test* temp = test_;
  test_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.And andComp = 4;
inline bool Compare::has_andcomp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Compare::set_has_andcomp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Compare::clear_has_andcomp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Compare::clear_andcomp() {
  if (andcomp_ != NULL) andcomp_->::blox::compiler::gpu::And::Clear();
  clear_has_andcomp();
}
inline const ::blox::compiler::gpu::And& Compare::andcomp() const {
  return andcomp_ != NULL ? *andcomp_ : *default_instance_->andcomp_;
}
inline ::blox::compiler::gpu::And* Compare::mutable_andcomp() {
  set_has_andcomp();
  if (andcomp_ == NULL) andcomp_ = new ::blox::compiler::gpu::And;
  return andcomp_;
}
inline ::blox::compiler::gpu::And* Compare::release_andcomp() {
  clear_has_andcomp();
  ::blox::compiler::gpu::And* temp = andcomp_;
  andcomp_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Count

// required int32 aggrng = 1;
inline bool Count::has_aggrng() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Count::set_has_aggrng() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Count::clear_has_aggrng() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Count::clear_aggrng() {
  aggrng_ = 0;
  clear_has_aggrng();
}
inline ::google::protobuf::int32 Count::aggrng() const {
  return aggrng_;
}
inline void Count::set_aggrng(::google::protobuf::int32 value) {
  set_has_aggrng();
  aggrng_ = value;
}

// -------------------------------------------------------------------

// Total

// required int32 aggdom = 1;
inline bool Total::has_aggdom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Total::set_has_aggdom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Total::clear_has_aggdom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Total::clear_aggdom() {
  aggdom_ = 0;
  clear_has_aggdom();
}
inline ::google::protobuf::int32 Total::aggdom() const {
  return aggdom_;
}
inline void Total::set_aggdom(::google::protobuf::int32 value) {
  set_has_aggdom();
  aggdom_ = value;
}

// required int32 aggrng = 2;
inline bool Total::has_aggrng() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Total::set_has_aggrng() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Total::clear_has_aggrng() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Total::clear_aggrng() {
  aggrng_ = 0;
  clear_has_aggrng();
}
inline ::google::protobuf::int32 Total::aggrng() const {
  return aggrng_;
}
inline void Total::set_aggrng(::google::protobuf::int32 value) {
  set_has_aggrng();
  aggrng_ = value;
}

// -------------------------------------------------------------------

// Min

// required int32 aggdom = 1;
inline bool Min::has_aggdom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Min::set_has_aggdom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Min::clear_has_aggdom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Min::clear_aggdom() {
  aggdom_ = 0;
  clear_has_aggdom();
}
inline ::google::protobuf::int32 Min::aggdom() const {
  return aggdom_;
}
inline void Min::set_aggdom(::google::protobuf::int32 value) {
  set_has_aggdom();
  aggdom_ = value;
}

// required int32 aggrng = 2;
inline bool Min::has_aggrng() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Min::set_has_aggrng() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Min::clear_has_aggrng() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Min::clear_aggrng() {
  aggrng_ = 0;
  clear_has_aggrng();
}
inline ::google::protobuf::int32 Min::aggrng() const {
  return aggrng_;
}
inline void Min::set_aggrng(::google::protobuf::int32 value) {
  set_has_aggrng();
  aggrng_ = value;
}

// -------------------------------------------------------------------

// Max

// required int32 aggdom = 1;
inline bool Max::has_aggdom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Max::set_has_aggdom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Max::clear_has_aggdom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Max::clear_aggdom() {
  aggdom_ = 0;
  clear_has_aggdom();
}
inline ::google::protobuf::int32 Max::aggdom() const {
  return aggdom_;
}
inline void Max::set_aggdom(::google::protobuf::int32 value) {
  set_has_aggdom();
  aggdom_ = value;
}

// required int32 aggrng = 2;
inline bool Max::has_aggrng() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Max::set_has_aggrng() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Max::clear_has_aggrng() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Max::clear_aggrng() {
  aggrng_ = 0;
  clear_has_aggrng();
}
inline ::google::protobuf::int32 Max::aggrng() const {
  return aggrng_;
}
inline void Max::set_aggrng(::google::protobuf::int32 value) {
  set_has_aggrng();
  aggrng_ = value;
}

// -------------------------------------------------------------------

// Agg

// required .blox.compiler.gpu.AggTag tag = 1;
inline bool Agg::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Agg::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Agg::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Agg::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline blox::compiler::gpu::AggTag Agg::tag() const {
  return static_cast< blox::compiler::gpu::AggTag >(tag_);
}
inline void Agg::set_tag(blox::compiler::gpu::AggTag value) {
  GOOGLE_DCHECK(blox::compiler::gpu::AggTag_IsValid(value));
  set_has_tag();
  tag_ = value;
}

// optional .blox.compiler.gpu.Count count = 2;
inline bool Agg::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Agg::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Agg::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Agg::clear_count() {
  if (count_ != NULL) count_->::blox::compiler::gpu::Count::Clear();
  clear_has_count();
}
inline const ::blox::compiler::gpu::Count& Agg::count() const {
  return count_ != NULL ? *count_ : *default_instance_->count_;
}
inline ::blox::compiler::gpu::Count* Agg::mutable_count() {
  set_has_count();
  if (count_ == NULL) count_ = new ::blox::compiler::gpu::Count;
  return count_;
}
inline ::blox::compiler::gpu::Count* Agg::release_count() {
  clear_has_count();
  ::blox::compiler::gpu::Count* temp = count_;
  count_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.Total total = 3;
inline bool Agg::has_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Agg::set_has_total() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Agg::clear_has_total() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Agg::clear_total() {
  if (total_ != NULL) total_->::blox::compiler::gpu::Total::Clear();
  clear_has_total();
}
inline const ::blox::compiler::gpu::Total& Agg::total() const {
  return total_ != NULL ? *total_ : *default_instance_->total_;
}
inline ::blox::compiler::gpu::Total* Agg::mutable_total() {
  set_has_total();
  if (total_ == NULL) total_ = new ::blox::compiler::gpu::Total;
  return total_;
}
inline ::blox::compiler::gpu::Total* Agg::release_total() {
  clear_has_total();
  ::blox::compiler::gpu::Total* temp = total_;
  total_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.Min min = 4;
inline bool Agg::has_min() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Agg::set_has_min() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Agg::clear_has_min() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Agg::clear_min() {
  if (min_ != NULL) min_->::blox::compiler::gpu::Min::Clear();
  clear_has_min();
}
inline const ::blox::compiler::gpu::Min& Agg::min() const {
  return min_ != NULL ? *min_ : *default_instance_->min_;
}
inline ::blox::compiler::gpu::Min* Agg::mutable_min() {
  set_has_min();
  if (min_ == NULL) min_ = new ::blox::compiler::gpu::Min;
  return min_;
}
inline ::blox::compiler::gpu::Min* Agg::release_min() {
  clear_has_min();
  ::blox::compiler::gpu::Min* temp = min_;
  min_ = NULL;
  return temp;
}

// optional .blox.compiler.gpu.Max max = 5;
inline bool Agg::has_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Agg::set_has_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Agg::clear_has_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Agg::clear_max() {
  if (max_ != NULL) max_->::blox::compiler::gpu::Max::Clear();
  clear_has_max();
}
inline const ::blox::compiler::gpu::Max& Agg::max() const {
  return max_ != NULL ? *max_ : *default_instance_->max_;
}
inline ::blox::compiler::gpu::Max* Agg::mutable_max() {
  set_has_max();
  if (max_ == NULL) max_ = new ::blox::compiler::gpu::Max;
  return max_;
}
inline ::blox::compiler::gpu::Max* Agg::release_max() {
  clear_has_max();
  ::blox::compiler::gpu::Max* temp = max_;
  max_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gpu
}  // namespace compiler
}  // namespace blox

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::compiler::gpu::OperatorTag>() {
  return blox::compiler::gpu::OperatorTag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::compiler::gpu::CommandTag>() {
  return blox::compiler::gpu::CommandTag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::compiler::gpu::Comparison>() {
  return blox::compiler::gpu::Comparison_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::compiler::gpu::AddressTag>() {
  return blox::compiler::gpu::AddressTag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::compiler::gpu::ArithmeticOp>() {
  return blox::compiler::gpu::ArithmeticOp_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::compiler::gpu::Numeric>() {
  return blox::compiler::gpu::Numeric_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::compiler::gpu::Fixed>() {
  return blox::compiler::gpu::Fixed_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::compiler::gpu::UnivTag>() {
  return blox::compiler::gpu::UnivTag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::compiler::gpu::ExpTag>() {
  return blox::compiler::gpu::ExpTag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::compiler::gpu::CompareTag>() {
  return blox::compiler::gpu::CompareTag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::compiler::gpu::AggTag>() {
  return blox::compiler::gpu::AggTag_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RelationalAlgebra_2eproto__INCLUDED

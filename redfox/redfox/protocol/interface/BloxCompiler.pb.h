// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BloxCompiler.proto

#ifndef PROTOBUF_BloxCompiler_2eproto__INCLUDED
#define PROTOBUF_BloxCompiler_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace blox {
namespace common {
namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BloxCompiler_2eproto();
void protobuf_AssignDesc_BloxCompiler_2eproto();
void protobuf_ShutdownFile_BloxCompiler_2eproto();

class CompilationProblems;
class Problem;
class Position;
class PredicateInfo;
class Constant;
class BoolConstant;
class IntConstant;
class UnsignedIntConstant;
class FloatConstant;
class StringConstant;
class DateTimeConstant;
class Type;
class PrimitiveType;
class UnaryPredicateType;

enum Constant_Kind {
  Constant_Kind_BOOL = 0,
  Constant_Kind_INT = 1,
  Constant_Kind_FLOAT = 2,
  Constant_Kind_STRING = 3,
  Constant_Kind_DATETIME = 4,
  Constant_Kind_UINT = 5
};
bool Constant_Kind_IsValid(int value);
const Constant_Kind Constant_Kind_Kind_MIN = Constant_Kind_BOOL;
const Constant_Kind Constant_Kind_Kind_MAX = Constant_Kind_UINT;
const int Constant_Kind_Kind_ARRAYSIZE = Constant_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Constant_Kind_descriptor();
inline const ::std::string& Constant_Kind_Name(Constant_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Constant_Kind_descriptor(), value);
}
inline bool Constant_Kind_Parse(
    const ::std::string& name, Constant_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Constant_Kind>(
    Constant_Kind_descriptor(), name, value);
}
enum Type_Kind {
  Type_Kind_PRIMITIVE = 0,
  Type_Kind_UNARY = 1
};
bool Type_Kind_IsValid(int value);
const Type_Kind Type_Kind_Kind_MIN = Type_Kind_PRIMITIVE;
const Type_Kind Type_Kind_Kind_MAX = Type_Kind_UNARY;
const int Type_Kind_Kind_ARRAYSIZE = Type_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_Kind_descriptor();
inline const ::std::string& Type_Kind_Name(Type_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_Kind_descriptor(), value);
}
inline bool Type_Kind_Parse(
    const ::std::string& name, Type_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type_Kind>(
    Type_Kind_descriptor(), name, value);
}
enum PrimitiveType_Kind {
  PrimitiveType_Kind_BOOL = 0,
  PrimitiveType_Kind_COLOR = 1,
  PrimitiveType_Kind_SHAPE = 2,
  PrimitiveType_Kind_IMAGE = 3,
  PrimitiveType_Kind_BLOB = 4,
  PrimitiveType_Kind_DATETIME = 5,
  PrimitiveType_Kind_INT = 6,
  PrimitiveType_Kind_UINT = 7,
  PrimitiveType_Kind_FLOAT = 8,
  PrimitiveType_Kind_STRING = 9,
  PrimitiveType_Kind_DECIMAL = 10
};
bool PrimitiveType_Kind_IsValid(int value);
const PrimitiveType_Kind PrimitiveType_Kind_Kind_MIN = PrimitiveType_Kind_BOOL;
const PrimitiveType_Kind PrimitiveType_Kind_Kind_MAX = PrimitiveType_Kind_DECIMAL;
const int PrimitiveType_Kind_Kind_ARRAYSIZE = PrimitiveType_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* PrimitiveType_Kind_descriptor();
inline const ::std::string& PrimitiveType_Kind_Name(PrimitiveType_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    PrimitiveType_Kind_descriptor(), value);
}
inline bool PrimitiveType_Kind_Parse(
    const ::std::string& name, PrimitiveType_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrimitiveType_Kind>(
    PrimitiveType_Kind_descriptor(), name, value);
}
enum Severity {
  SEV_ERROR = 0,
  SEV_WARNING = 1,
  SEV_NONE = 2
};
bool Severity_IsValid(int value);
const Severity Severity_MIN = SEV_ERROR;
const Severity Severity_MAX = SEV_NONE;
const int Severity_ARRAYSIZE = Severity_MAX + 1;

const ::google::protobuf::EnumDescriptor* Severity_descriptor();
inline const ::std::string& Severity_Name(Severity value) {
  return ::google::protobuf::internal::NameOfEnum(
    Severity_descriptor(), value);
}
inline bool Severity_Parse(
    const ::std::string& name, Severity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Severity>(
    Severity_descriptor(), name, value);
}
enum Lifetime {
  TRANSACTION = 1,
  DATABASE = 2,
  SESSION = 3
};
bool Lifetime_IsValid(int value);
const Lifetime Lifetime_MIN = TRANSACTION;
const Lifetime Lifetime_MAX = SESSION;
const int Lifetime_ARRAYSIZE = Lifetime_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lifetime_descriptor();
inline const ::std::string& Lifetime_Name(Lifetime value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lifetime_descriptor(), value);
}
inline bool Lifetime_Parse(
    const ::std::string& name, Lifetime* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lifetime>(
    Lifetime_descriptor(), name, value);
}
enum DerivationType {
  NOT_DERIVED = 0,
  EXTENSIONAL = 1,
  DERIVED = 2,
  DERIVED_AND_STORED = 3,
  INTEGRITY_CONSTRAINT = 4
};
bool DerivationType_IsValid(int value);
const DerivationType DerivationType_MIN = NOT_DERIVED;
const DerivationType DerivationType_MAX = INTEGRITY_CONSTRAINT;
const int DerivationType_ARRAYSIZE = DerivationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DerivationType_descriptor();
inline const ::std::string& DerivationType_Name(DerivationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DerivationType_descriptor(), value);
}
inline bool DerivationType_Parse(
    const ::std::string& name, DerivationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DerivationType>(
    DerivationType_descriptor(), name, value);
}
enum LockingPolicy {
  BY_PREDICATE = 0,
  BY_ELEMENT = 1,
  UNLOCKED = 2
};
bool LockingPolicy_IsValid(int value);
const LockingPolicy LockingPolicy_MIN = BY_PREDICATE;
const LockingPolicy LockingPolicy_MAX = UNLOCKED;
const int LockingPolicy_ARRAYSIZE = LockingPolicy_MAX + 1;

const ::google::protobuf::EnumDescriptor* LockingPolicy_descriptor();
inline const ::std::string& LockingPolicy_Name(LockingPolicy value) {
  return ::google::protobuf::internal::NameOfEnum(
    LockingPolicy_descriptor(), value);
}
inline bool LockingPolicy_Parse(
    const ::std::string& name, LockingPolicy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LockingPolicy>(
    LockingPolicy_descriptor(), name, value);
}
enum StorageModel {
  SPARSE = 0,
  DENSE = 1,
  DELTA_SPARSE = 2,
  CHUNKED = 3,
  DELIMITED_FILE = 4,
  BINARY_FILE = 5,
  RAW_FILE = 6,
  SCALABLE_SPARSE = 7,
  TCP_STREAM = 8
};
bool StorageModel_IsValid(int value);
const StorageModel StorageModel_MIN = SPARSE;
const StorageModel StorageModel_MAX = TCP_STREAM;
const int StorageModel_ARRAYSIZE = StorageModel_MAX + 1;

const ::google::protobuf::EnumDescriptor* StorageModel_descriptor();
inline const ::std::string& StorageModel_Name(StorageModel value) {
  return ::google::protobuf::internal::NameOfEnum(
    StorageModel_descriptor(), value);
}
inline bool StorageModel_Parse(
    const ::std::string& name, StorageModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StorageModel>(
    StorageModel_descriptor(), name, value);
}
enum Partitioning {
  PARTITIONED = 0,
  REPLICATED = 1,
  MASTER_ONLY = 2,
  FRAGMENT = 3
};
bool Partitioning_IsValid(int value);
const Partitioning Partitioning_MIN = PARTITIONED;
const Partitioning Partitioning_MAX = FRAGMENT;
const int Partitioning_ARRAYSIZE = Partitioning_MAX + 1;

const ::google::protobuf::EnumDescriptor* Partitioning_descriptor();
inline const ::std::string& Partitioning_Name(Partitioning value) {
  return ::google::protobuf::internal::NameOfEnum(
    Partitioning_descriptor(), value);
}
inline bool Partitioning_Parse(
    const ::std::string& name, Partitioning* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Partitioning>(
    Partitioning_descriptor(), name, value);
}
enum LogicSort {
  ACTIVE = 1,
  INACTIVE = 2,
  EXECUTE = 3,
  INACTIVE_AFTER_FIXPOINT = 4,
  EXECUTE_AFTER_FIXPOINT = 5
};
bool LogicSort_IsValid(int value);
const LogicSort LogicSort_MIN = ACTIVE;
const LogicSort LogicSort_MAX = EXECUTE_AFTER_FIXPOINT;
const int LogicSort_ARRAYSIZE = LogicSort_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogicSort_descriptor();
inline const ::std::string& LogicSort_Name(LogicSort value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogicSort_descriptor(), value);
}
inline bool LogicSort_Parse(
    const ::std::string& name, LogicSort* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogicSort>(
    LogicSort_descriptor(), name, value);
}
// ===================================================================

class CompilationProblems : public ::google::protobuf::Message {
 public:
  CompilationProblems();
  virtual ~CompilationProblems();
  
  CompilationProblems(const CompilationProblems& from);
  
  inline CompilationProblems& operator=(const CompilationProblems& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CompilationProblems& default_instance();
  
  void Swap(CompilationProblems* other);
  
  // implements Message ----------------------------------------------
  
  CompilationProblems* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompilationProblems& from);
  void MergeFrom(const CompilationProblems& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .blox.common.protocol.Problem error = 1;
  inline int error_size() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::blox::common::protocol::Problem& error(int index) const;
  inline ::blox::common::protocol::Problem* mutable_error(int index);
  inline ::blox::common::protocol::Problem* add_error();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >&
      error() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >*
      mutable_error();
  
  // repeated .blox.common.protocol.Problem warning = 2;
  inline int warning_size() const;
  inline void clear_warning();
  static const int kWarningFieldNumber = 2;
  inline const ::blox::common::protocol::Problem& warning(int index) const;
  inline ::blox::common::protocol::Problem* mutable_warning(int index);
  inline ::blox::common::protocol::Problem* add_warning();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >&
      warning() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >*
      mutable_warning();
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.CompilationProblems)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem > error_;
  ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem > warning_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static CompilationProblems* default_instance_;
};
// -------------------------------------------------------------------

class Problem : public ::google::protobuf::Message {
 public:
  Problem();
  virtual ~Problem();
  
  Problem(const Problem& from);
  
  inline Problem& operator=(const Problem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Problem& default_instance();
  
  void Swap(Problem* other);
  
  // implements Message ----------------------------------------------
  
  Problem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Problem& from);
  void MergeFrom(const Problem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  
  // required string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // required .blox.common.protocol.Position position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  
  // required .blox.common.protocol.Severity severity_code = 5;
  inline bool has_severity_code() const;
  inline void clear_severity_code();
  static const int kSeverityCodeFieldNumber = 5;
  inline blox::common::protocol::Severity severity_code() const;
  inline void set_severity_code(blox::common::protocol::Severity value);
  
  // optional string quote = 7;
  inline bool has_quote() const;
  inline void clear_quote();
  static const int kQuoteFieldNumber = 7;
  inline const ::std::string& quote() const;
  inline void set_quote(const ::std::string& value);
  inline void set_quote(const char* value);
  inline void set_quote(const char* value, size_t size);
  inline ::std::string* mutable_quote();
  inline ::std::string* release_quote();
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.Problem)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_severity_code();
  inline void clear_has_severity_code();
  inline void set_has_quote();
  inline void clear_has_quote();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* code_;
  ::std::string* msg_;
  ::blox::common::protocol::Position* position_;
  ::std::string* quote_;
  int severity_code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static Problem* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();
  
  Position(const Position& from);
  
  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();
  
  void Swap(Position* other);
  
  // implements Message ----------------------------------------------
  
  Position* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 start_line = 1;
  inline bool has_start_line() const;
  inline void clear_start_line();
  static const int kStartLineFieldNumber = 1;
  inline ::google::protobuf::uint32 start_line() const;
  inline void set_start_line(::google::protobuf::uint32 value);
  
  // required uint32 start_column = 2;
  inline bool has_start_column() const;
  inline void clear_start_column();
  static const int kStartColumnFieldNumber = 2;
  inline ::google::protobuf::uint32 start_column() const;
  inline void set_start_column(::google::protobuf::uint32 value);
  
  // optional uint32 end_line = 3;
  inline bool has_end_line() const;
  inline void clear_end_line();
  static const int kEndLineFieldNumber = 3;
  inline ::google::protobuf::uint32 end_line() const;
  inline void set_end_line(::google::protobuf::uint32 value);
  
  // optional uint32 end_column = 4;
  inline bool has_end_column() const;
  inline void clear_end_column();
  static const int kEndColumnFieldNumber = 4;
  inline ::google::protobuf::uint32 end_column() const;
  inline void set_end_column(::google::protobuf::uint32 value);
  
  // optional uint32 start_offset = 5;
  inline bool has_start_offset() const;
  inline void clear_start_offset();
  static const int kStartOffsetFieldNumber = 5;
  inline ::google::protobuf::uint32 start_offset() const;
  inline void set_start_offset(::google::protobuf::uint32 value);
  
  // optional uint32 end_offset = 6;
  inline bool has_end_offset() const;
  inline void clear_end_offset();
  static const int kEndOffsetFieldNumber = 6;
  inline ::google::protobuf::uint32 end_offset() const;
  inline void set_end_offset(::google::protobuf::uint32 value);
  
  // required string block_name = 7;
  inline bool has_block_name() const;
  inline void clear_block_name();
  static const int kBlockNameFieldNumber = 7;
  inline const ::std::string& block_name() const;
  inline void set_block_name(const ::std::string& value);
  inline void set_block_name(const char* value);
  inline void set_block_name(const char* value, size_t size);
  inline ::std::string* mutable_block_name();
  inline ::std::string* release_block_name();
  
  // optional string file_name = 8;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 8;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.Position)
 private:
  inline void set_has_start_line();
  inline void clear_has_start_line();
  inline void set_has_start_column();
  inline void clear_has_start_column();
  inline void set_has_end_line();
  inline void clear_has_end_line();
  inline void set_has_end_column();
  inline void clear_has_end_column();
  inline void set_has_start_offset();
  inline void clear_has_start_offset();
  inline void set_has_end_offset();
  inline void clear_has_end_offset();
  inline void set_has_block_name();
  inline void clear_has_block_name();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 start_line_;
  ::google::protobuf::uint32 start_column_;
  ::google::protobuf::uint32 end_line_;
  ::google::protobuf::uint32 end_column_;
  ::google::protobuf::uint32 start_offset_;
  ::google::protobuf::uint32 end_offset_;
  ::std::string* block_name_;
  ::std::string* file_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class PredicateInfo : public ::google::protobuf::Message {
 public:
  PredicateInfo();
  virtual ~PredicateInfo();
  
  PredicateInfo(const PredicateInfo& from);
  
  inline PredicateInfo& operator=(const PredicateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PredicateInfo& default_instance();
  
  void Swap(PredicateInfo* other);
  
  // implements Message ----------------------------------------------
  
  PredicateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PredicateInfo& from);
  void MergeFrom(const PredicateInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string qualified_name = 2;
  inline bool has_qualified_name() const;
  inline void clear_qualified_name();
  static const int kQualifiedNameFieldNumber = 2;
  inline const ::std::string& qualified_name() const;
  inline void set_qualified_name(const ::std::string& value);
  inline void set_qualified_name(const char* value);
  inline void set_qualified_name(const char* value, size_t size);
  inline ::std::string* mutable_qualified_name();
  inline ::std::string* release_qualified_name();
  
  // required uint32 arity = 3;
  inline bool has_arity() const;
  inline void clear_arity();
  static const int kArityFieldNumber = 3;
  inline ::google::protobuf::uint32 arity() const;
  inline void set_arity(::google::protobuf::uint32 value);
  
  // required uint32 key_arity = 4;
  inline bool has_key_arity() const;
  inline void clear_key_arity();
  static const int kKeyArityFieldNumber = 4;
  inline ::google::protobuf::uint32 key_arity() const;
  inline void set_key_arity(::google::protobuf::uint32 value);
  
  // required uint32 value_arity = 5;
  inline bool has_value_arity() const;
  inline void clear_value_arity();
  static const int kValueArityFieldNumber = 5;
  inline ::google::protobuf::uint32 value_arity() const;
  inline void set_value_arity(::google::protobuf::uint32 value);
  
  // repeated string key_argument = 6;
  inline int key_argument_size() const;
  inline void clear_key_argument();
  static const int kKeyArgumentFieldNumber = 6;
  inline const ::std::string& key_argument(int index) const;
  inline ::std::string* mutable_key_argument(int index);
  inline void set_key_argument(int index, const ::std::string& value);
  inline void set_key_argument(int index, const char* value);
  inline void set_key_argument(int index, const char* value, size_t size);
  inline ::std::string* add_key_argument();
  inline void add_key_argument(const ::std::string& value);
  inline void add_key_argument(const char* value);
  inline void add_key_argument(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& key_argument() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key_argument();
  
  // repeated string value_argument = 7;
  inline int value_argument_size() const;
  inline void clear_value_argument();
  static const int kValueArgumentFieldNumber = 7;
  inline const ::std::string& value_argument(int index) const;
  inline ::std::string* mutable_value_argument(int index);
  inline void set_value_argument(int index, const ::std::string& value);
  inline void set_value_argument(int index, const char* value);
  inline void set_value_argument(int index, const char* value, size_t size);
  inline ::std::string* add_value_argument();
  inline void add_value_argument(const ::std::string& value);
  inline void add_value_argument(const char* value);
  inline void add_value_argument(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& value_argument() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value_argument();
  
  // required bool is_entity = 8 [default = false];
  inline bool has_is_entity() const;
  inline void clear_is_entity();
  static const int kIsEntityFieldNumber = 8;
  inline bool is_entity() const;
  inline void set_is_entity(bool value);
  
  // required bool is_ref_mode = 9 [default = false];
  inline bool has_is_ref_mode() const;
  inline void clear_is_ref_mode();
  static const int kIsRefModeFieldNumber = 9;
  inline bool is_ref_mode() const;
  inline void set_is_ref_mode(bool value);
  
  // required bool is_one_to_one = 10 [default = false];
  inline bool has_is_one_to_one() const;
  inline void clear_is_one_to_one();
  static const int kIsOneToOneFieldNumber = 10;
  inline bool is_one_to_one() const;
  inline void set_is_one_to_one(bool value);
  
  // required bool is_ordered = 11 [default = false];
  inline bool has_is_ordered() const;
  inline void clear_is_ordered();
  static const int kIsOrderedFieldNumber = 11;
  inline bool is_ordered() const;
  inline void set_is_ordered(bool value);
  
  // required bool has_default_value = 12 [default = false];
  inline bool has_has_default_value() const;
  inline void clear_has_default_value();
  static const int kHasDefaultValueFieldNumber = 12;
  inline bool has_default_value() const;
  inline void set_has_default_value(bool value);
  
  // required bool is_disjoint = 13 [default = false];
  inline bool has_is_disjoint() const;
  inline void clear_is_disjoint();
  static const int kIsDisjointFieldNumber = 13;
  inline bool is_disjoint() const;
  inline void set_is_disjoint(bool value);
  
  // required bool is_subtype = 14 [default = false];
  inline bool has_is_subtype() const;
  inline void clear_is_subtype();
  static const int kIsSubtypeFieldNumber = 14;
  inline bool is_subtype() const;
  inline void set_is_subtype(bool value);
  
  // optional string supertype = 15;
  inline bool has_supertype() const;
  inline void clear_supertype();
  static const int kSupertypeFieldNumber = 15;
  inline const ::std::string& supertype() const;
  inline void set_supertype(const ::std::string& value);
  inline void set_supertype(const char* value);
  inline void set_supertype(const char* value, size_t size);
  inline ::std::string* mutable_supertype();
  inline ::std::string* release_supertype();
  
  // optional string toptype = 42;
  inline bool has_toptype() const;
  inline void clear_toptype();
  static const int kToptypeFieldNumber = 42;
  inline const ::std::string& toptype() const;
  inline void set_toptype(const ::std::string& value);
  inline void set_toptype(const char* value);
  inline void set_toptype(const char* value, size_t size);
  inline ::std::string* mutable_toptype();
  inline ::std::string* release_toptype();
  
  // required bool has_ref_mode = 16 [default = false];
  inline bool has_has_ref_mode() const;
  inline void clear_has_ref_mode();
  static const int kHasRefModeFieldNumber = 16;
  inline bool has_ref_mode() const;
  inline void set_has_ref_mode(bool value);
  
  // optional string ref_mode_name = 17;
  inline bool has_ref_mode_name() const;
  inline void clear_ref_mode_name();
  static const int kRefModeNameFieldNumber = 17;
  inline const ::std::string& ref_mode_name() const;
  inline void set_ref_mode_name(const ::std::string& value);
  inline void set_ref_mode_name(const char* value);
  inline void set_ref_mode_name(const char* value, size_t size);
  inline ::std::string* mutable_ref_mode_name();
  inline ::std::string* release_ref_mode_name();
  
  // required bool is_meta_predicate = 18 [default = false];
  inline bool has_is_meta_predicate() const;
  inline void clear_is_meta_predicate();
  static const int kIsMetaPredicateFieldNumber = 18;
  inline bool is_meta_predicate() const;
  inline void set_is_meta_predicate(bool value);
  
  // required bool is_pulse_predicate = 19 [default = false];
  inline bool has_is_pulse_predicate() const;
  inline void clear_is_pulse_predicate();
  static const int kIsPulsePredicateFieldNumber = 19;
  inline bool is_pulse_predicate() const;
  inline void set_is_pulse_predicate(bool value);
  
  // required bool is_calculated = 20 [default = false];
  inline bool has_is_calculated() const;
  inline void clear_is_calculated();
  static const int kIsCalculatedFieldNumber = 20;
  inline bool is_calculated() const;
  inline void set_is_calculated(bool value);
  
  // required bool line_numbers = 21 [default = false];
  inline bool has_line_numbers() const;
  inline void clear_line_numbers();
  static const int kLineNumbersFieldNumber = 21;
  inline bool line_numbers() const;
  inline void set_line_numbers(bool value);
  
  // required .blox.common.protocol.DerivationType derivation_type = 22;
  inline bool has_derivation_type() const;
  inline void clear_derivation_type();
  static const int kDerivationTypeFieldNumber = 22;
  inline blox::common::protocol::DerivationType derivation_type() const;
  inline void set_derivation_type(blox::common::protocol::DerivationType value);
  
  // required .blox.common.protocol.LockingPolicy locking_policy = 23;
  inline bool has_locking_policy() const;
  inline void clear_locking_policy();
  static const int kLockingPolicyFieldNumber = 23;
  inline blox::common::protocol::LockingPolicy locking_policy() const;
  inline void set_locking_policy(blox::common::protocol::LockingPolicy value);
  
  // required .blox.common.protocol.StorageModel storage_model = 24;
  inline bool has_storage_model() const;
  inline void clear_storage_model();
  static const int kStorageModelFieldNumber = 24;
  inline blox::common::protocol::StorageModel storage_model() const;
  inline void set_storage_model(blox::common::protocol::StorageModel value);
  
  // required .blox.common.protocol.Partitioning partitioning = 25;
  inline bool has_partitioning() const;
  inline void clear_partitioning();
  static const int kPartitioningFieldNumber = 25;
  inline blox::common::protocol::Partitioning partitioning() const;
  inline void set_partitioning(blox::common::protocol::Partitioning value);
  
  // optional uint64 capacity = 26 [default = 32767];
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 26;
  inline ::google::protobuf::uint64 capacity() const;
  inline void set_capacity(::google::protobuf::uint64 value);
  
  // optional string role_names = 27;
  inline bool has_role_names() const;
  inline void clear_role_names();
  static const int kRoleNamesFieldNumber = 27;
  inline const ::std::string& role_names() const;
  inline void set_role_names(const ::std::string& value);
  inline void set_role_names(const char* value);
  inline void set_role_names(const char* value, size_t size);
  inline ::std::string* mutable_role_names();
  inline ::std::string* release_role_names();
  
  // optional bool is_built_in = 28 [default = false];
  inline bool has_is_built_in() const;
  inline void clear_is_built_in();
  static const int kIsBuiltInFieldNumber = 28;
  inline bool is_built_in() const;
  inline void set_is_built_in(bool value);
  
  // required bool is_skolem = 29 [default = false];
  inline bool has_is_skolem() const;
  inline void clear_is_skolem();
  static const int kIsSkolemFieldNumber = 29;
  inline bool is_skolem() const;
  inline void set_is_skolem(bool value);
  
  // required .blox.common.protocol.Lifetime lifetime = 30;
  inline bool has_lifetime() const;
  inline void clear_lifetime();
  static const int kLifetimeFieldNumber = 30;
  inline blox::common::protocol::Lifetime lifetime() const;
  inline void set_lifetime(blox::common::protocol::Lifetime value);
  
  // required bool is_auto_numbered = 31;
  inline bool has_is_auto_numbered() const;
  inline void clear_is_auto_numbered();
  static const int kIsAutoNumberedFieldNumber = 31;
  inline bool is_auto_numbered() const;
  inline void set_is_auto_numbered(bool value);
  
  // optional .blox.common.protocol.Constant actual_default_value = 32;
  inline bool has_actual_default_value() const;
  inline void clear_actual_default_value();
  static const int kActualDefaultValueFieldNumber = 32;
  inline const ::blox::common::protocol::Constant& actual_default_value() const;
  inline ::blox::common::protocol::Constant* mutable_actual_default_value();
  inline ::blox::common::protocol::Constant* release_actual_default_value();
  
  // optional string file_path = 33;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 33;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  inline ::std::string* release_file_path();
  
  // optional string delimiter = 34;
  inline bool has_delimiter() const;
  inline void clear_delimiter();
  static const int kDelimiterFieldNumber = 34;
  inline const ::std::string& delimiter() const;
  inline void set_delimiter(const ::std::string& value);
  inline void set_delimiter(const char* value);
  inline void set_delimiter(const char* value, size_t size);
  inline ::std::string* mutable_delimiter();
  inline ::std::string* release_delimiter();
  
  // optional bool has_column_names = 35;
  inline bool has_has_column_names() const;
  inline void clear_has_column_names();
  static const int kHasColumnNamesFieldNumber = 35;
  inline bool has_column_names() const;
  inline void set_has_column_names(bool value);
  
  // optional string delim_column_names = 36;
  inline bool has_delim_column_names() const;
  inline void clear_delim_column_names();
  static const int kDelimColumnNamesFieldNumber = 36;
  inline const ::std::string& delim_column_names() const;
  inline void set_delim_column_names(const ::std::string& value);
  inline void set_delim_column_names(const char* value);
  inline void set_delim_column_names(const char* value, size_t size);
  inline ::std::string* mutable_delim_column_names();
  inline ::std::string* release_delim_column_names();
  
  // optional bool is_sealed = 37 [default = false];
  inline bool has_is_sealed() const;
  inline void clear_is_sealed();
  static const int kIsSealedFieldNumber = 37;
  inline bool is_sealed() const;
  inline void set_is_sealed(bool value);
  
  // optional string local_name = 38;
  inline bool has_local_name() const;
  inline void clear_local_name();
  static const int kLocalNameFieldNumber = 38;
  inline const ::std::string& local_name() const;
  inline void set_local_name(const ::std::string& value);
  inline void set_local_name(const char* value);
  inline void set_local_name(const char* value, size_t size);
  inline ::std::string* mutable_local_name();
  inline ::std::string* release_local_name();
  
  // optional string display_name = 39;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 39;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const char* value, size_t size);
  inline ::std::string* mutable_display_name();
  inline ::std::string* release_display_name();
  
  // optional string remote_ref = 40;
  inline bool has_remote_ref() const;
  inline void clear_remote_ref();
  static const int kRemoteRefFieldNumber = 40;
  inline const ::std::string& remote_ref() const;
  inline void set_remote_ref(const ::std::string& value);
  inline void set_remote_ref(const char* value);
  inline void set_remote_ref(const char* value, size_t size);
  inline ::std::string* mutable_remote_ref();
  inline ::std::string* release_remote_ref();
  
  // optional bool is_synthetic = 41;
  inline bool has_is_synthetic() const;
  inline void clear_is_synthetic();
  static const int kIsSyntheticFieldNumber = 41;
  inline bool is_synthetic() const;
  inline void set_is_synthetic(bool value);
  
  // optional bool is_constructor = 43;
  inline bool has_is_constructor() const;
  inline void clear_is_constructor();
  static const int kIsConstructorFieldNumber = 43;
  inline bool is_constructor() const;
  inline void set_is_constructor(bool value);
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.PredicateInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_qualified_name();
  inline void clear_has_qualified_name();
  inline void set_has_arity();
  inline void clear_has_arity();
  inline void set_has_key_arity();
  inline void clear_has_key_arity();
  inline void set_has_value_arity();
  inline void clear_has_value_arity();
  inline void set_has_is_entity();
  inline void clear_has_is_entity();
  inline void set_has_is_ref_mode();
  inline void clear_has_is_ref_mode();
  inline void set_has_is_one_to_one();
  inline void clear_has_is_one_to_one();
  inline void set_has_is_ordered();
  inline void clear_has_is_ordered();
  inline void set_has_has_default_value();
  inline void clear_has_has_default_value();
  inline void set_has_is_disjoint();
  inline void clear_has_is_disjoint();
  inline void set_has_is_subtype();
  inline void clear_has_is_subtype();
  inline void set_has_supertype();
  inline void clear_has_supertype();
  inline void set_has_toptype();
  inline void clear_has_toptype();
  inline void set_has_has_ref_mode();
  inline void clear_has_has_ref_mode();
  inline void set_has_ref_mode_name();
  inline void clear_has_ref_mode_name();
  inline void set_has_is_meta_predicate();
  inline void clear_has_is_meta_predicate();
  inline void set_has_is_pulse_predicate();
  inline void clear_has_is_pulse_predicate();
  inline void set_has_is_calculated();
  inline void clear_has_is_calculated();
  inline void set_has_line_numbers();
  inline void clear_has_line_numbers();
  inline void set_has_derivation_type();
  inline void clear_has_derivation_type();
  inline void set_has_locking_policy();
  inline void clear_has_locking_policy();
  inline void set_has_storage_model();
  inline void clear_has_storage_model();
  inline void set_has_partitioning();
  inline void clear_has_partitioning();
  inline void set_has_capacity();
  inline void clear_has_capacity();
  inline void set_has_role_names();
  inline void clear_has_role_names();
  inline void set_has_is_built_in();
  inline void clear_has_is_built_in();
  inline void set_has_is_skolem();
  inline void clear_has_is_skolem();
  inline void set_has_lifetime();
  inline void clear_has_lifetime();
  inline void set_has_is_auto_numbered();
  inline void clear_has_is_auto_numbered();
  inline void set_has_actual_default_value();
  inline void clear_has_actual_default_value();
  inline void set_has_file_path();
  inline void clear_has_file_path();
  inline void set_has_delimiter();
  inline void clear_has_delimiter();
  inline void set_has_has_column_names();
  inline void clear_has_has_column_names();
  inline void set_has_delim_column_names();
  inline void clear_has_delim_column_names();
  inline void set_has_is_sealed();
  inline void clear_has_is_sealed();
  inline void set_has_local_name();
  inline void clear_has_local_name();
  inline void set_has_display_name();
  inline void clear_has_display_name();
  inline void set_has_remote_ref();
  inline void clear_has_remote_ref();
  inline void set_has_is_synthetic();
  inline void clear_has_is_synthetic();
  inline void set_has_is_constructor();
  inline void clear_has_is_constructor();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* qualified_name_;
  ::google::protobuf::uint32 arity_;
  ::google::protobuf::uint32 key_arity_;
  ::google::protobuf::RepeatedPtrField< ::std::string> key_argument_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_argument_;
  ::google::protobuf::uint32 value_arity_;
  bool is_entity_;
  bool is_ref_mode_;
  bool is_one_to_one_;
  bool is_ordered_;
  ::std::string* supertype_;
  ::std::string* toptype_;
  bool has_default_value_;
  bool is_disjoint_;
  bool is_subtype_;
  bool has_ref_mode_;
  bool is_meta_predicate_;
  bool is_pulse_predicate_;
  bool is_calculated_;
  bool line_numbers_;
  ::std::string* ref_mode_name_;
  int derivation_type_;
  int locking_policy_;
  int storage_model_;
  int partitioning_;
  ::google::protobuf::uint64 capacity_;
  ::std::string* role_names_;
  int lifetime_;
  bool is_built_in_;
  bool is_skolem_;
  bool is_auto_numbered_;
  bool has_column_names_;
  ::blox::common::protocol::Constant* actual_default_value_;
  ::std::string* file_path_;
  ::std::string* delimiter_;
  ::std::string* delim_column_names_;
  ::std::string* local_name_;
  ::std::string* display_name_;
  ::std::string* remote_ref_;
  bool is_sealed_;
  bool is_synthetic_;
  bool is_constructor_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(43 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static PredicateInfo* default_instance_;
};
// -------------------------------------------------------------------

class Constant : public ::google::protobuf::Message {
 public:
  Constant();
  virtual ~Constant();
  
  Constant(const Constant& from);
  
  inline Constant& operator=(const Constant& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Constant& default_instance();
  
  void Swap(Constant* other);
  
  // implements Message ----------------------------------------------
  
  Constant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Constant& from);
  void MergeFrom(const Constant& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Constant_Kind Kind;
  static const Kind BOOL = Constant_Kind_BOOL;
  static const Kind INT = Constant_Kind_INT;
  static const Kind FLOAT = Constant_Kind_FLOAT;
  static const Kind STRING = Constant_Kind_STRING;
  static const Kind DATETIME = Constant_Kind_DATETIME;
  static const Kind UINT = Constant_Kind_UINT;
  static inline bool Kind_IsValid(int value) {
    return Constant_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    Constant_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    Constant_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    Constant_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return Constant_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return Constant_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return Constant_Kind_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .blox.common.protocol.Constant.Kind kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::blox::common::protocol::Constant_Kind kind() const;
  inline void set_kind(::blox::common::protocol::Constant_Kind value);
  
  // optional .blox.common.protocol.BoolConstant bool_constant = 2;
  inline bool has_bool_constant() const;
  inline void clear_bool_constant();
  static const int kBoolConstantFieldNumber = 2;
  inline const ::blox::common::protocol::BoolConstant& bool_constant() const;
  inline ::blox::common::protocol::BoolConstant* mutable_bool_constant();
  inline ::blox::common::protocol::BoolConstant* release_bool_constant();
  
  // optional .blox.common.protocol.IntConstant int_constant = 3;
  inline bool has_int_constant() const;
  inline void clear_int_constant();
  static const int kIntConstantFieldNumber = 3;
  inline const ::blox::common::protocol::IntConstant& int_constant() const;
  inline ::blox::common::protocol::IntConstant* mutable_int_constant();
  inline ::blox::common::protocol::IntConstant* release_int_constant();
  
  // optional .blox.common.protocol.FloatConstant float_constant = 4;
  inline bool has_float_constant() const;
  inline void clear_float_constant();
  static const int kFloatConstantFieldNumber = 4;
  inline const ::blox::common::protocol::FloatConstant& float_constant() const;
  inline ::blox::common::protocol::FloatConstant* mutable_float_constant();
  inline ::blox::common::protocol::FloatConstant* release_float_constant();
  
  // optional .blox.common.protocol.StringConstant string_constant = 5;
  inline bool has_string_constant() const;
  inline void clear_string_constant();
  static const int kStringConstantFieldNumber = 5;
  inline const ::blox::common::protocol::StringConstant& string_constant() const;
  inline ::blox::common::protocol::StringConstant* mutable_string_constant();
  inline ::blox::common::protocol::StringConstant* release_string_constant();
  
  // optional .blox.common.protocol.DateTimeConstant date_time_constant = 6;
  inline bool has_date_time_constant() const;
  inline void clear_date_time_constant();
  static const int kDateTimeConstantFieldNumber = 6;
  inline const ::blox::common::protocol::DateTimeConstant& date_time_constant() const;
  inline ::blox::common::protocol::DateTimeConstant* mutable_date_time_constant();
  inline ::blox::common::protocol::DateTimeConstant* release_date_time_constant();
  
  // optional .blox.common.protocol.UnsignedIntConstant uint_constant = 7;
  inline bool has_uint_constant() const;
  inline void clear_uint_constant();
  static const int kUintConstantFieldNumber = 7;
  inline const ::blox::common::protocol::UnsignedIntConstant& uint_constant() const;
  inline ::blox::common::protocol::UnsignedIntConstant* mutable_uint_constant();
  inline ::blox::common::protocol::UnsignedIntConstant* release_uint_constant();
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.Constant)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_bool_constant();
  inline void clear_has_bool_constant();
  inline void set_has_int_constant();
  inline void clear_has_int_constant();
  inline void set_has_float_constant();
  inline void clear_has_float_constant();
  inline void set_has_string_constant();
  inline void clear_has_string_constant();
  inline void set_has_date_time_constant();
  inline void clear_has_date_time_constant();
  inline void set_has_uint_constant();
  inline void clear_has_uint_constant();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::common::protocol::BoolConstant* bool_constant_;
  ::blox::common::protocol::IntConstant* int_constant_;
  ::blox::common::protocol::FloatConstant* float_constant_;
  ::blox::common::protocol::StringConstant* string_constant_;
  ::blox::common::protocol::DateTimeConstant* date_time_constant_;
  ::blox::common::protocol::UnsignedIntConstant* uint_constant_;
  int kind_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static Constant* default_instance_;
};
// -------------------------------------------------------------------

class BoolConstant : public ::google::protobuf::Message {
 public:
  BoolConstant();
  virtual ~BoolConstant();
  
  BoolConstant(const BoolConstant& from);
  
  inline BoolConstant& operator=(const BoolConstant& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoolConstant& default_instance();
  
  void Swap(BoolConstant* other);
  
  // implements Message ----------------------------------------------
  
  BoolConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoolConstant& from);
  void MergeFrom(const BoolConstant& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline bool value() const;
  inline void set_value(bool value);
  
  // optional .blox.common.protocol.Position position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.BoolConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_position();
  inline void clear_has_position();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::common::protocol::Position* position_;
  bool value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static BoolConstant* default_instance_;
};
// -------------------------------------------------------------------

class IntConstant : public ::google::protobuf::Message {
 public:
  IntConstant();
  virtual ~IntConstant();
  
  IntConstant(const IntConstant& from);
  
  inline IntConstant& operator=(const IntConstant& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IntConstant& default_instance();
  
  void Swap(IntConstant* other);
  
  // implements Message ----------------------------------------------
  
  IntConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntConstant& from);
  void MergeFrom(const IntConstant& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);
  
  // required .blox.common.protocol.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::blox::common::protocol::Type& type() const;
  inline ::blox::common::protocol::Type* mutable_type();
  inline ::blox::common::protocol::Type* release_type();
  
  // optional .blox.common.protocol.Position position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.IntConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 value_;
  ::blox::common::protocol::Type* type_;
  ::blox::common::protocol::Position* position_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static IntConstant* default_instance_;
};
// -------------------------------------------------------------------

class UnsignedIntConstant : public ::google::protobuf::Message {
 public:
  UnsignedIntConstant();
  virtual ~UnsignedIntConstant();
  
  UnsignedIntConstant(const UnsignedIntConstant& from);
  
  inline UnsignedIntConstant& operator=(const UnsignedIntConstant& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnsignedIntConstant& default_instance();
  
  void Swap(UnsignedIntConstant* other);
  
  // implements Message ----------------------------------------------
  
  UnsignedIntConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnsignedIntConstant& from);
  void MergeFrom(const UnsignedIntConstant& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint64 value() const;
  inline void set_value(::google::protobuf::uint64 value);
  
  // required .blox.common.protocol.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::blox::common::protocol::Type& type() const;
  inline ::blox::common::protocol::Type* mutable_type();
  inline ::blox::common::protocol::Type* release_type();
  
  // optional .blox.common.protocol.Position position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.UnsignedIntConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 value_;
  ::blox::common::protocol::Type* type_;
  ::blox::common::protocol::Position* position_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static UnsignedIntConstant* default_instance_;
};
// -------------------------------------------------------------------

class FloatConstant : public ::google::protobuf::Message {
 public:
  FloatConstant();
  virtual ~FloatConstant();
  
  FloatConstant(const FloatConstant& from);
  
  inline FloatConstant& operator=(const FloatConstant& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatConstant& default_instance();
  
  void Swap(FloatConstant* other);
  
  // implements Message ----------------------------------------------
  
  FloatConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloatConstant& from);
  void MergeFrom(const FloatConstant& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // required .blox.common.protocol.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::blox::common::protocol::Type& type() const;
  inline ::blox::common::protocol::Type* mutable_type();
  inline ::blox::common::protocol::Type* release_type();
  
  // optional .blox.common.protocol.Position position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.FloatConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  ::blox::common::protocol::Type* type_;
  ::blox::common::protocol::Position* position_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static FloatConstant* default_instance_;
};
// -------------------------------------------------------------------

class StringConstant : public ::google::protobuf::Message {
 public:
  StringConstant();
  virtual ~StringConstant();
  
  StringConstant(const StringConstant& from);
  
  inline StringConstant& operator=(const StringConstant& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringConstant& default_instance();
  
  void Swap(StringConstant* other);
  
  // implements Message ----------------------------------------------
  
  StringConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringConstant& from);
  void MergeFrom(const StringConstant& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // optional .blox.common.protocol.Position position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.StringConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_position();
  inline void clear_has_position();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  ::blox::common::protocol::Position* position_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static StringConstant* default_instance_;
};
// -------------------------------------------------------------------

class DateTimeConstant : public ::google::protobuf::Message {
 public:
  DateTimeConstant();
  virtual ~DateTimeConstant();
  
  DateTimeConstant(const DateTimeConstant& from);
  
  inline DateTimeConstant& operator=(const DateTimeConstant& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DateTimeConstant& default_instance();
  
  void Swap(DateTimeConstant* other);
  
  // implements Message ----------------------------------------------
  
  DateTimeConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DateTimeConstant& from);
  void MergeFrom(const DateTimeConstant& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);
  
  // optional .blox.common.protocol.Position position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.DateTimeConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_position();
  inline void clear_has_position();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 value_;
  ::blox::common::protocol::Position* position_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static DateTimeConstant* default_instance_;
};
// -------------------------------------------------------------------

class Type : public ::google::protobuf::Message {
 public:
  Type();
  virtual ~Type();
  
  Type(const Type& from);
  
  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type& default_instance();
  
  void Swap(Type* other);
  
  // implements Message ----------------------------------------------
  
  Type* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Type_Kind Kind;
  static const Kind PRIMITIVE = Type_Kind_PRIMITIVE;
  static const Kind UNARY = Type_Kind_UNARY;
  static inline bool Kind_IsValid(int value) {
    return Type_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    Type_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    Type_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    Type_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return Type_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return Type_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return Type_Kind_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .blox.common.protocol.Type.Kind kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::blox::common::protocol::Type_Kind kind() const;
  inline void set_kind(::blox::common::protocol::Type_Kind value);
  
  // optional .blox.common.protocol.PrimitiveType primitive = 2;
  inline bool has_primitive() const;
  inline void clear_primitive();
  static const int kPrimitiveFieldNumber = 2;
  inline const ::blox::common::protocol::PrimitiveType& primitive() const;
  inline ::blox::common::protocol::PrimitiveType* mutable_primitive();
  inline ::blox::common::protocol::PrimitiveType* release_primitive();
  
  // optional .blox.common.protocol.UnaryPredicateType unary = 3;
  inline bool has_unary() const;
  inline void clear_unary();
  static const int kUnaryFieldNumber = 3;
  inline const ::blox::common::protocol::UnaryPredicateType& unary() const;
  inline ::blox::common::protocol::UnaryPredicateType* mutable_unary();
  inline ::blox::common::protocol::UnaryPredicateType* release_unary();
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.Type)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_primitive();
  inline void clear_has_primitive();
  inline void set_has_unary();
  inline void clear_has_unary();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::blox::common::protocol::PrimitiveType* primitive_;
  ::blox::common::protocol::UnaryPredicateType* unary_;
  int kind_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static Type* default_instance_;
};
// -------------------------------------------------------------------

class PrimitiveType : public ::google::protobuf::Message {
 public:
  PrimitiveType();
  virtual ~PrimitiveType();
  
  PrimitiveType(const PrimitiveType& from);
  
  inline PrimitiveType& operator=(const PrimitiveType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PrimitiveType& default_instance();
  
  void Swap(PrimitiveType* other);
  
  // implements Message ----------------------------------------------
  
  PrimitiveType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrimitiveType& from);
  void MergeFrom(const PrimitiveType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PrimitiveType_Kind Kind;
  static const Kind BOOL = PrimitiveType_Kind_BOOL;
  static const Kind COLOR = PrimitiveType_Kind_COLOR;
  static const Kind SHAPE = PrimitiveType_Kind_SHAPE;
  static const Kind IMAGE = PrimitiveType_Kind_IMAGE;
  static const Kind BLOB = PrimitiveType_Kind_BLOB;
  static const Kind DATETIME = PrimitiveType_Kind_DATETIME;
  static const Kind INT = PrimitiveType_Kind_INT;
  static const Kind UINT = PrimitiveType_Kind_UINT;
  static const Kind FLOAT = PrimitiveType_Kind_FLOAT;
  static const Kind STRING = PrimitiveType_Kind_STRING;
  static const Kind DECIMAL = PrimitiveType_Kind_DECIMAL;
  static inline bool Kind_IsValid(int value) {
    return PrimitiveType_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    PrimitiveType_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    PrimitiveType_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    PrimitiveType_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return PrimitiveType_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return PrimitiveType_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return PrimitiveType_Kind_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .blox.common.protocol.PrimitiveType.Kind kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::blox::common::protocol::PrimitiveType_Kind kind() const;
  inline void set_kind(::blox::common::protocol::PrimitiveType_Kind value);
  
  // optional uint32 capacity = 2;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 2;
  inline ::google::protobuf::uint32 capacity() const;
  inline void set_capacity(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.PrimitiveType)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_capacity();
  inline void clear_has_capacity();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int kind_;
  ::google::protobuf::uint32 capacity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static PrimitiveType* default_instance_;
};
// -------------------------------------------------------------------

class UnaryPredicateType : public ::google::protobuf::Message {
 public:
  UnaryPredicateType();
  virtual ~UnaryPredicateType();
  
  UnaryPredicateType(const UnaryPredicateType& from);
  
  inline UnaryPredicateType& operator=(const UnaryPredicateType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnaryPredicateType& default_instance();
  
  void Swap(UnaryPredicateType* other);
  
  // implements Message ----------------------------------------------
  
  UnaryPredicateType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnaryPredicateType& from);
  void MergeFrom(const UnaryPredicateType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:blox.common.protocol.UnaryPredicateType)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloxCompiler_2eproto();
  friend void protobuf_AssignDesc_BloxCompiler_2eproto();
  friend void protobuf_ShutdownFile_BloxCompiler_2eproto();
  
  void InitAsDefaultInstance();
  static UnaryPredicateType* default_instance_;
};
// ===================================================================


// ===================================================================

// CompilationProblems

// repeated .blox.common.protocol.Problem error = 1;
inline int CompilationProblems::error_size() const {
  return error_.size();
}
inline void CompilationProblems::clear_error() {
  error_.Clear();
}
inline const ::blox::common::protocol::Problem& CompilationProblems::error(int index) const {
  return error_.Get(index);
}
inline ::blox::common::protocol::Problem* CompilationProblems::mutable_error(int index) {
  return error_.Mutable(index);
}
inline ::blox::common::protocol::Problem* CompilationProblems::add_error() {
  return error_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >&
CompilationProblems::error() const {
  return error_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >*
CompilationProblems::mutable_error() {
  return &error_;
}

// repeated .blox.common.protocol.Problem warning = 2;
inline int CompilationProblems::warning_size() const {
  return warning_.size();
}
inline void CompilationProblems::clear_warning() {
  warning_.Clear();
}
inline const ::blox::common::protocol::Problem& CompilationProblems::warning(int index) const {
  return warning_.Get(index);
}
inline ::blox::common::protocol::Problem* CompilationProblems::mutable_warning(int index) {
  return warning_.Mutable(index);
}
inline ::blox::common::protocol::Problem* CompilationProblems::add_warning() {
  return warning_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >&
CompilationProblems::warning() const {
  return warning_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >*
CompilationProblems::mutable_warning() {
  return &warning_;
}

// -------------------------------------------------------------------

// Problem

// optional string code = 1;
inline bool Problem::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Problem::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Problem::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Problem::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& Problem::code() const {
  return *code_;
}
inline void Problem::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void Problem::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void Problem::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Problem::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* Problem::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string msg = 2;
inline bool Problem::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Problem::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Problem::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Problem::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& Problem::msg() const {
  return *msg_;
}
inline void Problem::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void Problem::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void Problem::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Problem::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* Problem::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .blox.common.protocol.Position position = 4;
inline bool Problem::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Problem::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Problem::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Problem::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& Problem::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* Problem::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  return position_;
}
inline ::blox::common::protocol::Position* Problem::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}

// required .blox.common.protocol.Severity severity_code = 5;
inline bool Problem::has_severity_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Problem::set_has_severity_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Problem::clear_has_severity_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Problem::clear_severity_code() {
  severity_code_ = 0;
  clear_has_severity_code();
}
inline blox::common::protocol::Severity Problem::severity_code() const {
  return static_cast< blox::common::protocol::Severity >(severity_code_);
}
inline void Problem::set_severity_code(blox::common::protocol::Severity value) {
  GOOGLE_DCHECK(blox::common::protocol::Severity_IsValid(value));
  set_has_severity_code();
  severity_code_ = value;
}

// optional string quote = 7;
inline bool Problem::has_quote() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Problem::set_has_quote() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Problem::clear_has_quote() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Problem::clear_quote() {
  if (quote_ != &::google::protobuf::internal::kEmptyString) {
    quote_->clear();
  }
  clear_has_quote();
}
inline const ::std::string& Problem::quote() const {
  return *quote_;
}
inline void Problem::set_quote(const ::std::string& value) {
  set_has_quote();
  if (quote_ == &::google::protobuf::internal::kEmptyString) {
    quote_ = new ::std::string;
  }
  quote_->assign(value);
}
inline void Problem::set_quote(const char* value) {
  set_has_quote();
  if (quote_ == &::google::protobuf::internal::kEmptyString) {
    quote_ = new ::std::string;
  }
  quote_->assign(value);
}
inline void Problem::set_quote(const char* value, size_t size) {
  set_has_quote();
  if (quote_ == &::google::protobuf::internal::kEmptyString) {
    quote_ = new ::std::string;
  }
  quote_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Problem::mutable_quote() {
  set_has_quote();
  if (quote_ == &::google::protobuf::internal::kEmptyString) {
    quote_ = new ::std::string;
  }
  return quote_;
}
inline ::std::string* Problem::release_quote() {
  clear_has_quote();
  if (quote_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = quote_;
    quote_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Position

// required uint32 start_line = 1;
inline bool Position::has_start_line() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_start_line() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_start_line() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_start_line() {
  start_line_ = 0u;
  clear_has_start_line();
}
inline ::google::protobuf::uint32 Position::start_line() const {
  return start_line_;
}
inline void Position::set_start_line(::google::protobuf::uint32 value) {
  set_has_start_line();
  start_line_ = value;
}

// required uint32 start_column = 2;
inline bool Position::has_start_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_start_column() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_start_column() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_start_column() {
  start_column_ = 0u;
  clear_has_start_column();
}
inline ::google::protobuf::uint32 Position::start_column() const {
  return start_column_;
}
inline void Position::set_start_column(::google::protobuf::uint32 value) {
  set_has_start_column();
  start_column_ = value;
}

// optional uint32 end_line = 3;
inline bool Position::has_end_line() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_end_line() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_end_line() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_end_line() {
  end_line_ = 0u;
  clear_has_end_line();
}
inline ::google::protobuf::uint32 Position::end_line() const {
  return end_line_;
}
inline void Position::set_end_line(::google::protobuf::uint32 value) {
  set_has_end_line();
  end_line_ = value;
}

// optional uint32 end_column = 4;
inline bool Position::has_end_column() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Position::set_has_end_column() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Position::clear_has_end_column() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Position::clear_end_column() {
  end_column_ = 0u;
  clear_has_end_column();
}
inline ::google::protobuf::uint32 Position::end_column() const {
  return end_column_;
}
inline void Position::set_end_column(::google::protobuf::uint32 value) {
  set_has_end_column();
  end_column_ = value;
}

// optional uint32 start_offset = 5;
inline bool Position::has_start_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Position::set_has_start_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Position::clear_has_start_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Position::clear_start_offset() {
  start_offset_ = 0u;
  clear_has_start_offset();
}
inline ::google::protobuf::uint32 Position::start_offset() const {
  return start_offset_;
}
inline void Position::set_start_offset(::google::protobuf::uint32 value) {
  set_has_start_offset();
  start_offset_ = value;
}

// optional uint32 end_offset = 6;
inline bool Position::has_end_offset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Position::set_has_end_offset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Position::clear_has_end_offset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Position::clear_end_offset() {
  end_offset_ = 0u;
  clear_has_end_offset();
}
inline ::google::protobuf::uint32 Position::end_offset() const {
  return end_offset_;
}
inline void Position::set_end_offset(::google::protobuf::uint32 value) {
  set_has_end_offset();
  end_offset_ = value;
}

// required string block_name = 7;
inline bool Position::has_block_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Position::set_has_block_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Position::clear_has_block_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Position::clear_block_name() {
  if (block_name_ != &::google::protobuf::internal::kEmptyString) {
    block_name_->clear();
  }
  clear_has_block_name();
}
inline const ::std::string& Position::block_name() const {
  return *block_name_;
}
inline void Position::set_block_name(const ::std::string& value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::kEmptyString) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
}
inline void Position::set_block_name(const char* value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::kEmptyString) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
}
inline void Position::set_block_name(const char* value, size_t size) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::kEmptyString) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Position::mutable_block_name() {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::kEmptyString) {
    block_name_ = new ::std::string;
  }
  return block_name_;
}
inline ::std::string* Position::release_block_name() {
  clear_has_block_name();
  if (block_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = block_name_;
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string file_name = 8;
inline bool Position::has_file_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Position::set_has_file_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Position::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Position::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& Position::file_name() const {
  return *file_name_;
}
inline void Position::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void Position::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void Position::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Position::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* Position::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PredicateInfo

// required string name = 1;
inline bool PredicateInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredicateInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PredicateInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PredicateInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PredicateInfo::name() const {
  return *name_;
}
inline void PredicateInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PredicateInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PredicateInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PredicateInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string qualified_name = 2;
inline bool PredicateInfo::has_qualified_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PredicateInfo::set_has_qualified_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PredicateInfo::clear_has_qualified_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PredicateInfo::clear_qualified_name() {
  if (qualified_name_ != &::google::protobuf::internal::kEmptyString) {
    qualified_name_->clear();
  }
  clear_has_qualified_name();
}
inline const ::std::string& PredicateInfo::qualified_name() const {
  return *qualified_name_;
}
inline void PredicateInfo::set_qualified_name(const ::std::string& value) {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::kEmptyString) {
    qualified_name_ = new ::std::string;
  }
  qualified_name_->assign(value);
}
inline void PredicateInfo::set_qualified_name(const char* value) {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::kEmptyString) {
    qualified_name_ = new ::std::string;
  }
  qualified_name_->assign(value);
}
inline void PredicateInfo::set_qualified_name(const char* value, size_t size) {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::kEmptyString) {
    qualified_name_ = new ::std::string;
  }
  qualified_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::mutable_qualified_name() {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::kEmptyString) {
    qualified_name_ = new ::std::string;
  }
  return qualified_name_;
}
inline ::std::string* PredicateInfo::release_qualified_name() {
  clear_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qualified_name_;
    qualified_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 arity = 3;
inline bool PredicateInfo::has_arity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PredicateInfo::set_has_arity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PredicateInfo::clear_has_arity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PredicateInfo::clear_arity() {
  arity_ = 0u;
  clear_has_arity();
}
inline ::google::protobuf::uint32 PredicateInfo::arity() const {
  return arity_;
}
inline void PredicateInfo::set_arity(::google::protobuf::uint32 value) {
  set_has_arity();
  arity_ = value;
}

// required uint32 key_arity = 4;
inline bool PredicateInfo::has_key_arity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PredicateInfo::set_has_key_arity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PredicateInfo::clear_has_key_arity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PredicateInfo::clear_key_arity() {
  key_arity_ = 0u;
  clear_has_key_arity();
}
inline ::google::protobuf::uint32 PredicateInfo::key_arity() const {
  return key_arity_;
}
inline void PredicateInfo::set_key_arity(::google::protobuf::uint32 value) {
  set_has_key_arity();
  key_arity_ = value;
}

// required uint32 value_arity = 5;
inline bool PredicateInfo::has_value_arity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PredicateInfo::set_has_value_arity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PredicateInfo::clear_has_value_arity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PredicateInfo::clear_value_arity() {
  value_arity_ = 0u;
  clear_has_value_arity();
}
inline ::google::protobuf::uint32 PredicateInfo::value_arity() const {
  return value_arity_;
}
inline void PredicateInfo::set_value_arity(::google::protobuf::uint32 value) {
  set_has_value_arity();
  value_arity_ = value;
}

// repeated string key_argument = 6;
inline int PredicateInfo::key_argument_size() const {
  return key_argument_.size();
}
inline void PredicateInfo::clear_key_argument() {
  key_argument_.Clear();
}
inline const ::std::string& PredicateInfo::key_argument(int index) const {
  return key_argument_.Get(index);
}
inline ::std::string* PredicateInfo::mutable_key_argument(int index) {
  return key_argument_.Mutable(index);
}
inline void PredicateInfo::set_key_argument(int index, const ::std::string& value) {
  key_argument_.Mutable(index)->assign(value);
}
inline void PredicateInfo::set_key_argument(int index, const char* value) {
  key_argument_.Mutable(index)->assign(value);
}
inline void PredicateInfo::set_key_argument(int index, const char* value, size_t size) {
  key_argument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::add_key_argument() {
  return key_argument_.Add();
}
inline void PredicateInfo::add_key_argument(const ::std::string& value) {
  key_argument_.Add()->assign(value);
}
inline void PredicateInfo::add_key_argument(const char* value) {
  key_argument_.Add()->assign(value);
}
inline void PredicateInfo::add_key_argument(const char* value, size_t size) {
  key_argument_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PredicateInfo::key_argument() const {
  return key_argument_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PredicateInfo::mutable_key_argument() {
  return &key_argument_;
}

// repeated string value_argument = 7;
inline int PredicateInfo::value_argument_size() const {
  return value_argument_.size();
}
inline void PredicateInfo::clear_value_argument() {
  value_argument_.Clear();
}
inline const ::std::string& PredicateInfo::value_argument(int index) const {
  return value_argument_.Get(index);
}
inline ::std::string* PredicateInfo::mutable_value_argument(int index) {
  return value_argument_.Mutable(index);
}
inline void PredicateInfo::set_value_argument(int index, const ::std::string& value) {
  value_argument_.Mutable(index)->assign(value);
}
inline void PredicateInfo::set_value_argument(int index, const char* value) {
  value_argument_.Mutable(index)->assign(value);
}
inline void PredicateInfo::set_value_argument(int index, const char* value, size_t size) {
  value_argument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::add_value_argument() {
  return value_argument_.Add();
}
inline void PredicateInfo::add_value_argument(const ::std::string& value) {
  value_argument_.Add()->assign(value);
}
inline void PredicateInfo::add_value_argument(const char* value) {
  value_argument_.Add()->assign(value);
}
inline void PredicateInfo::add_value_argument(const char* value, size_t size) {
  value_argument_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PredicateInfo::value_argument() const {
  return value_argument_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PredicateInfo::mutable_value_argument() {
  return &value_argument_;
}

// required bool is_entity = 8 [default = false];
inline bool PredicateInfo::has_is_entity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PredicateInfo::set_has_is_entity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PredicateInfo::clear_has_is_entity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PredicateInfo::clear_is_entity() {
  is_entity_ = false;
  clear_has_is_entity();
}
inline bool PredicateInfo::is_entity() const {
  return is_entity_;
}
inline void PredicateInfo::set_is_entity(bool value) {
  set_has_is_entity();
  is_entity_ = value;
}

// required bool is_ref_mode = 9 [default = false];
inline bool PredicateInfo::has_is_ref_mode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PredicateInfo::set_has_is_ref_mode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PredicateInfo::clear_has_is_ref_mode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PredicateInfo::clear_is_ref_mode() {
  is_ref_mode_ = false;
  clear_has_is_ref_mode();
}
inline bool PredicateInfo::is_ref_mode() const {
  return is_ref_mode_;
}
inline void PredicateInfo::set_is_ref_mode(bool value) {
  set_has_is_ref_mode();
  is_ref_mode_ = value;
}

// required bool is_one_to_one = 10 [default = false];
inline bool PredicateInfo::has_is_one_to_one() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PredicateInfo::set_has_is_one_to_one() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PredicateInfo::clear_has_is_one_to_one() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PredicateInfo::clear_is_one_to_one() {
  is_one_to_one_ = false;
  clear_has_is_one_to_one();
}
inline bool PredicateInfo::is_one_to_one() const {
  return is_one_to_one_;
}
inline void PredicateInfo::set_is_one_to_one(bool value) {
  set_has_is_one_to_one();
  is_one_to_one_ = value;
}

// required bool is_ordered = 11 [default = false];
inline bool PredicateInfo::has_is_ordered() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PredicateInfo::set_has_is_ordered() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PredicateInfo::clear_has_is_ordered() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PredicateInfo::clear_is_ordered() {
  is_ordered_ = false;
  clear_has_is_ordered();
}
inline bool PredicateInfo::is_ordered() const {
  return is_ordered_;
}
inline void PredicateInfo::set_is_ordered(bool value) {
  set_has_is_ordered();
  is_ordered_ = value;
}

// required bool has_default_value = 12 [default = false];
inline bool PredicateInfo::has_has_default_value() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PredicateInfo::set_has_has_default_value() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PredicateInfo::clear_has_has_default_value() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PredicateInfo::clear_has_default_value() {
  has_default_value_ = false;
  clear_has_has_default_value();
}
inline bool PredicateInfo::has_default_value() const {
  return has_default_value_;
}
inline void PredicateInfo::set_has_default_value(bool value) {
  set_has_has_default_value();
  has_default_value_ = value;
}

// required bool is_disjoint = 13 [default = false];
inline bool PredicateInfo::has_is_disjoint() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PredicateInfo::set_has_is_disjoint() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PredicateInfo::clear_has_is_disjoint() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PredicateInfo::clear_is_disjoint() {
  is_disjoint_ = false;
  clear_has_is_disjoint();
}
inline bool PredicateInfo::is_disjoint() const {
  return is_disjoint_;
}
inline void PredicateInfo::set_is_disjoint(bool value) {
  set_has_is_disjoint();
  is_disjoint_ = value;
}

// required bool is_subtype = 14 [default = false];
inline bool PredicateInfo::has_is_subtype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PredicateInfo::set_has_is_subtype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PredicateInfo::clear_has_is_subtype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PredicateInfo::clear_is_subtype() {
  is_subtype_ = false;
  clear_has_is_subtype();
}
inline bool PredicateInfo::is_subtype() const {
  return is_subtype_;
}
inline void PredicateInfo::set_is_subtype(bool value) {
  set_has_is_subtype();
  is_subtype_ = value;
}

// optional string supertype = 15;
inline bool PredicateInfo::has_supertype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PredicateInfo::set_has_supertype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PredicateInfo::clear_has_supertype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PredicateInfo::clear_supertype() {
  if (supertype_ != &::google::protobuf::internal::kEmptyString) {
    supertype_->clear();
  }
  clear_has_supertype();
}
inline const ::std::string& PredicateInfo::supertype() const {
  return *supertype_;
}
inline void PredicateInfo::set_supertype(const ::std::string& value) {
  set_has_supertype();
  if (supertype_ == &::google::protobuf::internal::kEmptyString) {
    supertype_ = new ::std::string;
  }
  supertype_->assign(value);
}
inline void PredicateInfo::set_supertype(const char* value) {
  set_has_supertype();
  if (supertype_ == &::google::protobuf::internal::kEmptyString) {
    supertype_ = new ::std::string;
  }
  supertype_->assign(value);
}
inline void PredicateInfo::set_supertype(const char* value, size_t size) {
  set_has_supertype();
  if (supertype_ == &::google::protobuf::internal::kEmptyString) {
    supertype_ = new ::std::string;
  }
  supertype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::mutable_supertype() {
  set_has_supertype();
  if (supertype_ == &::google::protobuf::internal::kEmptyString) {
    supertype_ = new ::std::string;
  }
  return supertype_;
}
inline ::std::string* PredicateInfo::release_supertype() {
  clear_has_supertype();
  if (supertype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = supertype_;
    supertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string toptype = 42;
inline bool PredicateInfo::has_toptype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PredicateInfo::set_has_toptype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PredicateInfo::clear_has_toptype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PredicateInfo::clear_toptype() {
  if (toptype_ != &::google::protobuf::internal::kEmptyString) {
    toptype_->clear();
  }
  clear_has_toptype();
}
inline const ::std::string& PredicateInfo::toptype() const {
  return *toptype_;
}
inline void PredicateInfo::set_toptype(const ::std::string& value) {
  set_has_toptype();
  if (toptype_ == &::google::protobuf::internal::kEmptyString) {
    toptype_ = new ::std::string;
  }
  toptype_->assign(value);
}
inline void PredicateInfo::set_toptype(const char* value) {
  set_has_toptype();
  if (toptype_ == &::google::protobuf::internal::kEmptyString) {
    toptype_ = new ::std::string;
  }
  toptype_->assign(value);
}
inline void PredicateInfo::set_toptype(const char* value, size_t size) {
  set_has_toptype();
  if (toptype_ == &::google::protobuf::internal::kEmptyString) {
    toptype_ = new ::std::string;
  }
  toptype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::mutable_toptype() {
  set_has_toptype();
  if (toptype_ == &::google::protobuf::internal::kEmptyString) {
    toptype_ = new ::std::string;
  }
  return toptype_;
}
inline ::std::string* PredicateInfo::release_toptype() {
  clear_has_toptype();
  if (toptype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = toptype_;
    toptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool has_ref_mode = 16 [default = false];
inline bool PredicateInfo::has_has_ref_mode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PredicateInfo::set_has_has_ref_mode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PredicateInfo::clear_has_has_ref_mode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PredicateInfo::clear_has_ref_mode() {
  has_ref_mode_ = false;
  clear_has_has_ref_mode();
}
inline bool PredicateInfo::has_ref_mode() const {
  return has_ref_mode_;
}
inline void PredicateInfo::set_has_ref_mode(bool value) {
  set_has_has_ref_mode();
  has_ref_mode_ = value;
}

// optional string ref_mode_name = 17;
inline bool PredicateInfo::has_ref_mode_name() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PredicateInfo::set_has_ref_mode_name() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PredicateInfo::clear_has_ref_mode_name() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PredicateInfo::clear_ref_mode_name() {
  if (ref_mode_name_ != &::google::protobuf::internal::kEmptyString) {
    ref_mode_name_->clear();
  }
  clear_has_ref_mode_name();
}
inline const ::std::string& PredicateInfo::ref_mode_name() const {
  return *ref_mode_name_;
}
inline void PredicateInfo::set_ref_mode_name(const ::std::string& value) {
  set_has_ref_mode_name();
  if (ref_mode_name_ == &::google::protobuf::internal::kEmptyString) {
    ref_mode_name_ = new ::std::string;
  }
  ref_mode_name_->assign(value);
}
inline void PredicateInfo::set_ref_mode_name(const char* value) {
  set_has_ref_mode_name();
  if (ref_mode_name_ == &::google::protobuf::internal::kEmptyString) {
    ref_mode_name_ = new ::std::string;
  }
  ref_mode_name_->assign(value);
}
inline void PredicateInfo::set_ref_mode_name(const char* value, size_t size) {
  set_has_ref_mode_name();
  if (ref_mode_name_ == &::google::protobuf::internal::kEmptyString) {
    ref_mode_name_ = new ::std::string;
  }
  ref_mode_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::mutable_ref_mode_name() {
  set_has_ref_mode_name();
  if (ref_mode_name_ == &::google::protobuf::internal::kEmptyString) {
    ref_mode_name_ = new ::std::string;
  }
  return ref_mode_name_;
}
inline ::std::string* PredicateInfo::release_ref_mode_name() {
  clear_has_ref_mode_name();
  if (ref_mode_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ref_mode_name_;
    ref_mode_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool is_meta_predicate = 18 [default = false];
inline bool PredicateInfo::has_is_meta_predicate() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PredicateInfo::set_has_is_meta_predicate() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PredicateInfo::clear_has_is_meta_predicate() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PredicateInfo::clear_is_meta_predicate() {
  is_meta_predicate_ = false;
  clear_has_is_meta_predicate();
}
inline bool PredicateInfo::is_meta_predicate() const {
  return is_meta_predicate_;
}
inline void PredicateInfo::set_is_meta_predicate(bool value) {
  set_has_is_meta_predicate();
  is_meta_predicate_ = value;
}

// required bool is_pulse_predicate = 19 [default = false];
inline bool PredicateInfo::has_is_pulse_predicate() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PredicateInfo::set_has_is_pulse_predicate() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PredicateInfo::clear_has_is_pulse_predicate() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PredicateInfo::clear_is_pulse_predicate() {
  is_pulse_predicate_ = false;
  clear_has_is_pulse_predicate();
}
inline bool PredicateInfo::is_pulse_predicate() const {
  return is_pulse_predicate_;
}
inline void PredicateInfo::set_is_pulse_predicate(bool value) {
  set_has_is_pulse_predicate();
  is_pulse_predicate_ = value;
}

// required bool is_calculated = 20 [default = false];
inline bool PredicateInfo::has_is_calculated() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PredicateInfo::set_has_is_calculated() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PredicateInfo::clear_has_is_calculated() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PredicateInfo::clear_is_calculated() {
  is_calculated_ = false;
  clear_has_is_calculated();
}
inline bool PredicateInfo::is_calculated() const {
  return is_calculated_;
}
inline void PredicateInfo::set_is_calculated(bool value) {
  set_has_is_calculated();
  is_calculated_ = value;
}

// required bool line_numbers = 21 [default = false];
inline bool PredicateInfo::has_line_numbers() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PredicateInfo::set_has_line_numbers() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PredicateInfo::clear_has_line_numbers() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PredicateInfo::clear_line_numbers() {
  line_numbers_ = false;
  clear_has_line_numbers();
}
inline bool PredicateInfo::line_numbers() const {
  return line_numbers_;
}
inline void PredicateInfo::set_line_numbers(bool value) {
  set_has_line_numbers();
  line_numbers_ = value;
}

// required .blox.common.protocol.DerivationType derivation_type = 22;
inline bool PredicateInfo::has_derivation_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PredicateInfo::set_has_derivation_type() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PredicateInfo::clear_has_derivation_type() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PredicateInfo::clear_derivation_type() {
  derivation_type_ = 0;
  clear_has_derivation_type();
}
inline blox::common::protocol::DerivationType PredicateInfo::derivation_type() const {
  return static_cast< blox::common::protocol::DerivationType >(derivation_type_);
}
inline void PredicateInfo::set_derivation_type(blox::common::protocol::DerivationType value) {
  GOOGLE_DCHECK(blox::common::protocol::DerivationType_IsValid(value));
  set_has_derivation_type();
  derivation_type_ = value;
}

// required .blox.common.protocol.LockingPolicy locking_policy = 23;
inline bool PredicateInfo::has_locking_policy() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PredicateInfo::set_has_locking_policy() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PredicateInfo::clear_has_locking_policy() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PredicateInfo::clear_locking_policy() {
  locking_policy_ = 0;
  clear_has_locking_policy();
}
inline blox::common::protocol::LockingPolicy PredicateInfo::locking_policy() const {
  return static_cast< blox::common::protocol::LockingPolicy >(locking_policy_);
}
inline void PredicateInfo::set_locking_policy(blox::common::protocol::LockingPolicy value) {
  GOOGLE_DCHECK(blox::common::protocol::LockingPolicy_IsValid(value));
  set_has_locking_policy();
  locking_policy_ = value;
}

// required .blox.common.protocol.StorageModel storage_model = 24;
inline bool PredicateInfo::has_storage_model() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PredicateInfo::set_has_storage_model() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PredicateInfo::clear_has_storage_model() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PredicateInfo::clear_storage_model() {
  storage_model_ = 0;
  clear_has_storage_model();
}
inline blox::common::protocol::StorageModel PredicateInfo::storage_model() const {
  return static_cast< blox::common::protocol::StorageModel >(storage_model_);
}
inline void PredicateInfo::set_storage_model(blox::common::protocol::StorageModel value) {
  GOOGLE_DCHECK(blox::common::protocol::StorageModel_IsValid(value));
  set_has_storage_model();
  storage_model_ = value;
}

// required .blox.common.protocol.Partitioning partitioning = 25;
inline bool PredicateInfo::has_partitioning() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PredicateInfo::set_has_partitioning() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PredicateInfo::clear_has_partitioning() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PredicateInfo::clear_partitioning() {
  partitioning_ = 0;
  clear_has_partitioning();
}
inline blox::common::protocol::Partitioning PredicateInfo::partitioning() const {
  return static_cast< blox::common::protocol::Partitioning >(partitioning_);
}
inline void PredicateInfo::set_partitioning(blox::common::protocol::Partitioning value) {
  GOOGLE_DCHECK(blox::common::protocol::Partitioning_IsValid(value));
  set_has_partitioning();
  partitioning_ = value;
}

// optional uint64 capacity = 26 [default = 32767];
inline bool PredicateInfo::has_capacity() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PredicateInfo::set_has_capacity() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PredicateInfo::clear_has_capacity() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PredicateInfo::clear_capacity() {
  capacity_ = GOOGLE_ULONGLONG(32767);
  clear_has_capacity();
}
inline ::google::protobuf::uint64 PredicateInfo::capacity() const {
  return capacity_;
}
inline void PredicateInfo::set_capacity(::google::protobuf::uint64 value) {
  set_has_capacity();
  capacity_ = value;
}

// optional string role_names = 27;
inline bool PredicateInfo::has_role_names() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PredicateInfo::set_has_role_names() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PredicateInfo::clear_has_role_names() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PredicateInfo::clear_role_names() {
  if (role_names_ != &::google::protobuf::internal::kEmptyString) {
    role_names_->clear();
  }
  clear_has_role_names();
}
inline const ::std::string& PredicateInfo::role_names() const {
  return *role_names_;
}
inline void PredicateInfo::set_role_names(const ::std::string& value) {
  set_has_role_names();
  if (role_names_ == &::google::protobuf::internal::kEmptyString) {
    role_names_ = new ::std::string;
  }
  role_names_->assign(value);
}
inline void PredicateInfo::set_role_names(const char* value) {
  set_has_role_names();
  if (role_names_ == &::google::protobuf::internal::kEmptyString) {
    role_names_ = new ::std::string;
  }
  role_names_->assign(value);
}
inline void PredicateInfo::set_role_names(const char* value, size_t size) {
  set_has_role_names();
  if (role_names_ == &::google::protobuf::internal::kEmptyString) {
    role_names_ = new ::std::string;
  }
  role_names_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::mutable_role_names() {
  set_has_role_names();
  if (role_names_ == &::google::protobuf::internal::kEmptyString) {
    role_names_ = new ::std::string;
  }
  return role_names_;
}
inline ::std::string* PredicateInfo::release_role_names() {
  clear_has_role_names();
  if (role_names_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_names_;
    role_names_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool is_built_in = 28 [default = false];
inline bool PredicateInfo::has_is_built_in() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PredicateInfo::set_has_is_built_in() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PredicateInfo::clear_has_is_built_in() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PredicateInfo::clear_is_built_in() {
  is_built_in_ = false;
  clear_has_is_built_in();
}
inline bool PredicateInfo::is_built_in() const {
  return is_built_in_;
}
inline void PredicateInfo::set_is_built_in(bool value) {
  set_has_is_built_in();
  is_built_in_ = value;
}

// required bool is_skolem = 29 [default = false];
inline bool PredicateInfo::has_is_skolem() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PredicateInfo::set_has_is_skolem() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PredicateInfo::clear_has_is_skolem() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PredicateInfo::clear_is_skolem() {
  is_skolem_ = false;
  clear_has_is_skolem();
}
inline bool PredicateInfo::is_skolem() const {
  return is_skolem_;
}
inline void PredicateInfo::set_is_skolem(bool value) {
  set_has_is_skolem();
  is_skolem_ = value;
}

// required .blox.common.protocol.Lifetime lifetime = 30;
inline bool PredicateInfo::has_lifetime() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PredicateInfo::set_has_lifetime() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PredicateInfo::clear_has_lifetime() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PredicateInfo::clear_lifetime() {
  lifetime_ = 1;
  clear_has_lifetime();
}
inline blox::common::protocol::Lifetime PredicateInfo::lifetime() const {
  return static_cast< blox::common::protocol::Lifetime >(lifetime_);
}
inline void PredicateInfo::set_lifetime(blox::common::protocol::Lifetime value) {
  GOOGLE_DCHECK(blox::common::protocol::Lifetime_IsValid(value));
  set_has_lifetime();
  lifetime_ = value;
}

// required bool is_auto_numbered = 31;
inline bool PredicateInfo::has_is_auto_numbered() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PredicateInfo::set_has_is_auto_numbered() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PredicateInfo::clear_has_is_auto_numbered() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PredicateInfo::clear_is_auto_numbered() {
  is_auto_numbered_ = false;
  clear_has_is_auto_numbered();
}
inline bool PredicateInfo::is_auto_numbered() const {
  return is_auto_numbered_;
}
inline void PredicateInfo::set_is_auto_numbered(bool value) {
  set_has_is_auto_numbered();
  is_auto_numbered_ = value;
}

// optional .blox.common.protocol.Constant actual_default_value = 32;
inline bool PredicateInfo::has_actual_default_value() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PredicateInfo::set_has_actual_default_value() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PredicateInfo::clear_has_actual_default_value() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PredicateInfo::clear_actual_default_value() {
  if (actual_default_value_ != NULL) actual_default_value_->::blox::common::protocol::Constant::Clear();
  clear_has_actual_default_value();
}
inline const ::blox::common::protocol::Constant& PredicateInfo::actual_default_value() const {
  return actual_default_value_ != NULL ? *actual_default_value_ : *default_instance_->actual_default_value_;
}
inline ::blox::common::protocol::Constant* PredicateInfo::mutable_actual_default_value() {
  set_has_actual_default_value();
  if (actual_default_value_ == NULL) actual_default_value_ = new ::blox::common::protocol::Constant;
  return actual_default_value_;
}
inline ::blox::common::protocol::Constant* PredicateInfo::release_actual_default_value() {
  clear_has_actual_default_value();
  ::blox::common::protocol::Constant* temp = actual_default_value_;
  actual_default_value_ = NULL;
  return temp;
}

// optional string file_path = 33;
inline bool PredicateInfo::has_file_path() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PredicateInfo::set_has_file_path() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PredicateInfo::clear_has_file_path() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PredicateInfo::clear_file_path() {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    file_path_->clear();
  }
  clear_has_file_path();
}
inline const ::std::string& PredicateInfo::file_path() const {
  return *file_path_;
}
inline void PredicateInfo::set_file_path(const ::std::string& value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void PredicateInfo::set_file_path(const char* value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void PredicateInfo::set_file_path(const char* value, size_t size) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::mutable_file_path() {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  return file_path_;
}
inline ::std::string* PredicateInfo::release_file_path() {
  clear_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_path_;
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string delimiter = 34;
inline bool PredicateInfo::has_delimiter() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PredicateInfo::set_has_delimiter() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PredicateInfo::clear_has_delimiter() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PredicateInfo::clear_delimiter() {
  if (delimiter_ != &::google::protobuf::internal::kEmptyString) {
    delimiter_->clear();
  }
  clear_has_delimiter();
}
inline const ::std::string& PredicateInfo::delimiter() const {
  return *delimiter_;
}
inline void PredicateInfo::set_delimiter(const ::std::string& value) {
  set_has_delimiter();
  if (delimiter_ == &::google::protobuf::internal::kEmptyString) {
    delimiter_ = new ::std::string;
  }
  delimiter_->assign(value);
}
inline void PredicateInfo::set_delimiter(const char* value) {
  set_has_delimiter();
  if (delimiter_ == &::google::protobuf::internal::kEmptyString) {
    delimiter_ = new ::std::string;
  }
  delimiter_->assign(value);
}
inline void PredicateInfo::set_delimiter(const char* value, size_t size) {
  set_has_delimiter();
  if (delimiter_ == &::google::protobuf::internal::kEmptyString) {
    delimiter_ = new ::std::string;
  }
  delimiter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::mutable_delimiter() {
  set_has_delimiter();
  if (delimiter_ == &::google::protobuf::internal::kEmptyString) {
    delimiter_ = new ::std::string;
  }
  return delimiter_;
}
inline ::std::string* PredicateInfo::release_delimiter() {
  clear_has_delimiter();
  if (delimiter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = delimiter_;
    delimiter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool has_column_names = 35;
inline bool PredicateInfo::has_has_column_names() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PredicateInfo::set_has_has_column_names() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PredicateInfo::clear_has_has_column_names() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PredicateInfo::clear_has_column_names() {
  has_column_names_ = false;
  clear_has_has_column_names();
}
inline bool PredicateInfo::has_column_names() const {
  return has_column_names_;
}
inline void PredicateInfo::set_has_column_names(bool value) {
  set_has_has_column_names();
  has_column_names_ = value;
}

// optional string delim_column_names = 36;
inline bool PredicateInfo::has_delim_column_names() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PredicateInfo::set_has_delim_column_names() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PredicateInfo::clear_has_delim_column_names() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PredicateInfo::clear_delim_column_names() {
  if (delim_column_names_ != &::google::protobuf::internal::kEmptyString) {
    delim_column_names_->clear();
  }
  clear_has_delim_column_names();
}
inline const ::std::string& PredicateInfo::delim_column_names() const {
  return *delim_column_names_;
}
inline void PredicateInfo::set_delim_column_names(const ::std::string& value) {
  set_has_delim_column_names();
  if (delim_column_names_ == &::google::protobuf::internal::kEmptyString) {
    delim_column_names_ = new ::std::string;
  }
  delim_column_names_->assign(value);
}
inline void PredicateInfo::set_delim_column_names(const char* value) {
  set_has_delim_column_names();
  if (delim_column_names_ == &::google::protobuf::internal::kEmptyString) {
    delim_column_names_ = new ::std::string;
  }
  delim_column_names_->assign(value);
}
inline void PredicateInfo::set_delim_column_names(const char* value, size_t size) {
  set_has_delim_column_names();
  if (delim_column_names_ == &::google::protobuf::internal::kEmptyString) {
    delim_column_names_ = new ::std::string;
  }
  delim_column_names_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::mutable_delim_column_names() {
  set_has_delim_column_names();
  if (delim_column_names_ == &::google::protobuf::internal::kEmptyString) {
    delim_column_names_ = new ::std::string;
  }
  return delim_column_names_;
}
inline ::std::string* PredicateInfo::release_delim_column_names() {
  clear_has_delim_column_names();
  if (delim_column_names_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = delim_column_names_;
    delim_column_names_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool is_sealed = 37 [default = false];
inline bool PredicateInfo::has_is_sealed() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PredicateInfo::set_has_is_sealed() {
  _has_bits_[1] |= 0x00000020u;
}
inline void PredicateInfo::clear_has_is_sealed() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void PredicateInfo::clear_is_sealed() {
  is_sealed_ = false;
  clear_has_is_sealed();
}
inline bool PredicateInfo::is_sealed() const {
  return is_sealed_;
}
inline void PredicateInfo::set_is_sealed(bool value) {
  set_has_is_sealed();
  is_sealed_ = value;
}

// optional string local_name = 38;
inline bool PredicateInfo::has_local_name() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PredicateInfo::set_has_local_name() {
  _has_bits_[1] |= 0x00000040u;
}
inline void PredicateInfo::clear_has_local_name() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void PredicateInfo::clear_local_name() {
  if (local_name_ != &::google::protobuf::internal::kEmptyString) {
    local_name_->clear();
  }
  clear_has_local_name();
}
inline const ::std::string& PredicateInfo::local_name() const {
  return *local_name_;
}
inline void PredicateInfo::set_local_name(const ::std::string& value) {
  set_has_local_name();
  if (local_name_ == &::google::protobuf::internal::kEmptyString) {
    local_name_ = new ::std::string;
  }
  local_name_->assign(value);
}
inline void PredicateInfo::set_local_name(const char* value) {
  set_has_local_name();
  if (local_name_ == &::google::protobuf::internal::kEmptyString) {
    local_name_ = new ::std::string;
  }
  local_name_->assign(value);
}
inline void PredicateInfo::set_local_name(const char* value, size_t size) {
  set_has_local_name();
  if (local_name_ == &::google::protobuf::internal::kEmptyString) {
    local_name_ = new ::std::string;
  }
  local_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::mutable_local_name() {
  set_has_local_name();
  if (local_name_ == &::google::protobuf::internal::kEmptyString) {
    local_name_ = new ::std::string;
  }
  return local_name_;
}
inline ::std::string* PredicateInfo::release_local_name() {
  clear_has_local_name();
  if (local_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = local_name_;
    local_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string display_name = 39;
inline bool PredicateInfo::has_display_name() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PredicateInfo::set_has_display_name() {
  _has_bits_[1] |= 0x00000080u;
}
inline void PredicateInfo::clear_has_display_name() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void PredicateInfo::clear_display_name() {
  if (display_name_ != &::google::protobuf::internal::kEmptyString) {
    display_name_->clear();
  }
  clear_has_display_name();
}
inline const ::std::string& PredicateInfo::display_name() const {
  return *display_name_;
}
inline void PredicateInfo::set_display_name(const ::std::string& value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void PredicateInfo::set_display_name(const char* value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void PredicateInfo::set_display_name(const char* value, size_t size) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::mutable_display_name() {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}
inline ::std::string* PredicateInfo::release_display_name() {
  clear_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_name_;
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string remote_ref = 40;
inline bool PredicateInfo::has_remote_ref() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PredicateInfo::set_has_remote_ref() {
  _has_bits_[1] |= 0x00000100u;
}
inline void PredicateInfo::clear_has_remote_ref() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void PredicateInfo::clear_remote_ref() {
  if (remote_ref_ != &::google::protobuf::internal::kEmptyString) {
    remote_ref_->clear();
  }
  clear_has_remote_ref();
}
inline const ::std::string& PredicateInfo::remote_ref() const {
  return *remote_ref_;
}
inline void PredicateInfo::set_remote_ref(const ::std::string& value) {
  set_has_remote_ref();
  if (remote_ref_ == &::google::protobuf::internal::kEmptyString) {
    remote_ref_ = new ::std::string;
  }
  remote_ref_->assign(value);
}
inline void PredicateInfo::set_remote_ref(const char* value) {
  set_has_remote_ref();
  if (remote_ref_ == &::google::protobuf::internal::kEmptyString) {
    remote_ref_ = new ::std::string;
  }
  remote_ref_->assign(value);
}
inline void PredicateInfo::set_remote_ref(const char* value, size_t size) {
  set_has_remote_ref();
  if (remote_ref_ == &::google::protobuf::internal::kEmptyString) {
    remote_ref_ = new ::std::string;
  }
  remote_ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredicateInfo::mutable_remote_ref() {
  set_has_remote_ref();
  if (remote_ref_ == &::google::protobuf::internal::kEmptyString) {
    remote_ref_ = new ::std::string;
  }
  return remote_ref_;
}
inline ::std::string* PredicateInfo::release_remote_ref() {
  clear_has_remote_ref();
  if (remote_ref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remote_ref_;
    remote_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool is_synthetic = 41;
inline bool PredicateInfo::has_is_synthetic() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void PredicateInfo::set_has_is_synthetic() {
  _has_bits_[1] |= 0x00000200u;
}
inline void PredicateInfo::clear_has_is_synthetic() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void PredicateInfo::clear_is_synthetic() {
  is_synthetic_ = false;
  clear_has_is_synthetic();
}
inline bool PredicateInfo::is_synthetic() const {
  return is_synthetic_;
}
inline void PredicateInfo::set_is_synthetic(bool value) {
  set_has_is_synthetic();
  is_synthetic_ = value;
}

// optional bool is_constructor = 43;
inline bool PredicateInfo::has_is_constructor() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void PredicateInfo::set_has_is_constructor() {
  _has_bits_[1] |= 0x00000400u;
}
inline void PredicateInfo::clear_has_is_constructor() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void PredicateInfo::clear_is_constructor() {
  is_constructor_ = false;
  clear_has_is_constructor();
}
inline bool PredicateInfo::is_constructor() const {
  return is_constructor_;
}
inline void PredicateInfo::set_is_constructor(bool value) {
  set_has_is_constructor();
  is_constructor_ = value;
}

// -------------------------------------------------------------------

// Constant

// required .blox.common.protocol.Constant.Kind kind = 1;
inline bool Constant::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Constant::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Constant::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Constant::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::blox::common::protocol::Constant_Kind Constant::kind() const {
  return static_cast< ::blox::common::protocol::Constant_Kind >(kind_);
}
inline void Constant::set_kind(::blox::common::protocol::Constant_Kind value) {
  GOOGLE_DCHECK(::blox::common::protocol::Constant_Kind_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// optional .blox.common.protocol.BoolConstant bool_constant = 2;
inline bool Constant::has_bool_constant() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Constant::set_has_bool_constant() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Constant::clear_has_bool_constant() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Constant::clear_bool_constant() {
  if (bool_constant_ != NULL) bool_constant_->::blox::common::protocol::BoolConstant::Clear();
  clear_has_bool_constant();
}
inline const ::blox::common::protocol::BoolConstant& Constant::bool_constant() const {
  return bool_constant_ != NULL ? *bool_constant_ : *default_instance_->bool_constant_;
}
inline ::blox::common::protocol::BoolConstant* Constant::mutable_bool_constant() {
  set_has_bool_constant();
  if (bool_constant_ == NULL) bool_constant_ = new ::blox::common::protocol::BoolConstant;
  return bool_constant_;
}
inline ::blox::common::protocol::BoolConstant* Constant::release_bool_constant() {
  clear_has_bool_constant();
  ::blox::common::protocol::BoolConstant* temp = bool_constant_;
  bool_constant_ = NULL;
  return temp;
}

// optional .blox.common.protocol.IntConstant int_constant = 3;
inline bool Constant::has_int_constant() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Constant::set_has_int_constant() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Constant::clear_has_int_constant() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Constant::clear_int_constant() {
  if (int_constant_ != NULL) int_constant_->::blox::common::protocol::IntConstant::Clear();
  clear_has_int_constant();
}
inline const ::blox::common::protocol::IntConstant& Constant::int_constant() const {
  return int_constant_ != NULL ? *int_constant_ : *default_instance_->int_constant_;
}
inline ::blox::common::protocol::IntConstant* Constant::mutable_int_constant() {
  set_has_int_constant();
  if (int_constant_ == NULL) int_constant_ = new ::blox::common::protocol::IntConstant;
  return int_constant_;
}
inline ::blox::common::protocol::IntConstant* Constant::release_int_constant() {
  clear_has_int_constant();
  ::blox::common::protocol::IntConstant* temp = int_constant_;
  int_constant_ = NULL;
  return temp;
}

// optional .blox.common.protocol.FloatConstant float_constant = 4;
inline bool Constant::has_float_constant() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Constant::set_has_float_constant() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Constant::clear_has_float_constant() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Constant::clear_float_constant() {
  if (float_constant_ != NULL) float_constant_->::blox::common::protocol::FloatConstant::Clear();
  clear_has_float_constant();
}
inline const ::blox::common::protocol::FloatConstant& Constant::float_constant() const {
  return float_constant_ != NULL ? *float_constant_ : *default_instance_->float_constant_;
}
inline ::blox::common::protocol::FloatConstant* Constant::mutable_float_constant() {
  set_has_float_constant();
  if (float_constant_ == NULL) float_constant_ = new ::blox::common::protocol::FloatConstant;
  return float_constant_;
}
inline ::blox::common::protocol::FloatConstant* Constant::release_float_constant() {
  clear_has_float_constant();
  ::blox::common::protocol::FloatConstant* temp = float_constant_;
  float_constant_ = NULL;
  return temp;
}

// optional .blox.common.protocol.StringConstant string_constant = 5;
inline bool Constant::has_string_constant() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Constant::set_has_string_constant() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Constant::clear_has_string_constant() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Constant::clear_string_constant() {
  if (string_constant_ != NULL) string_constant_->::blox::common::protocol::StringConstant::Clear();
  clear_has_string_constant();
}
inline const ::blox::common::protocol::StringConstant& Constant::string_constant() const {
  return string_constant_ != NULL ? *string_constant_ : *default_instance_->string_constant_;
}
inline ::blox::common::protocol::StringConstant* Constant::mutable_string_constant() {
  set_has_string_constant();
  if (string_constant_ == NULL) string_constant_ = new ::blox::common::protocol::StringConstant;
  return string_constant_;
}
inline ::blox::common::protocol::StringConstant* Constant::release_string_constant() {
  clear_has_string_constant();
  ::blox::common::protocol::StringConstant* temp = string_constant_;
  string_constant_ = NULL;
  return temp;
}

// optional .blox.common.protocol.DateTimeConstant date_time_constant = 6;
inline bool Constant::has_date_time_constant() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Constant::set_has_date_time_constant() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Constant::clear_has_date_time_constant() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Constant::clear_date_time_constant() {
  if (date_time_constant_ != NULL) date_time_constant_->::blox::common::protocol::DateTimeConstant::Clear();
  clear_has_date_time_constant();
}
inline const ::blox::common::protocol::DateTimeConstant& Constant::date_time_constant() const {
  return date_time_constant_ != NULL ? *date_time_constant_ : *default_instance_->date_time_constant_;
}
inline ::blox::common::protocol::DateTimeConstant* Constant::mutable_date_time_constant() {
  set_has_date_time_constant();
  if (date_time_constant_ == NULL) date_time_constant_ = new ::blox::common::protocol::DateTimeConstant;
  return date_time_constant_;
}
inline ::blox::common::protocol::DateTimeConstant* Constant::release_date_time_constant() {
  clear_has_date_time_constant();
  ::blox::common::protocol::DateTimeConstant* temp = date_time_constant_;
  date_time_constant_ = NULL;
  return temp;
}

// optional .blox.common.protocol.UnsignedIntConstant uint_constant = 7;
inline bool Constant::has_uint_constant() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Constant::set_has_uint_constant() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Constant::clear_has_uint_constant() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Constant::clear_uint_constant() {
  if (uint_constant_ != NULL) uint_constant_->::blox::common::protocol::UnsignedIntConstant::Clear();
  clear_has_uint_constant();
}
inline const ::blox::common::protocol::UnsignedIntConstant& Constant::uint_constant() const {
  return uint_constant_ != NULL ? *uint_constant_ : *default_instance_->uint_constant_;
}
inline ::blox::common::protocol::UnsignedIntConstant* Constant::mutable_uint_constant() {
  set_has_uint_constant();
  if (uint_constant_ == NULL) uint_constant_ = new ::blox::common::protocol::UnsignedIntConstant;
  return uint_constant_;
}
inline ::blox::common::protocol::UnsignedIntConstant* Constant::release_uint_constant() {
  clear_has_uint_constant();
  ::blox::common::protocol::UnsignedIntConstant* temp = uint_constant_;
  uint_constant_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// BoolConstant

// required bool value = 1;
inline bool BoolConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoolConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoolConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoolConstant::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool BoolConstant::value() const {
  return value_;
}
inline void BoolConstant::set_value(bool value) {
  set_has_value();
  value_ = value;
}

// optional .blox.common.protocol.Position position = 2;
inline bool BoolConstant::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoolConstant::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoolConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoolConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& BoolConstant::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* BoolConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  return position_;
}
inline ::blox::common::protocol::Position* BoolConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// IntConstant

// required int64 value = 1;
inline bool IntConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntConstant::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 IntConstant::value() const {
  return value_;
}
inline void IntConstant::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
}

// required .blox.common.protocol.Type type = 2;
inline bool IntConstant::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntConstant::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntConstant::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntConstant::clear_type() {
  if (type_ != NULL) type_->::blox::common::protocol::Type::Clear();
  clear_has_type();
}
inline const ::blox::common::protocol::Type& IntConstant::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::blox::common::protocol::Type* IntConstant::mutable_type() {
  set_has_type();
  if (type_ == NULL) type_ = new ::blox::common::protocol::Type;
  return type_;
}
inline ::blox::common::protocol::Type* IntConstant::release_type() {
  clear_has_type();
  ::blox::common::protocol::Type* temp = type_;
  type_ = NULL;
  return temp;
}

// optional .blox.common.protocol.Position position = 3;
inline bool IntConstant::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IntConstant::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IntConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IntConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& IntConstant::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* IntConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  return position_;
}
inline ::blox::common::protocol::Position* IntConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UnsignedIntConstant

// required uint64 value = 1;
inline bool UnsignedIntConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnsignedIntConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnsignedIntConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnsignedIntConstant::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::uint64 UnsignedIntConstant::value() const {
  return value_;
}
inline void UnsignedIntConstant::set_value(::google::protobuf::uint64 value) {
  set_has_value();
  value_ = value;
}

// required .blox.common.protocol.Type type = 2;
inline bool UnsignedIntConstant::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnsignedIntConstant::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnsignedIntConstant::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnsignedIntConstant::clear_type() {
  if (type_ != NULL) type_->::blox::common::protocol::Type::Clear();
  clear_has_type();
}
inline const ::blox::common::protocol::Type& UnsignedIntConstant::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::blox::common::protocol::Type* UnsignedIntConstant::mutable_type() {
  set_has_type();
  if (type_ == NULL) type_ = new ::blox::common::protocol::Type;
  return type_;
}
inline ::blox::common::protocol::Type* UnsignedIntConstant::release_type() {
  clear_has_type();
  ::blox::common::protocol::Type* temp = type_;
  type_ = NULL;
  return temp;
}

// optional .blox.common.protocol.Position position = 3;
inline bool UnsignedIntConstant::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnsignedIntConstant::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnsignedIntConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnsignedIntConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& UnsignedIntConstant::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* UnsignedIntConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  return position_;
}
inline ::blox::common::protocol::Position* UnsignedIntConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// FloatConstant

// required string value = 1;
inline bool FloatConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloatConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloatConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloatConstant::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& FloatConstant::value() const {
  return *value_;
}
inline void FloatConstant::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FloatConstant::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FloatConstant::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FloatConstant::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* FloatConstant::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .blox.common.protocol.Type type = 2;
inline bool FloatConstant::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloatConstant::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloatConstant::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloatConstant::clear_type() {
  if (type_ != NULL) type_->::blox::common::protocol::Type::Clear();
  clear_has_type();
}
inline const ::blox::common::protocol::Type& FloatConstant::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::blox::common::protocol::Type* FloatConstant::mutable_type() {
  set_has_type();
  if (type_ == NULL) type_ = new ::blox::common::protocol::Type;
  return type_;
}
inline ::blox::common::protocol::Type* FloatConstant::release_type() {
  clear_has_type();
  ::blox::common::protocol::Type* temp = type_;
  type_ = NULL;
  return temp;
}

// optional .blox.common.protocol.Position position = 3;
inline bool FloatConstant::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FloatConstant::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FloatConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FloatConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& FloatConstant::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* FloatConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  return position_;
}
inline ::blox::common::protocol::Position* FloatConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// StringConstant

// required string value = 1;
inline bool StringConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringConstant::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& StringConstant::value() const {
  return *value_;
}
inline void StringConstant::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void StringConstant::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void StringConstant::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringConstant::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* StringConstant::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .blox.common.protocol.Position position = 2;
inline bool StringConstant::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringConstant::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& StringConstant::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* StringConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  return position_;
}
inline ::blox::common::protocol::Position* StringConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// DateTimeConstant

// optional int64 value = 1;
inline bool DateTimeConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DateTimeConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DateTimeConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DateTimeConstant::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 DateTimeConstant::value() const {
  return value_;
}
inline void DateTimeConstant::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
}

// optional .blox.common.protocol.Position position = 2;
inline bool DateTimeConstant::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DateTimeConstant::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DateTimeConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DateTimeConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& DateTimeConstant::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* DateTimeConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  return position_;
}
inline ::blox::common::protocol::Position* DateTimeConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Type

// required .blox.common.protocol.Type.Kind kind = 1;
inline bool Type::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Type::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Type::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Type::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::blox::common::protocol::Type_Kind Type::kind() const {
  return static_cast< ::blox::common::protocol::Type_Kind >(kind_);
}
inline void Type::set_kind(::blox::common::protocol::Type_Kind value) {
  GOOGLE_DCHECK(::blox::common::protocol::Type_Kind_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// optional .blox.common.protocol.PrimitiveType primitive = 2;
inline bool Type::has_primitive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Type::set_has_primitive() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Type::clear_has_primitive() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Type::clear_primitive() {
  if (primitive_ != NULL) primitive_->::blox::common::protocol::PrimitiveType::Clear();
  clear_has_primitive();
}
inline const ::blox::common::protocol::PrimitiveType& Type::primitive() const {
  return primitive_ != NULL ? *primitive_ : *default_instance_->primitive_;
}
inline ::blox::common::protocol::PrimitiveType* Type::mutable_primitive() {
  set_has_primitive();
  if (primitive_ == NULL) primitive_ = new ::blox::common::protocol::PrimitiveType;
  return primitive_;
}
inline ::blox::common::protocol::PrimitiveType* Type::release_primitive() {
  clear_has_primitive();
  ::blox::common::protocol::PrimitiveType* temp = primitive_;
  primitive_ = NULL;
  return temp;
}

// optional .blox.common.protocol.UnaryPredicateType unary = 3;
inline bool Type::has_unary() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Type::set_has_unary() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Type::clear_has_unary() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Type::clear_unary() {
  if (unary_ != NULL) unary_->::blox::common::protocol::UnaryPredicateType::Clear();
  clear_has_unary();
}
inline const ::blox::common::protocol::UnaryPredicateType& Type::unary() const {
  return unary_ != NULL ? *unary_ : *default_instance_->unary_;
}
inline ::blox::common::protocol::UnaryPredicateType* Type::mutable_unary() {
  set_has_unary();
  if (unary_ == NULL) unary_ = new ::blox::common::protocol::UnaryPredicateType;
  return unary_;
}
inline ::blox::common::protocol::UnaryPredicateType* Type::release_unary() {
  clear_has_unary();
  ::blox::common::protocol::UnaryPredicateType* temp = unary_;
  unary_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PrimitiveType

// required .blox.common.protocol.PrimitiveType.Kind kind = 1;
inline bool PrimitiveType::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrimitiveType::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrimitiveType::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrimitiveType::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::blox::common::protocol::PrimitiveType_Kind PrimitiveType::kind() const {
  return static_cast< ::blox::common::protocol::PrimitiveType_Kind >(kind_);
}
inline void PrimitiveType::set_kind(::blox::common::protocol::PrimitiveType_Kind value) {
  GOOGLE_DCHECK(::blox::common::protocol::PrimitiveType_Kind_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// optional uint32 capacity = 2;
inline bool PrimitiveType::has_capacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrimitiveType::set_has_capacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrimitiveType::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrimitiveType::clear_capacity() {
  capacity_ = 0u;
  clear_has_capacity();
}
inline ::google::protobuf::uint32 PrimitiveType::capacity() const {
  return capacity_;
}
inline void PrimitiveType::set_capacity(::google::protobuf::uint32 value) {
  set_has_capacity();
  capacity_ = value;
}

// -------------------------------------------------------------------

// UnaryPredicateType

// required string name = 1;
inline bool UnaryPredicateType::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnaryPredicateType::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnaryPredicateType::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnaryPredicateType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UnaryPredicateType::name() const {
  return *name_;
}
inline void UnaryPredicateType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UnaryPredicateType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UnaryPredicateType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnaryPredicateType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UnaryPredicateType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace common
}  // namespace blox

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::common::protocol::Constant_Kind>() {
  return ::blox::common::protocol::Constant_Kind_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::common::protocol::Type_Kind>() {
  return ::blox::common::protocol::Type_Kind_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::common::protocol::PrimitiveType_Kind>() {
  return ::blox::common::protocol::PrimitiveType_Kind_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::common::protocol::Severity>() {
  return blox::common::protocol::Severity_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::common::protocol::Lifetime>() {
  return blox::common::protocol::Lifetime_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::common::protocol::DerivationType>() {
  return blox::common::protocol::DerivationType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::common::protocol::LockingPolicy>() {
  return blox::common::protocol::LockingPolicy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::common::protocol::StorageModel>() {
  return blox::common::protocol::StorageModel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::common::protocol::Partitioning>() {
  return blox::common::protocol::Partitioning_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< blox::common::protocol::LogicSort>() {
  return blox::common::protocol::LogicSort_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BloxCompiler_2eproto__INCLUDED

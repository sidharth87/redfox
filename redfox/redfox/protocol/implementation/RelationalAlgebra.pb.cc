// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "../interface/RelationalAlgebra.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace blox {
namespace compiler {
namespace gpu {

namespace {

const ::google::protobuf::Descriptor* GPUGraph_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUGraph_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUVariable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUVariable_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUUnion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUUnion_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUIntersection_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUIntersection_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUProduct_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUProduct_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUSingle_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUSingle_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUDifference_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUDifference_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUJoin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUJoin_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUMapFilter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUMapFilter_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUAgg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUAgg_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUOperator_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUOperator_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUAssign_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUAssign_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUCond_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUCond_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUGoto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUGoto_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUMove_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUMove_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUCommand_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUCommand_reflection_ = NULL;
const ::google::protobuf::Descriptor* Address_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Address_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUCompare_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUCompare_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPUSequence_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPUSequence_reflection_ = NULL;
const ::google::protobuf::Descriptor* NumType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NumType_reflection_ = NULL;
const ::google::protobuf::Descriptor* Univ_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Univ_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConstExp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConstExp_reflection_ = NULL;
const ::google::protobuf::Descriptor* Name_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Name_reflection_ = NULL;
const ::google::protobuf::Descriptor* Index_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Index_reflection_ = NULL;
const ::google::protobuf::Descriptor* ArithExp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ArithExp_reflection_ = NULL;
const ::google::protobuf::Descriptor* Convert_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Convert_reflection_ = NULL;
const ::google::protobuf::Descriptor* Mixed_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Mixed_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_reflection_ = NULL;
const ::google::protobuf::Descriptor* Exp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Exp_reflection_ = NULL;
const ::google::protobuf::Descriptor* Comp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Comp_reflection_ = NULL;
const ::google::protobuf::Descriptor* Test_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Test_reflection_ = NULL;
const ::google::protobuf::Descriptor* And_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  And_reflection_ = NULL;
const ::google::protobuf::Descriptor* Compare_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Compare_reflection_ = NULL;
const ::google::protobuf::Descriptor* Count_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Count_reflection_ = NULL;
const ::google::protobuf::Descriptor* Total_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Total_reflection_ = NULL;
const ::google::protobuf::Descriptor* Min_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Min_reflection_ = NULL;
const ::google::protobuf::Descriptor* Max_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Max_reflection_ = NULL;
const ::google::protobuf::Descriptor* Agg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Agg_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* OperatorTag_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CommandTag_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Comparison_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* AddressTag_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ArithmeticOp_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Numeric_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Fixed_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* UnivTag_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ExpTag_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CompareTag_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* AggTag_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_RelationalAlgebra_2eproto() {
  protobuf_AddDesc_RelationalAlgebra_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "RelationalAlgebra.proto");
  GOOGLE_CHECK(file != NULL);
  GPUGraph_descriptor_ = file->message_type(0);
  static const int GPUGraph_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUGraph, graphname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUGraph, variables_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUGraph, sequences_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUGraph, entry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUGraph, exit_),
  };
  GPUGraph_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUGraph_descriptor_,
      GPUGraph::default_instance_,
      GPUGraph_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUGraph, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUGraph, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUGraph));
  GPUVariable_descriptor_ = file->message_type(1);
  static const int GPUVariable_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUVariable, varname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUVariable, keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUVariable, fields_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUVariable, initialdata_),
  };
  GPUVariable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUVariable_descriptor_,
      GPUVariable::default_instance_,
      GPUVariable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUVariable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUVariable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUVariable));
  GPUUnion_descriptor_ = file->message_type(2);
  static const int GPUUnion_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUUnion, srca_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUUnion, srcb_),
  };
  GPUUnion_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUUnion_descriptor_,
      GPUUnion::default_instance_,
      GPUUnion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUUnion, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUUnion, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUUnion));
  GPUIntersection_descriptor_ = file->message_type(3);
  static const int GPUIntersection_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUIntersection, srca_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUIntersection, srcb_),
  };
  GPUIntersection_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUIntersection_descriptor_,
      GPUIntersection::default_instance_,
      GPUIntersection_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUIntersection, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUIntersection, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUIntersection));
  GPUProduct_descriptor_ = file->message_type(4);
  static const int GPUProduct_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUProduct, srca_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUProduct, srcb_),
  };
  GPUProduct_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUProduct_descriptor_,
      GPUProduct::default_instance_,
      GPUProduct_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUProduct, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUProduct, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUProduct));
  GPUSingle_descriptor_ = file->message_type(5);
  static const int GPUSingle_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUSingle, element_),
  };
  GPUSingle_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUSingle_descriptor_,
      GPUSingle::default_instance_,
      GPUSingle_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUSingle, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUSingle, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUSingle));
  GPUDifference_descriptor_ = file->message_type(6);
  static const int GPUDifference_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUDifference, srca_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUDifference, srcb_),
  };
  GPUDifference_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUDifference_descriptor_,
      GPUDifference::default_instance_,
      GPUDifference_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUDifference, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUDifference, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUDifference));
  GPUJoin_descriptor_ = file->message_type(7);
  static const int GPUJoin_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUJoin, keycount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUJoin, srca_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUJoin, srcb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUJoin, args_),
  };
  GPUJoin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUJoin_descriptor_,
      GPUJoin::default_instance_,
      GPUJoin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUJoin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUJoin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUJoin));
  GPUMapFilter_descriptor_ = file->message_type(8);
  static const int GPUMapFilter_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUMapFilter, srcwidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUMapFilter, predicate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUMapFilter, reordering_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUMapFilter, srca_),
  };
  GPUMapFilter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUMapFilter_descriptor_,
      GPUMapFilter::default_instance_,
      GPUMapFilter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUMapFilter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUMapFilter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUMapFilter));
  GPUAgg_descriptor_ = file->message_type(9);
  static const int GPUAgg_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUAgg, srcwidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUAgg, domains_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUAgg, range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUAgg, srca_),
  };
  GPUAgg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUAgg_descriptor_,
      GPUAgg::default_instance_,
      GPUAgg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUAgg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUAgg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUAgg));
  GPUOperator_descriptor_ = file->message_type(10);
  static const int GPUOperator_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUOperator, tag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUOperator, unionop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUOperator, intersection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUOperator, product_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUOperator, single_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUOperator, difference_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUOperator, join_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUOperator, mapfilter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUOperator, agg_),
  };
  GPUOperator_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUOperator_descriptor_,
      GPUOperator::default_instance_,
      GPUOperator_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUOperator, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUOperator, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUOperator));
  GPUAssign_descriptor_ = file->message_type(11);
  static const int GPUAssign_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUAssign, dest_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUAssign, op_),
  };
  GPUAssign_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUAssign_descriptor_,
      GPUAssign::default_instance_,
      GPUAssign_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUAssign, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUAssign, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUAssign));
  GPUCond_descriptor_ = file->message_type(12);
  static const int GPUCond_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCond, src1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCond, src2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCond, yes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCond, no_),
  };
  GPUCond_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUCond_descriptor_,
      GPUCond::default_instance_,
      GPUCond_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCond, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCond, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUCond));
  GPUGoto_descriptor_ = file->message_type(13);
  static const int GPUGoto_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUGoto, target_),
  };
  GPUGoto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUGoto_descriptor_,
      GPUGoto::default_instance_,
      GPUGoto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUGoto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUGoto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUGoto));
  GPUMove_descriptor_ = file->message_type(14);
  static const int GPUMove_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUMove, dest_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUMove, src1_),
  };
  GPUMove_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUMove_descriptor_,
      GPUMove::default_instance_,
      GPUMove_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUMove, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUMove, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUMove));
  GPUCommand_descriptor_ = file->message_type(15);
  static const int GPUCommand_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCommand, tag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCommand, assign_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCommand, cond_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCommand, jump_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCommand, move_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCommand, halt_),
  };
  GPUCommand_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUCommand_descriptor_,
      GPUCommand::default_instance_,
      GPUCommand_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCommand, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCommand, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUCommand));
  Address_descriptor_ = file->message_type(16);
  static const int Address_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, tag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, varaddr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, constaddr_),
  };
  Address_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Address_descriptor_,
      Address::default_instance_,
      Address_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Address));
  GPUCompare_descriptor_ = file->message_type(17);
  static const int GPUCompare_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCompare, comparison_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCompare, optype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCompare, addr1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCompare, addr2_),
  };
  GPUCompare_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUCompare_descriptor_,
      GPUCompare::default_instance_,
      GPUCompare_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCompare, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUCompare, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUCompare));
  GPUSequence_descriptor_ = file->message_type(18);
  static const int GPUSequence_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUSequence, uniqueidentifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUSequence, operators_),
  };
  GPUSequence_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPUSequence_descriptor_,
      GPUSequence::default_instance_,
      GPUSequence_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUSequence, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPUSequence, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPUSequence));
  NumType_descriptor_ = file->message_type(19);
  static const int NumType_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NumType, typ_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NumType, size_),
  };
  NumType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NumType_descriptor_,
      NumType::default_instance_,
      NumType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NumType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NumType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NumType));
  Univ_descriptor_ = file->message_type(20);
  static const int Univ_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Univ, tag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Univ, n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Univ, f_),
  };
  Univ_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Univ_descriptor_,
      Univ::default_instance_,
      Univ_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Univ, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Univ, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Univ));
  ConstExp_descriptor_ = file->message_type(21);
  static const int ConstExp_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConstExp, literal_),
  };
  ConstExp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ConstExp_descriptor_,
      ConstExp::default_instance_,
      ConstExp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConstExp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConstExp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ConstExp));
  Name_descriptor_ = file->message_type(22);
  static const int Name_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Name, ename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Name, etype_),
  };
  Name_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Name_descriptor_,
      Name::default_instance_,
      Name_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Name, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Name, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Name));
  Index_descriptor_ = file->message_type(23);
  static const int Index_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Index, offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Index, etyp_),
  };
  Index_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Index_descriptor_,
      Index::default_instance_,
      Index_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Index, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Index, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Index));
  ArithExp_descriptor_ = file->message_type(24);
  static const int ArithExp_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ArithExp, domain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ArithExp, op_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ArithExp, exp1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ArithExp, exp2_),
  };
  ArithExp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ArithExp_descriptor_,
      ArithExp::default_instance_,
      ArithExp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ArithExp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ArithExp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ArithExp));
  Convert_descriptor_ = file->message_type(25);
  static const int Convert_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Convert, convdom_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Convert, convrng_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Convert, exp2_),
  };
  Convert_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Convert_descriptor_,
      Convert::default_instance_,
      Convert_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Convert, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Convert, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Convert));
  Mixed_descriptor_ = file->message_type(26);
  static const int Mixed_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mixed, domain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mixed, range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mixed, exp1_),
  };
  Mixed_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Mixed_descriptor_,
      Mixed::default_instance_,
      Mixed_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mixed, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mixed, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Mixed));
  Call_descriptor_ = file->message_type(27);
  static const int Call_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, calltype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, callname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, args_),
  };
  Call_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_descriptor_,
      Call::default_instance_,
      Call_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call));
  Exp_descriptor_ = file->message_type(28);
  static const int Exp_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exp, tag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exp, constexp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exp, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exp, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exp, arithexp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exp, convert_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exp, mixed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exp, call_),
  };
  Exp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Exp_descriptor_,
      Exp::default_instance_,
      Exp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Exp));
  Comp_descriptor_ = file->message_type(29);
  static const int Comp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Comp, comparison_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Comp, op1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Comp, op2_),
  };
  Comp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Comp_descriptor_,
      Comp::default_instance_,
      Comp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Comp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Comp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Comp));
  Test_descriptor_ = file->message_type(30);
  static const int Test_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Test, testtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Test, testname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Test, ops_),
  };
  Test_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Test_descriptor_,
      Test::default_instance_,
      Test_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Test, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Test, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Test));
  And_descriptor_ = file->message_type(31);
  static const int And_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(And, and1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(And, and2_),
  };
  And_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      And_descriptor_,
      And::default_instance_,
      And_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(And, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(And, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(And));
  Compare_descriptor_ = file->message_type(32);
  static const int Compare_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Compare, tag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Compare, comp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Compare, test_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Compare, andcomp_),
  };
  Compare_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Compare_descriptor_,
      Compare::default_instance_,
      Compare_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Compare, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Compare, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Compare));
  Count_descriptor_ = file->message_type(33);
  static const int Count_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Count, aggrng_),
  };
  Count_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Count_descriptor_,
      Count::default_instance_,
      Count_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Count, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Count, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Count));
  Total_descriptor_ = file->message_type(34);
  static const int Total_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Total, aggdom_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Total, aggrng_),
  };
  Total_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Total_descriptor_,
      Total::default_instance_,
      Total_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Total, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Total, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Total));
  Min_descriptor_ = file->message_type(35);
  static const int Min_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Min, aggdom_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Min, aggrng_),
  };
  Min_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Min_descriptor_,
      Min::default_instance_,
      Min_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Min, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Min, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Min));
  Max_descriptor_ = file->message_type(36);
  static const int Max_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Max, aggdom_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Max, aggrng_),
  };
  Max_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Max_descriptor_,
      Max::default_instance_,
      Max_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Max, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Max, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Max));
  Agg_descriptor_ = file->message_type(37);
  static const int Agg_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Agg, tag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Agg, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Agg, total_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Agg, min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Agg, max_),
  };
  Agg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Agg_descriptor_,
      Agg::default_instance_,
      Agg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Agg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Agg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Agg));
  OperatorTag_descriptor_ = file->enum_type(0);
  CommandTag_descriptor_ = file->enum_type(1);
  Comparison_descriptor_ = file->enum_type(2);
  AddressTag_descriptor_ = file->enum_type(3);
  ArithmeticOp_descriptor_ = file->enum_type(4);
  Numeric_descriptor_ = file->enum_type(5);
  Fixed_descriptor_ = file->enum_type(6);
  UnivTag_descriptor_ = file->enum_type(7);
  ExpTag_descriptor_ = file->enum_type(8);
  CompareTag_descriptor_ = file->enum_type(9);
  AggTag_descriptor_ = file->enum_type(10);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_RelationalAlgebra_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUGraph_descriptor_, &GPUGraph::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUVariable_descriptor_, &GPUVariable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUUnion_descriptor_, &GPUUnion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUIntersection_descriptor_, &GPUIntersection::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUProduct_descriptor_, &GPUProduct::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUSingle_descriptor_, &GPUSingle::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUDifference_descriptor_, &GPUDifference::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUJoin_descriptor_, &GPUJoin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUMapFilter_descriptor_, &GPUMapFilter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUAgg_descriptor_, &GPUAgg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUOperator_descriptor_, &GPUOperator::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUAssign_descriptor_, &GPUAssign::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUCond_descriptor_, &GPUCond::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUGoto_descriptor_, &GPUGoto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUMove_descriptor_, &GPUMove::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUCommand_descriptor_, &GPUCommand::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Address_descriptor_, &Address::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUCompare_descriptor_, &GPUCompare::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPUSequence_descriptor_, &GPUSequence::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NumType_descriptor_, &NumType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Univ_descriptor_, &Univ::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ConstExp_descriptor_, &ConstExp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Name_descriptor_, &Name::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Index_descriptor_, &Index::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ArithExp_descriptor_, &ArithExp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Convert_descriptor_, &Convert::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Mixed_descriptor_, &Mixed::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_descriptor_, &Call::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Exp_descriptor_, &Exp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Comp_descriptor_, &Comp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Test_descriptor_, &Test::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    And_descriptor_, &And::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Compare_descriptor_, &Compare::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Count_descriptor_, &Count::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Total_descriptor_, &Total::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Min_descriptor_, &Min::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Max_descriptor_, &Max::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Agg_descriptor_, &Agg::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_RelationalAlgebra_2eproto() {
  delete GPUGraph::default_instance_;
  delete GPUGraph_reflection_;
  delete GPUVariable::default_instance_;
  delete GPUVariable_reflection_;
  delete GPUUnion::default_instance_;
  delete GPUUnion_reflection_;
  delete GPUIntersection::default_instance_;
  delete GPUIntersection_reflection_;
  delete GPUProduct::default_instance_;
  delete GPUProduct_reflection_;
  delete GPUSingle::default_instance_;
  delete GPUSingle_reflection_;
  delete GPUDifference::default_instance_;
  delete GPUDifference_reflection_;
  delete GPUJoin::default_instance_;
  delete GPUJoin_reflection_;
  delete GPUMapFilter::default_instance_;
  delete GPUMapFilter_reflection_;
  delete GPUAgg::default_instance_;
  delete GPUAgg_reflection_;
  delete GPUOperator::default_instance_;
  delete GPUOperator_reflection_;
  delete GPUAssign::default_instance_;
  delete GPUAssign_reflection_;
  delete GPUCond::default_instance_;
  delete GPUCond_reflection_;
  delete GPUGoto::default_instance_;
  delete GPUGoto_reflection_;
  delete GPUMove::default_instance_;
  delete GPUMove_reflection_;
  delete GPUCommand::default_instance_;
  delete GPUCommand_reflection_;
  delete Address::default_instance_;
  delete Address_reflection_;
  delete GPUCompare::default_instance_;
  delete GPUCompare_reflection_;
  delete GPUSequence::default_instance_;
  delete GPUSequence_reflection_;
  delete NumType::default_instance_;
  delete NumType_reflection_;
  delete Univ::default_instance_;
  delete Univ_reflection_;
  delete ConstExp::default_instance_;
  delete ConstExp_reflection_;
  delete Name::default_instance_;
  delete Name_reflection_;
  delete Index::default_instance_;
  delete Index_reflection_;
  delete ArithExp::default_instance_;
  delete ArithExp_reflection_;
  delete Convert::default_instance_;
  delete Convert_reflection_;
  delete Mixed::default_instance_;
  delete Mixed_reflection_;
  delete Call::default_instance_;
  delete Call_reflection_;
  delete Exp::default_instance_;
  delete Exp_reflection_;
  delete Comp::default_instance_;
  delete Comp_reflection_;
  delete Test::default_instance_;
  delete Test_reflection_;
  delete And::default_instance_;
  delete And_reflection_;
  delete Compare::default_instance_;
  delete Compare_reflection_;
  delete Count::default_instance_;
  delete Count_reflection_;
  delete Total::default_instance_;
  delete Total_reflection_;
  delete Min::default_instance_;
  delete Min_reflection_;
  delete Max::default_instance_;
  delete Max_reflection_;
  delete Agg::default_instance_;
  delete Agg_reflection_;
}

void protobuf_AddDesc_RelationalAlgebra_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::blox::common::protocol::protobuf_AddDesc_BloxCompiler_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\027RelationalAlgebra.proto\022\021blox.compiler"
    ".gpu\032\022BloxCompiler.proto\"\240\001\n\010GPUGraph\022\021\n"
    "\tgraphName\030\001 \002(\t\0221\n\tvariables\030\002 \003(\0132\036.bl"
    "ox.compiler.gpu.GPUVariable\0221\n\tsequences"
    "\030\003 \003(\0132\036.blox.compiler.gpu.GPUSequence\022\r"
    "\n\005entry\030\004 \002(\005\022\014\n\004exit\030\005 \002(\005\"\211\001\n\013GPUVaria"
    "ble\022\017\n\007varName\030\001 \002(\t\022(\n\004keys\030\002 \003(\0132\032.blo"
    "x.common.protocol.Type\022*\n\006fields\030\003 \003(\0132\032"
    ".blox.common.protocol.Type\022\023\n\013initialDat"
    "a\030\004 \002(\014\"&\n\010GPUUnion\022\014\n\004srcA\030\002 \002(\t\022\014\n\004src"
    "B\030\003 \002(\t\"-\n\017GPUIntersection\022\014\n\004srcA\030\002 \002(\t"
    "\022\014\n\004srcB\030\003 \002(\t\"(\n\nGPUProduct\022\014\n\004srcA\030\002 \002"
    "(\t\022\014\n\004srcB\030\003 \002(\t\"<\n\tGPUSingle\022/\n\007element"
    "\030\001 \003(\0132\036.blox.common.protocol.Constant\"+"
    "\n\rGPUDifference\022\014\n\004srcA\030\003 \002(\t\022\014\n\004srcB\030\004 "
    "\002(\t\"]\n\007GPUJoin\022\020\n\010keyCount\030\002 \002(\005\022\014\n\004srcA"
    "\030\003 \002(\t\022\014\n\004srcB\030\004 \002(\t\022$\n\004args\030\005 \003(\0132\026.blo"
    "x.compiler.gpu.Exp\"\211\001\n\014GPUMapFilter\022\020\n\010s"
    "rcWidth\030\002 \002(\005\022-\n\tpredicate\030\003 \002(\0132\032.blox."
    "compiler.gpu.Compare\022*\n\nreordering\030\004 \003(\013"
    "2\026.blox.compiler.gpu.Exp\022\014\n\004srcA\030\005 \002(\t\"`"
    "\n\006GPUAgg\022\020\n\010srcWidth\030\002 \002(\005\022\017\n\007domains\030\003 "
    "\003(\005\022%\n\005range\030\004 \003(\0132\026.blox.compiler.gpu.A"
    "gg\022\014\n\004srcA\030\005 \002(\t\"\274\003\n\013GPUOperator\022+\n\003tag\030"
    "\001 \002(\0162\036.blox.compiler.gpu.OperatorTag\022,\n"
    "\007unionop\030\002 \001(\0132\033.blox.compiler.gpu.GPUUn"
    "ion\0228\n\014intersection\030\003 \001(\0132\".blox.compile"
    "r.gpu.GPUIntersection\022.\n\007product\030\004 \001(\0132\035"
    ".blox.compiler.gpu.GPUProduct\022,\n\006single\030"
    "\005 \001(\0132\034.blox.compiler.gpu.GPUSingle\0224\n\nd"
    "ifference\030\006 \001(\0132 .blox.compiler.gpu.GPUD"
    "ifference\022(\n\004join\030\007 \001(\0132\032.blox.compiler."
    "gpu.GPUJoin\0222\n\tmapfilter\030\n \001(\0132\037.blox.co"
    "mpiler.gpu.GPUMapFilter\022&\n\003agg\030\013 \001(\0132\031.b"
    "lox.compiler.gpu.GPUAgg\"E\n\tGPUAssign\022\014\n\004"
    "dest\030\001 \002(\t\022*\n\002op\030\002 \002(\0132\036.blox.compiler.g"
    "pu.GPUOperator\">\n\007GPUCond\022\014\n\004src1\030\001 \002(\t\022"
    "\014\n\004src2\030\002 \002(\t\022\013\n\003yes\030\003 \002(\005\022\n\n\002no\030\004 \002(\005\"\031"
    "\n\007GPUGoto\022\016\n\006target\030\001 \002(\005\"%\n\007GPUMove\022\014\n\004"
    "dest\030\001 \002(\t\022\014\n\004src1\030\002 \002(\t\"\362\001\n\nGPUCommand\022"
    "*\n\003tag\030\001 \002(\0162\035.blox.compiler.gpu.Command"
    "Tag\022,\n\006assign\030\002 \001(\0132\034.blox.compiler.gpu."
    "GPUAssign\022(\n\004cond\030\003 \001(\0132\032.blox.compiler."
    "gpu.GPUCond\022(\n\004jump\030\004 \001(\0132\032.blox.compile"
    "r.gpu.GPUGoto\022(\n\004move\030\005 \001(\0132\032.blox.compi"
    "ler.gpu.GPUMove\022\014\n\004halt\030\006 \001(\005\"y\n\007Address"
    "\022*\n\003tag\030\001 \002(\0162\035.blox.compiler.gpu.Addres"
    "sTag\022\017\n\007varaddr\030\002 \001(\005\0221\n\tconstaddr\030\003 \001(\013"
    "2\036.blox.common.protocol.Constant\"\312\001\n\nGPU"
    "Compare\0221\n\ncomparison\030\001 \002(\0162\035.blox.compi"
    "ler.gpu.Comparison\0223\n\006optype\030\002 \002(\0132#.blo"
    "x.common.protocol.PrimitiveType\022)\n\005addr1"
    "\030\003 \002(\0132\032.blox.compiler.gpu.Address\022)\n\005ad"
    "dr2\030\004 \002(\0132\032.blox.compiler.gpu.Address\"Y\n"
    "\013GPUSequence\022\030\n\020uniqueIdentifier\030\001 \002(\005\0220"
    "\n\toperators\030\002 \003(\0132\035.blox.compiler.gpu.GP"
    "UCommand\"@\n\007NumType\022\'\n\003typ\030\001 \002(\0162\032.blox."
    "compiler.gpu.Numeric\022\014\n\004size\030\002 \002(\005\"{\n\004Un"
    "iv\022\'\n\003tag\030\001 \002(\0162\032.blox.compiler.gpu.Univ"
    "Tag\022%\n\001n\030\002 \001(\0132\032.blox.compiler.gpu.NumTy"
    "pe\022#\n\001f\030\003 \001(\0162\030.blox.compiler.gpu.Fixed\""
    ";\n\010ConstExp\022/\n\007literal\030\001 \002(\0132\036.blox.comm"
    "on.protocol.Constant\"@\n\004Name\022\r\n\005ename\030\001 "
    "\002(\t\022)\n\005etype\030\002 \002(\0132\032.blox.common.protoco"
    "l.Type\"A\n\005Index\022\016\n\006offset\030\001 \002(\005\022(\n\004etyp\030"
    "\002 \002(\0132\032.blox.common.protocol.Type\"\257\001\n\010Ar"
    "ithExp\022*\n\006domain\030\001 \002(\0132\032.blox.compiler.g"
    "pu.NumType\022+\n\002op\030\002 \002(\0162\037.blox.compiler.g"
    "pu.ArithmeticOp\022$\n\004exp1\030\003 \002(\0132\026.blox.com"
    "piler.gpu.Exp\022$\n\004exp2\030\004 \002(\0132\026.blox.compi"
    "ler.gpu.Exp\"\203\001\n\007Convert\022(\n\007convDom\030\001 \002(\013"
    "2\027.blox.compiler.gpu.Univ\022(\n\007convRng\030\002 \002"
    "(\0132\027.blox.compiler.gpu.Univ\022$\n\004exp2\030\003 \002("
    "\0132\026.blox.compiler.gpu.Exp\"\204\001\n\005Mixed\022*\n\006d"
    "omain\030\001 \002(\0132\032.blox.compiler.gpu.NumType\022"
    ")\n\005range\030\002 \002(\0132\032.blox.compiler.gpu.NumTy"
    "pe\022$\n\004exp1\030\003 \002(\0132\026.blox.compiler.gpu.Exp"
    "\"j\n\004Call\022*\n\010calltype\030\001 \002(\0162\030.blox.compil"
    "er.gpu.Fixed\022\020\n\010callname\030\002 \002(\t\022$\n\004args\030\003"
    " \003(\0132\026.blox.compiler.gpu.Exp\"\330\002\n\003Exp\022&\n\003"
    "tag\030\001 \002(\0162\031.blox.compiler.gpu.ExpTag\022-\n\010"
    "constExp\030\002 \001(\0132\033.blox.compiler.gpu.Const"
    "Exp\022\'\n\005index\030\003 \001(\0132\030.blox.compiler.gpu.I"
    "ndex\022%\n\004name\030\004 \001(\0132\027.blox.compiler.gpu.N"
    "ame\022-\n\010arithexp\030\005 \001(\0132\033.blox.compiler.gp"
    "u.ArithExp\022+\n\007convert\030\006 \001(\0132\032.blox.compi"
    "ler.gpu.Convert\022\'\n\005mixed\030\007 \001(\0132\030.blox.co"
    "mpiler.gpu.Mixed\022%\n\004call\030\010 \001(\0132\027.blox.co"
    "mpiler.gpu.Call\"\203\001\n\004Comp\0221\n\ncomparison\030\001"
    " \002(\0162\035.blox.compiler.gpu.Comparison\022#\n\003o"
    "p1\030\002 \002(\0132\026.blox.compiler.gpu.Exp\022#\n\003op2\030"
    "\003 \002(\0132\026.blox.compiler.gpu.Exp\"i\n\004Test\022*\n"
    "\010testtype\030\001 \002(\0162\030.blox.compiler.gpu.Fixe"
    "d\022\020\n\010testname\030\002 \002(\t\022#\n\003ops\030\003 \003(\0132\026.blox."
    "compiler.gpu.Exp\"Y\n\003And\022(\n\004and1\030\001 \002(\0132\032."
    "blox.compiler.gpu.Compare\022(\n\004and2\030\002 \002(\0132"
    "\032.blox.compiler.gpu.Compare\"\254\001\n\007Compare\022"
    "*\n\003tag\030\001 \002(\0162\035.blox.compiler.gpu.Compare"
    "Tag\022%\n\004comp\030\002 \001(\0132\027.blox.compiler.gpu.Co"
    "mp\022%\n\004test\030\003 \001(\0132\027.blox.compiler.gpu.Tes"
    "t\022\'\n\007andComp\030\004 \001(\0132\026.blox.compiler.gpu.A"
    "nd\"\027\n\005Count\022\016\n\006aggrng\030\001 \002(\005\"\'\n\005Total\022\016\n\006"
    "aggdom\030\001 \002(\005\022\016\n\006aggrng\030\002 \002(\005\"%\n\003Min\022\016\n\006a"
    "ggdom\030\001 \002(\005\022\016\n\006aggrng\030\002 \002(\005\"%\n\003Max\022\016\n\006ag"
    "gdom\030\001 \002(\005\022\016\n\006aggrng\030\002 \002(\005\"\311\001\n\003Agg\022&\n\003ta"
    "g\030\001 \002(\0162\031.blox.compiler.gpu.AggTag\022\'\n\005co"
    "unt\030\002 \001(\0132\030.blox.compiler.gpu.Count\022\'\n\005t"
    "otal\030\003 \001(\0132\030.blox.compiler.gpu.Total\022#\n\003"
    "min\030\004 \001(\0132\026.blox.compiler.gpu.Min\022#\n\003max"
    "\030\005 \001(\0132\026.blox.compiler.gpu.Max*u\n\013Operat"
    "orTag\022\t\n\005UNION\020\002\022\020\n\014INTERSECTION\020\003\022\013\n\007PR"
    "ODUCT\020\004\022\n\n\006SINGLE\020\005\022\016\n\nDIFFERENCE\020\006\022\010\n\004J"
    "OIN\020\007\022\r\n\tMAPFILTER\020\n\022\007\n\003AGG\020\013*@\n\nCommand"
    "Tag\022\n\n\006ASSIGN\020\002\022\010\n\004COND\020\003\022\010\n\004GOTO\020\004\022\010\n\004M"
    "OVE\020\005\022\010\n\004HALT\020\006*<\n\nComparison\022\006\n\002Eq\020\000\022\006\n"
    "\002Ne\020\001\022\006\n\002Lt\020\002\022\006\n\002Le\020\003\022\006\n\002Gt\020\004\022\006\n\002Ge\020\005*(\n"
    "\nAddressTag\022\013\n\007VARADDR\020\002\022\r\n\tCONSTADDR\020\003*"
    "H\n\014ArithmeticOp\022\007\n\003Add\020\000\022\014\n\010Multiply\020\001\022\014"
    "\n\010Subtract\020\002\022\n\n\006Divide\020\003\022\007\n\003Mod\020\004*8\n\007Num"
    "eric\022\010\n\004NInt\020\000\022\t\n\005NUInt\020\001\022\n\n\006NFloat\020\002\022\014\n"
    "\010NDecimal\020\003*:\n\005Fixed\022\013\n\007FString\020\000\022\t\n\005FBo"
    "ol\020\001\022\r\n\tFDatetime\020\002\022\n\n\006FColor\020\003*\035\n\007UnivT"
    "ag\022\010\n\004Ntag\020\000\022\010\n\004Ftag\020\001*[\n\006ExpTag\022\014\n\010CONS"
    "TEXP\020\000\022\t\n\005INDEX\020\001\022\010\n\004NAME\020\002\022\014\n\010ARITHEXP\020"
    "\003\022\013\n\007CONVERT\020\004\022\t\n\005MIXED\020\005\022\010\n\004CALL\020\006*5\n\nC"
    "ompareTag\022\010\n\004COMP\020\000\022\010\n\004TEST\020\001\022\007\n\003AND\020\002\022\n"
    "\n\006ALWAYS\020\003*0\n\006AggTag\022\t\n\005COUNT\020\000\022\t\n\005TOTAL"
    "\020\001\022\007\n\003MIN\020\002\022\007\n\003MAX\020\003B.\n\035com.logicblox.co"
    "mmon.protocolB\013CommonProtoH\001", 5148);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "RelationalAlgebra.proto", &protobuf_RegisterTypes);
  GPUGraph::default_instance_ = new GPUGraph();
  GPUVariable::default_instance_ = new GPUVariable();
  GPUUnion::default_instance_ = new GPUUnion();
  GPUIntersection::default_instance_ = new GPUIntersection();
  GPUProduct::default_instance_ = new GPUProduct();
  GPUSingle::default_instance_ = new GPUSingle();
  GPUDifference::default_instance_ = new GPUDifference();
  GPUJoin::default_instance_ = new GPUJoin();
  GPUMapFilter::default_instance_ = new GPUMapFilter();
  GPUAgg::default_instance_ = new GPUAgg();
  GPUOperator::default_instance_ = new GPUOperator();
  GPUAssign::default_instance_ = new GPUAssign();
  GPUCond::default_instance_ = new GPUCond();
  GPUGoto::default_instance_ = new GPUGoto();
  GPUMove::default_instance_ = new GPUMove();
  GPUCommand::default_instance_ = new GPUCommand();
  Address::default_instance_ = new Address();
  GPUCompare::default_instance_ = new GPUCompare();
  GPUSequence::default_instance_ = new GPUSequence();
  NumType::default_instance_ = new NumType();
  Univ::default_instance_ = new Univ();
  ConstExp::default_instance_ = new ConstExp();
  Name::default_instance_ = new Name();
  Index::default_instance_ = new Index();
  ArithExp::default_instance_ = new ArithExp();
  Convert::default_instance_ = new Convert();
  Mixed::default_instance_ = new Mixed();
  Call::default_instance_ = new Call();
  Exp::default_instance_ = new Exp();
  Comp::default_instance_ = new Comp();
  Test::default_instance_ = new Test();
  And::default_instance_ = new And();
  Compare::default_instance_ = new Compare();
  Count::default_instance_ = new Count();
  Total::default_instance_ = new Total();
  Min::default_instance_ = new Min();
  Max::default_instance_ = new Max();
  Agg::default_instance_ = new Agg();
  GPUGraph::default_instance_->InitAsDefaultInstance();
  GPUVariable::default_instance_->InitAsDefaultInstance();
  GPUUnion::default_instance_->InitAsDefaultInstance();
  GPUIntersection::default_instance_->InitAsDefaultInstance();
  GPUProduct::default_instance_->InitAsDefaultInstance();
  GPUSingle::default_instance_->InitAsDefaultInstance();
  GPUDifference::default_instance_->InitAsDefaultInstance();
  GPUJoin::default_instance_->InitAsDefaultInstance();
  GPUMapFilter::default_instance_->InitAsDefaultInstance();
  GPUAgg::default_instance_->InitAsDefaultInstance();
  GPUOperator::default_instance_->InitAsDefaultInstance();
  GPUAssign::default_instance_->InitAsDefaultInstance();
  GPUCond::default_instance_->InitAsDefaultInstance();
  GPUGoto::default_instance_->InitAsDefaultInstance();
  GPUMove::default_instance_->InitAsDefaultInstance();
  GPUCommand::default_instance_->InitAsDefaultInstance();
  Address::default_instance_->InitAsDefaultInstance();
  GPUCompare::default_instance_->InitAsDefaultInstance();
  GPUSequence::default_instance_->InitAsDefaultInstance();
  NumType::default_instance_->InitAsDefaultInstance();
  Univ::default_instance_->InitAsDefaultInstance();
  ConstExp::default_instance_->InitAsDefaultInstance();
  Name::default_instance_->InitAsDefaultInstance();
  Index::default_instance_->InitAsDefaultInstance();
  ArithExp::default_instance_->InitAsDefaultInstance();
  Convert::default_instance_->InitAsDefaultInstance();
  Mixed::default_instance_->InitAsDefaultInstance();
  Call::default_instance_->InitAsDefaultInstance();
  Exp::default_instance_->InitAsDefaultInstance();
  Comp::default_instance_->InitAsDefaultInstance();
  Test::default_instance_->InitAsDefaultInstance();
  And::default_instance_->InitAsDefaultInstance();
  Compare::default_instance_->InitAsDefaultInstance();
  Count::default_instance_->InitAsDefaultInstance();
  Total::default_instance_->InitAsDefaultInstance();
  Min::default_instance_->InitAsDefaultInstance();
  Max::default_instance_->InitAsDefaultInstance();
  Agg::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_RelationalAlgebra_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_RelationalAlgebra_2eproto {
  StaticDescriptorInitializer_RelationalAlgebra_2eproto() {
    protobuf_AddDesc_RelationalAlgebra_2eproto();
  }
} static_descriptor_initializer_RelationalAlgebra_2eproto_;

const ::google::protobuf::EnumDescriptor* OperatorTag_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OperatorTag_descriptor_;
}
bool OperatorTag_IsValid(int value) {
  switch(value) {
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CommandTag_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CommandTag_descriptor_;
}
bool CommandTag_IsValid(int value) {
  switch(value) {
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Comparison_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Comparison_descriptor_;
}
bool Comparison_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* AddressTag_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AddressTag_descriptor_;
}
bool AddressTag_IsValid(int value) {
  switch(value) {
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ArithmeticOp_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ArithmeticOp_descriptor_;
}
bool ArithmeticOp_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Numeric_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Numeric_descriptor_;
}
bool Numeric_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Fixed_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Fixed_descriptor_;
}
bool Fixed_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* UnivTag_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnivTag_descriptor_;
}
bool UnivTag_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ExpTag_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExpTag_descriptor_;
}
bool ExpTag_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CompareTag_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CompareTag_descriptor_;
}
bool CompareTag_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* AggTag_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AggTag_descriptor_;
}
bool AggTag_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int GPUGraph::kGraphNameFieldNumber;
const int GPUGraph::kVariablesFieldNumber;
const int GPUGraph::kSequencesFieldNumber;
const int GPUGraph::kEntryFieldNumber;
const int GPUGraph::kExitFieldNumber;
#endif  // !_MSC_VER

GPUGraph::GPUGraph()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUGraph::InitAsDefaultInstance() {
}

GPUGraph::GPUGraph(const GPUGraph& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUGraph::SharedCtor() {
  _cached_size_ = 0;
  graphname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  entry_ = 0;
  exit_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUGraph::~GPUGraph() {
  SharedDtor();
}

void GPUGraph::SharedDtor() {
  if (graphname_ != &::google::protobuf::internal::kEmptyString) {
    delete graphname_;
  }
  if (this != default_instance_) {
  }
}

void GPUGraph::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUGraph::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUGraph_descriptor_;
}

const GPUGraph& GPUGraph::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUGraph* GPUGraph::default_instance_ = NULL;

GPUGraph* GPUGraph::New() const {
  return new GPUGraph;
}

void GPUGraph::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_graphname()) {
      if (graphname_ != &::google::protobuf::internal::kEmptyString) {
        graphname_->clear();
      }
    }
    entry_ = 0;
    exit_ = 0;
  }
  variables_.Clear();
  sequences_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUGraph::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string graphName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_graphname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->graphname().data(), this->graphname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_variables;
        break;
      }
      
      // repeated .blox.compiler.gpu.GPUVariable variables = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_variables:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_variables()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_variables;
        if (input->ExpectTag(26)) goto parse_sequences;
        break;
      }
      
      // repeated .blox.compiler.gpu.GPUSequence sequences = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sequences:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sequences()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sequences;
        if (input->ExpectTag(32)) goto parse_entry;
        break;
      }
      
      // required int32 entry = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_entry:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &entry_)));
          set_has_entry();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_exit;
        break;
      }
      
      // required int32 exit = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exit_)));
          set_has_exit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUGraph::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string graphName = 1;
  if (has_graphname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->graphname().data(), this->graphname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->graphname(), output);
  }
  
  // repeated .blox.compiler.gpu.GPUVariable variables = 2;
  for (int i = 0; i < this->variables_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->variables(i), output);
  }
  
  // repeated .blox.compiler.gpu.GPUSequence sequences = 3;
  for (int i = 0; i < this->sequences_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->sequences(i), output);
  }
  
  // required int32 entry = 4;
  if (has_entry()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->entry(), output);
  }
  
  // required int32 exit = 5;
  if (has_exit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->exit(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUGraph::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string graphName = 1;
  if (has_graphname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->graphname().data(), this->graphname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->graphname(), target);
  }
  
  // repeated .blox.compiler.gpu.GPUVariable variables = 2;
  for (int i = 0; i < this->variables_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->variables(i), target);
  }
  
  // repeated .blox.compiler.gpu.GPUSequence sequences = 3;
  for (int i = 0; i < this->sequences_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->sequences(i), target);
  }
  
  // required int32 entry = 4;
  if (has_entry()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->entry(), target);
  }
  
  // required int32 exit = 5;
  if (has_exit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->exit(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUGraph::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string graphName = 1;
    if (has_graphname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->graphname());
    }
    
    // required int32 entry = 4;
    if (has_entry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->entry());
    }
    
    // required int32 exit = 5;
    if (has_exit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exit());
    }
    
  }
  // repeated .blox.compiler.gpu.GPUVariable variables = 2;
  total_size += 1 * this->variables_size();
  for (int i = 0; i < this->variables_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->variables(i));
  }
  
  // repeated .blox.compiler.gpu.GPUSequence sequences = 3;
  total_size += 1 * this->sequences_size();
  for (int i = 0; i < this->sequences_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sequences(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUGraph::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUGraph* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUGraph*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUGraph::MergeFrom(const GPUGraph& from) {
  GOOGLE_CHECK_NE(&from, this);
  variables_.MergeFrom(from.variables_);
  sequences_.MergeFrom(from.sequences_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_graphname()) {
      set_graphname(from.graphname());
    }
    if (from.has_entry()) {
      set_entry(from.entry());
    }
    if (from.has_exit()) {
      set_exit(from.exit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUGraph::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUGraph::CopyFrom(const GPUGraph& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUGraph::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000019) != 0x00000019) return false;
  
  for (int i = 0; i < variables_size(); i++) {
    if (!this->variables(i).IsInitialized()) return false;
  }
  for (int i = 0; i < sequences_size(); i++) {
    if (!this->sequences(i).IsInitialized()) return false;
  }
  return true;
}

void GPUGraph::Swap(GPUGraph* other) {
  if (other != this) {
    std::swap(graphname_, other->graphname_);
    variables_.Swap(&other->variables_);
    sequences_.Swap(&other->sequences_);
    std::swap(entry_, other->entry_);
    std::swap(exit_, other->exit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUGraph::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUGraph_descriptor_;
  metadata.reflection = GPUGraph_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUVariable::kVarNameFieldNumber;
const int GPUVariable::kKeysFieldNumber;
const int GPUVariable::kFieldsFieldNumber;
const int GPUVariable::kInitialDataFieldNumber;
#endif  // !_MSC_VER

GPUVariable::GPUVariable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUVariable::InitAsDefaultInstance() {
}

GPUVariable::GPUVariable(const GPUVariable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUVariable::SharedCtor() {
  _cached_size_ = 0;
  varname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  initialdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUVariable::~GPUVariable() {
  SharedDtor();
}

void GPUVariable::SharedDtor() {
  if (varname_ != &::google::protobuf::internal::kEmptyString) {
    delete varname_;
  }
  if (initialdata_ != &::google::protobuf::internal::kEmptyString) {
    delete initialdata_;
  }
  if (this != default_instance_) {
  }
}

void GPUVariable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUVariable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUVariable_descriptor_;
}

const GPUVariable& GPUVariable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUVariable* GPUVariable::default_instance_ = NULL;

GPUVariable* GPUVariable::New() const {
  return new GPUVariable;
}

void GPUVariable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_varname()) {
      if (varname_ != &::google::protobuf::internal::kEmptyString) {
        varname_->clear();
      }
    }
    if (has_initialdata()) {
      if (initialdata_ != &::google::protobuf::internal::kEmptyString) {
        initialdata_->clear();
      }
    }
  }
  keys_.Clear();
  fields_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUVariable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string varName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_varname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->varname().data(), this->varname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_keys;
        break;
      }
      
      // repeated .blox.common.protocol.Type keys = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_keys()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_keys;
        if (input->ExpectTag(26)) goto parse_fields;
        break;
      }
      
      // repeated .blox.common.protocol.Type fields = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fields:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_fields()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_fields;
        if (input->ExpectTag(34)) goto parse_initialData;
        break;
      }
      
      // required bytes initialData = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_initialData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_initialdata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUVariable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string varName = 1;
  if (has_varname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->varname().data(), this->varname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->varname(), output);
  }
  
  // repeated .blox.common.protocol.Type keys = 2;
  for (int i = 0; i < this->keys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->keys(i), output);
  }
  
  // repeated .blox.common.protocol.Type fields = 3;
  for (int i = 0; i < this->fields_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->fields(i), output);
  }
  
  // required bytes initialData = 4;
  if (has_initialdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->initialdata(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUVariable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string varName = 1;
  if (has_varname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->varname().data(), this->varname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->varname(), target);
  }
  
  // repeated .blox.common.protocol.Type keys = 2;
  for (int i = 0; i < this->keys_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->keys(i), target);
  }
  
  // repeated .blox.common.protocol.Type fields = 3;
  for (int i = 0; i < this->fields_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->fields(i), target);
  }
  
  // required bytes initialData = 4;
  if (has_initialdata()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->initialdata(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUVariable::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string varName = 1;
    if (has_varname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->varname());
    }
    
    // required bytes initialData = 4;
    if (has_initialdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->initialdata());
    }
    
  }
  // repeated .blox.common.protocol.Type keys = 2;
  total_size += 1 * this->keys_size();
  for (int i = 0; i < this->keys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->keys(i));
  }
  
  // repeated .blox.common.protocol.Type fields = 3;
  total_size += 1 * this->fields_size();
  for (int i = 0; i < this->fields_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->fields(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUVariable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUVariable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUVariable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUVariable::MergeFrom(const GPUVariable& from) {
  GOOGLE_CHECK_NE(&from, this);
  keys_.MergeFrom(from.keys_);
  fields_.MergeFrom(from.fields_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_varname()) {
      set_varname(from.varname());
    }
    if (from.has_initialdata()) {
      set_initialdata(from.initialdata());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUVariable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUVariable::CopyFrom(const GPUVariable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUVariable::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;
  
  for (int i = 0; i < keys_size(); i++) {
    if (!this->keys(i).IsInitialized()) return false;
  }
  for (int i = 0; i < fields_size(); i++) {
    if (!this->fields(i).IsInitialized()) return false;
  }
  return true;
}

void GPUVariable::Swap(GPUVariable* other) {
  if (other != this) {
    std::swap(varname_, other->varname_);
    keys_.Swap(&other->keys_);
    fields_.Swap(&other->fields_);
    std::swap(initialdata_, other->initialdata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUVariable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUVariable_descriptor_;
  metadata.reflection = GPUVariable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUUnion::kSrcAFieldNumber;
const int GPUUnion::kSrcBFieldNumber;
#endif  // !_MSC_VER

GPUUnion::GPUUnion()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUUnion::InitAsDefaultInstance() {
}

GPUUnion::GPUUnion(const GPUUnion& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUUnion::SharedCtor() {
  _cached_size_ = 0;
  srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  srcb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUUnion::~GPUUnion() {
  SharedDtor();
}

void GPUUnion::SharedDtor() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    delete srca_;
  }
  if (srcb_ != &::google::protobuf::internal::kEmptyString) {
    delete srcb_;
  }
  if (this != default_instance_) {
  }
}

void GPUUnion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUUnion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUUnion_descriptor_;
}

const GPUUnion& GPUUnion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUUnion* GPUUnion::default_instance_ = NULL;

GPUUnion* GPUUnion::New() const {
  return new GPUUnion;
}

void GPUUnion::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_srca()) {
      if (srca_ != &::google::protobuf::internal::kEmptyString) {
        srca_->clear();
      }
    }
    if (has_srcb()) {
      if (srcb_ != &::google::protobuf::internal::kEmptyString) {
        srcb_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUUnion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string srcA = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_srca()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->srca().data(), this->srca().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_srcB;
        break;
      }
      
      // required string srcB = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_srcB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_srcb()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->srcb().data(), this->srcb().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUUnion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string srcA = 2;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->srca(), output);
  }
  
  // required string srcB = 3;
  if (has_srcb()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srcb().data(), this->srcb().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->srcb(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUUnion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string srcA = 2;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->srca(), target);
  }
  
  // required string srcB = 3;
  if (has_srcb()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srcb().data(), this->srcb().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->srcb(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUUnion::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string srcA = 2;
    if (has_srca()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->srca());
    }
    
    // required string srcB = 3;
    if (has_srcb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->srcb());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUUnion::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUUnion* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUUnion*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUUnion::MergeFrom(const GPUUnion& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_srca()) {
      set_srca(from.srca());
    }
    if (from.has_srcb()) {
      set_srcb(from.srcb());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUUnion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUUnion::CopyFrom(const GPUUnion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUUnion::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void GPUUnion::Swap(GPUUnion* other) {
  if (other != this) {
    std::swap(srca_, other->srca_);
    std::swap(srcb_, other->srcb_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUUnion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUUnion_descriptor_;
  metadata.reflection = GPUUnion_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUIntersection::kSrcAFieldNumber;
const int GPUIntersection::kSrcBFieldNumber;
#endif  // !_MSC_VER

GPUIntersection::GPUIntersection()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUIntersection::InitAsDefaultInstance() {
}

GPUIntersection::GPUIntersection(const GPUIntersection& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUIntersection::SharedCtor() {
  _cached_size_ = 0;
  srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  srcb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUIntersection::~GPUIntersection() {
  SharedDtor();
}

void GPUIntersection::SharedDtor() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    delete srca_;
  }
  if (srcb_ != &::google::protobuf::internal::kEmptyString) {
    delete srcb_;
  }
  if (this != default_instance_) {
  }
}

void GPUIntersection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUIntersection::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUIntersection_descriptor_;
}

const GPUIntersection& GPUIntersection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUIntersection* GPUIntersection::default_instance_ = NULL;

GPUIntersection* GPUIntersection::New() const {
  return new GPUIntersection;
}

void GPUIntersection::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_srca()) {
      if (srca_ != &::google::protobuf::internal::kEmptyString) {
        srca_->clear();
      }
    }
    if (has_srcb()) {
      if (srcb_ != &::google::protobuf::internal::kEmptyString) {
        srcb_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUIntersection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string srcA = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_srca()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->srca().data(), this->srca().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_srcB;
        break;
      }
      
      // required string srcB = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_srcB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_srcb()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->srcb().data(), this->srcb().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUIntersection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string srcA = 2;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->srca(), output);
  }
  
  // required string srcB = 3;
  if (has_srcb()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srcb().data(), this->srcb().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->srcb(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUIntersection::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string srcA = 2;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->srca(), target);
  }
  
  // required string srcB = 3;
  if (has_srcb()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srcb().data(), this->srcb().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->srcb(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUIntersection::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string srcA = 2;
    if (has_srca()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->srca());
    }
    
    // required string srcB = 3;
    if (has_srcb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->srcb());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUIntersection::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUIntersection* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUIntersection*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUIntersection::MergeFrom(const GPUIntersection& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_srca()) {
      set_srca(from.srca());
    }
    if (from.has_srcb()) {
      set_srcb(from.srcb());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUIntersection::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUIntersection::CopyFrom(const GPUIntersection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUIntersection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void GPUIntersection::Swap(GPUIntersection* other) {
  if (other != this) {
    std::swap(srca_, other->srca_);
    std::swap(srcb_, other->srcb_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUIntersection::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUIntersection_descriptor_;
  metadata.reflection = GPUIntersection_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUProduct::kSrcAFieldNumber;
const int GPUProduct::kSrcBFieldNumber;
#endif  // !_MSC_VER

GPUProduct::GPUProduct()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUProduct::InitAsDefaultInstance() {
}

GPUProduct::GPUProduct(const GPUProduct& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUProduct::SharedCtor() {
  _cached_size_ = 0;
  srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  srcb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUProduct::~GPUProduct() {
  SharedDtor();
}

void GPUProduct::SharedDtor() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    delete srca_;
  }
  if (srcb_ != &::google::protobuf::internal::kEmptyString) {
    delete srcb_;
  }
  if (this != default_instance_) {
  }
}

void GPUProduct::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUProduct::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUProduct_descriptor_;
}

const GPUProduct& GPUProduct::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUProduct* GPUProduct::default_instance_ = NULL;

GPUProduct* GPUProduct::New() const {
  return new GPUProduct;
}

void GPUProduct::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_srca()) {
      if (srca_ != &::google::protobuf::internal::kEmptyString) {
        srca_->clear();
      }
    }
    if (has_srcb()) {
      if (srcb_ != &::google::protobuf::internal::kEmptyString) {
        srcb_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUProduct::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string srcA = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_srca()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->srca().data(), this->srca().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_srcB;
        break;
      }
      
      // required string srcB = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_srcB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_srcb()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->srcb().data(), this->srcb().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUProduct::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string srcA = 2;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->srca(), output);
  }
  
  // required string srcB = 3;
  if (has_srcb()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srcb().data(), this->srcb().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->srcb(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUProduct::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string srcA = 2;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->srca(), target);
  }
  
  // required string srcB = 3;
  if (has_srcb()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srcb().data(), this->srcb().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->srcb(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUProduct::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string srcA = 2;
    if (has_srca()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->srca());
    }
    
    // required string srcB = 3;
    if (has_srcb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->srcb());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUProduct::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUProduct* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUProduct*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUProduct::MergeFrom(const GPUProduct& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_srca()) {
      set_srca(from.srca());
    }
    if (from.has_srcb()) {
      set_srcb(from.srcb());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUProduct::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUProduct::CopyFrom(const GPUProduct& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUProduct::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void GPUProduct::Swap(GPUProduct* other) {
  if (other != this) {
    std::swap(srca_, other->srca_);
    std::swap(srcb_, other->srcb_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUProduct::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUProduct_descriptor_;
  metadata.reflection = GPUProduct_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUSingle::kElementFieldNumber;
#endif  // !_MSC_VER

GPUSingle::GPUSingle()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUSingle::InitAsDefaultInstance() {
}

GPUSingle::GPUSingle(const GPUSingle& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUSingle::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUSingle::~GPUSingle() {
  SharedDtor();
}

void GPUSingle::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GPUSingle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUSingle::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUSingle_descriptor_;
}

const GPUSingle& GPUSingle::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUSingle* GPUSingle::default_instance_ = NULL;

GPUSingle* GPUSingle::New() const {
  return new GPUSingle;
}

void GPUSingle::Clear() {
  element_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUSingle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .blox.common.protocol.Constant element = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_element:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_element()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_element;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUSingle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .blox.common.protocol.Constant element = 1;
  for (int i = 0; i < this->element_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->element(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUSingle::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .blox.common.protocol.Constant element = 1;
  for (int i = 0; i < this->element_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->element(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUSingle::ByteSize() const {
  int total_size = 0;
  
  // repeated .blox.common.protocol.Constant element = 1;
  total_size += 1 * this->element_size();
  for (int i = 0; i < this->element_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->element(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUSingle::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUSingle* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUSingle*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUSingle::MergeFrom(const GPUSingle& from) {
  GOOGLE_CHECK_NE(&from, this);
  element_.MergeFrom(from.element_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUSingle::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUSingle::CopyFrom(const GPUSingle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUSingle::IsInitialized() const {
  
  for (int i = 0; i < element_size(); i++) {
    if (!this->element(i).IsInitialized()) return false;
  }
  return true;
}

void GPUSingle::Swap(GPUSingle* other) {
  if (other != this) {
    element_.Swap(&other->element_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUSingle::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUSingle_descriptor_;
  metadata.reflection = GPUSingle_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUDifference::kSrcAFieldNumber;
const int GPUDifference::kSrcBFieldNumber;
#endif  // !_MSC_VER

GPUDifference::GPUDifference()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUDifference::InitAsDefaultInstance() {
}

GPUDifference::GPUDifference(const GPUDifference& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUDifference::SharedCtor() {
  _cached_size_ = 0;
  srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  srcb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUDifference::~GPUDifference() {
  SharedDtor();
}

void GPUDifference::SharedDtor() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    delete srca_;
  }
  if (srcb_ != &::google::protobuf::internal::kEmptyString) {
    delete srcb_;
  }
  if (this != default_instance_) {
  }
}

void GPUDifference::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUDifference::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUDifference_descriptor_;
}

const GPUDifference& GPUDifference::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUDifference* GPUDifference::default_instance_ = NULL;

GPUDifference* GPUDifference::New() const {
  return new GPUDifference;
}

void GPUDifference::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_srca()) {
      if (srca_ != &::google::protobuf::internal::kEmptyString) {
        srca_->clear();
      }
    }
    if (has_srcb()) {
      if (srcb_ != &::google::protobuf::internal::kEmptyString) {
        srcb_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUDifference::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string srcA = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_srca()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->srca().data(), this->srca().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_srcB;
        break;
      }
      
      // required string srcB = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_srcB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_srcb()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->srcb().data(), this->srcb().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUDifference::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string srcA = 3;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->srca(), output);
  }
  
  // required string srcB = 4;
  if (has_srcb()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srcb().data(), this->srcb().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->srcb(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUDifference::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string srcA = 3;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->srca(), target);
  }
  
  // required string srcB = 4;
  if (has_srcb()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srcb().data(), this->srcb().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->srcb(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUDifference::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string srcA = 3;
    if (has_srca()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->srca());
    }
    
    // required string srcB = 4;
    if (has_srcb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->srcb());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUDifference::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUDifference* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUDifference*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUDifference::MergeFrom(const GPUDifference& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_srca()) {
      set_srca(from.srca());
    }
    if (from.has_srcb()) {
      set_srcb(from.srcb());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUDifference::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUDifference::CopyFrom(const GPUDifference& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUDifference::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void GPUDifference::Swap(GPUDifference* other) {
  if (other != this) {
    std::swap(srca_, other->srca_);
    std::swap(srcb_, other->srcb_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUDifference::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUDifference_descriptor_;
  metadata.reflection = GPUDifference_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUJoin::kKeyCountFieldNumber;
const int GPUJoin::kSrcAFieldNumber;
const int GPUJoin::kSrcBFieldNumber;
const int GPUJoin::kArgsFieldNumber;
#endif  // !_MSC_VER

GPUJoin::GPUJoin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUJoin::InitAsDefaultInstance() {
}

GPUJoin::GPUJoin(const GPUJoin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUJoin::SharedCtor() {
  _cached_size_ = 0;
  keycount_ = 0;
  srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  srcb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUJoin::~GPUJoin() {
  SharedDtor();
}

void GPUJoin::SharedDtor() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    delete srca_;
  }
  if (srcb_ != &::google::protobuf::internal::kEmptyString) {
    delete srcb_;
  }
  if (this != default_instance_) {
  }
}

void GPUJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUJoin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUJoin_descriptor_;
}

const GPUJoin& GPUJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUJoin* GPUJoin::default_instance_ = NULL;

GPUJoin* GPUJoin::New() const {
  return new GPUJoin;
}

void GPUJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    keycount_ = 0;
    if (has_srca()) {
      if (srca_ != &::google::protobuf::internal::kEmptyString) {
        srca_->clear();
      }
    }
    if (has_srcb()) {
      if (srcb_ != &::google::protobuf::internal::kEmptyString) {
        srcb_->clear();
      }
    }
  }
  args_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 keyCount = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &keycount_)));
          set_has_keycount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_srcA;
        break;
      }
      
      // required string srcA = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_srcA:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_srca()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->srca().data(), this->srca().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_srcB;
        break;
      }
      
      // required string srcB = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_srcB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_srcb()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->srcb().data(), this->srcb().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_args;
        break;
      }
      
      // repeated .blox.compiler.gpu.Exp args = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_args()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_args;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 keyCount = 2;
  if (has_keycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->keycount(), output);
  }
  
  // required string srcA = 3;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->srca(), output);
  }
  
  // required string srcB = 4;
  if (has_srcb()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srcb().data(), this->srcb().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->srcb(), output);
  }
  
  // repeated .blox.compiler.gpu.Exp args = 5;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->args(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUJoin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 keyCount = 2;
  if (has_keycount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->keycount(), target);
  }
  
  // required string srcA = 3;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->srca(), target);
  }
  
  // required string srcB = 4;
  if (has_srcb()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srcb().data(), this->srcb().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->srcb(), target);
  }
  
  // repeated .blox.compiler.gpu.Exp args = 5;
  for (int i = 0; i < this->args_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->args(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUJoin::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 keyCount = 2;
    if (has_keycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->keycount());
    }
    
    // required string srcA = 3;
    if (has_srca()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->srca());
    }
    
    // required string srcB = 4;
    if (has_srcb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->srcb());
    }
    
  }
  // repeated .blox.compiler.gpu.Exp args = 5;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->args(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUJoin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUJoin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUJoin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUJoin::MergeFrom(const GPUJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  args_.MergeFrom(from.args_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keycount()) {
      set_keycount(from.keycount());
    }
    if (from.has_srca()) {
      set_srca(from.srca());
    }
    if (from.has_srcb()) {
      set_srcb(from.srcb());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUJoin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUJoin::CopyFrom(const GPUJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  for (int i = 0; i < args_size(); i++) {
    if (!this->args(i).IsInitialized()) return false;
  }
  return true;
}

void GPUJoin::Swap(GPUJoin* other) {
  if (other != this) {
    std::swap(keycount_, other->keycount_);
    std::swap(srca_, other->srca_);
    std::swap(srcb_, other->srcb_);
    args_.Swap(&other->args_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUJoin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUJoin_descriptor_;
  metadata.reflection = GPUJoin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUMapFilter::kSrcWidthFieldNumber;
const int GPUMapFilter::kPredicateFieldNumber;
const int GPUMapFilter::kReorderingFieldNumber;
const int GPUMapFilter::kSrcAFieldNumber;
#endif  // !_MSC_VER

GPUMapFilter::GPUMapFilter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUMapFilter::InitAsDefaultInstance() {
  predicate_ = const_cast< ::blox::compiler::gpu::Compare*>(&::blox::compiler::gpu::Compare::default_instance());
}

GPUMapFilter::GPUMapFilter(const GPUMapFilter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUMapFilter::SharedCtor() {
  _cached_size_ = 0;
  srcwidth_ = 0;
  predicate_ = NULL;
  srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUMapFilter::~GPUMapFilter() {
  SharedDtor();
}

void GPUMapFilter::SharedDtor() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    delete srca_;
  }
  if (this != default_instance_) {
    delete predicate_;
  }
}

void GPUMapFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUMapFilter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUMapFilter_descriptor_;
}

const GPUMapFilter& GPUMapFilter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUMapFilter* GPUMapFilter::default_instance_ = NULL;

GPUMapFilter* GPUMapFilter::New() const {
  return new GPUMapFilter;
}

void GPUMapFilter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    srcwidth_ = 0;
    if (has_predicate()) {
      if (predicate_ != NULL) predicate_->::blox::compiler::gpu::Compare::Clear();
    }
    if (has_srca()) {
      if (srca_ != &::google::protobuf::internal::kEmptyString) {
        srca_->clear();
      }
    }
  }
  reordering_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUMapFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 srcWidth = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &srcwidth_)));
          set_has_srcwidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_predicate;
        break;
      }
      
      // required .blox.compiler.gpu.Compare predicate = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_predicate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_predicate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_reordering;
        break;
      }
      
      // repeated .blox.compiler.gpu.Exp reordering = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reordering:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_reordering()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_reordering;
        if (input->ExpectTag(42)) goto parse_srcA;
        break;
      }
      
      // required string srcA = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_srcA:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_srca()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->srca().data(), this->srca().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUMapFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 srcWidth = 2;
  if (has_srcwidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->srcwidth(), output);
  }
  
  // required .blox.compiler.gpu.Compare predicate = 3;
  if (has_predicate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->predicate(), output);
  }
  
  // repeated .blox.compiler.gpu.Exp reordering = 4;
  for (int i = 0; i < this->reordering_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->reordering(i), output);
  }
  
  // required string srcA = 5;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->srca(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUMapFilter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 srcWidth = 2;
  if (has_srcwidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->srcwidth(), target);
  }
  
  // required .blox.compiler.gpu.Compare predicate = 3;
  if (has_predicate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->predicate(), target);
  }
  
  // repeated .blox.compiler.gpu.Exp reordering = 4;
  for (int i = 0; i < this->reordering_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->reordering(i), target);
  }
  
  // required string srcA = 5;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->srca(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUMapFilter::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 srcWidth = 2;
    if (has_srcwidth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->srcwidth());
    }
    
    // required .blox.compiler.gpu.Compare predicate = 3;
    if (has_predicate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->predicate());
    }
    
    // required string srcA = 5;
    if (has_srca()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->srca());
    }
    
  }
  // repeated .blox.compiler.gpu.Exp reordering = 4;
  total_size += 1 * this->reordering_size();
  for (int i = 0; i < this->reordering_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->reordering(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUMapFilter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUMapFilter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUMapFilter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUMapFilter::MergeFrom(const GPUMapFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  reordering_.MergeFrom(from.reordering_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_srcwidth()) {
      set_srcwidth(from.srcwidth());
    }
    if (from.has_predicate()) {
      mutable_predicate()->::blox::compiler::gpu::Compare::MergeFrom(from.predicate());
    }
    if (from.has_srca()) {
      set_srca(from.srca());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUMapFilter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUMapFilter::CopyFrom(const GPUMapFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUMapFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;
  
  if (has_predicate()) {
    if (!this->predicate().IsInitialized()) return false;
  }
  for (int i = 0; i < reordering_size(); i++) {
    if (!this->reordering(i).IsInitialized()) return false;
  }
  return true;
}

void GPUMapFilter::Swap(GPUMapFilter* other) {
  if (other != this) {
    std::swap(srcwidth_, other->srcwidth_);
    std::swap(predicate_, other->predicate_);
    reordering_.Swap(&other->reordering_);
    std::swap(srca_, other->srca_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUMapFilter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUMapFilter_descriptor_;
  metadata.reflection = GPUMapFilter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUAgg::kSrcWidthFieldNumber;
const int GPUAgg::kDomainsFieldNumber;
const int GPUAgg::kRangeFieldNumber;
const int GPUAgg::kSrcAFieldNumber;
#endif  // !_MSC_VER

GPUAgg::GPUAgg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUAgg::InitAsDefaultInstance() {
}

GPUAgg::GPUAgg(const GPUAgg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUAgg::SharedCtor() {
  _cached_size_ = 0;
  srcwidth_ = 0;
  srca_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUAgg::~GPUAgg() {
  SharedDtor();
}

void GPUAgg::SharedDtor() {
  if (srca_ != &::google::protobuf::internal::kEmptyString) {
    delete srca_;
  }
  if (this != default_instance_) {
  }
}

void GPUAgg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUAgg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUAgg_descriptor_;
}

const GPUAgg& GPUAgg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUAgg* GPUAgg::default_instance_ = NULL;

GPUAgg* GPUAgg::New() const {
  return new GPUAgg;
}

void GPUAgg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    srcwidth_ = 0;
    if (has_srca()) {
      if (srca_ != &::google::protobuf::internal::kEmptyString) {
        srca_->clear();
      }
    }
  }
  domains_.Clear();
  range_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUAgg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 srcWidth = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &srcwidth_)));
          set_has_srcwidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_domains;
        break;
      }
      
      // repeated int32 domains = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_domains:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_domains())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_domains())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_domains;
        if (input->ExpectTag(34)) goto parse_range;
        break;
      }
      
      // repeated .blox.compiler.gpu.Agg range = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_range()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_range;
        if (input->ExpectTag(42)) goto parse_srcA;
        break;
      }
      
      // required string srcA = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_srcA:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_srca()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->srca().data(), this->srca().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUAgg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 srcWidth = 2;
  if (has_srcwidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->srcwidth(), output);
  }
  
  // repeated int32 domains = 3;
  for (int i = 0; i < this->domains_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->domains(i), output);
  }
  
  // repeated .blox.compiler.gpu.Agg range = 4;
  for (int i = 0; i < this->range_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->range(i), output);
  }
  
  // required string srcA = 5;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->srca(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUAgg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 srcWidth = 2;
  if (has_srcwidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->srcwidth(), target);
  }
  
  // repeated int32 domains = 3;
  for (int i = 0; i < this->domains_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->domains(i), target);
  }
  
  // repeated .blox.compiler.gpu.Agg range = 4;
  for (int i = 0; i < this->range_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->range(i), target);
  }
  
  // required string srcA = 5;
  if (has_srca()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->srca().data(), this->srca().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->srca(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUAgg::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 srcWidth = 2;
    if (has_srcwidth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->srcwidth());
    }
    
    // required string srcA = 5;
    if (has_srca()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->srca());
    }
    
  }
  // repeated int32 domains = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->domains_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->domains(i));
    }
    total_size += 1 * this->domains_size() + data_size;
  }
  
  // repeated .blox.compiler.gpu.Agg range = 4;
  total_size += 1 * this->range_size();
  for (int i = 0; i < this->range_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->range(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUAgg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUAgg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUAgg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUAgg::MergeFrom(const GPUAgg& from) {
  GOOGLE_CHECK_NE(&from, this);
  domains_.MergeFrom(from.domains_);
  range_.MergeFrom(from.range_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_srcwidth()) {
      set_srcwidth(from.srcwidth());
    }
    if (from.has_srca()) {
      set_srca(from.srca());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUAgg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUAgg::CopyFrom(const GPUAgg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUAgg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;
  
  for (int i = 0; i < range_size(); i++) {
    if (!this->range(i).IsInitialized()) return false;
  }
  return true;
}

void GPUAgg::Swap(GPUAgg* other) {
  if (other != this) {
    std::swap(srcwidth_, other->srcwidth_);
    domains_.Swap(&other->domains_);
    range_.Swap(&other->range_);
    std::swap(srca_, other->srca_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUAgg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUAgg_descriptor_;
  metadata.reflection = GPUAgg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUOperator::kTagFieldNumber;
const int GPUOperator::kUnionopFieldNumber;
const int GPUOperator::kIntersectionFieldNumber;
const int GPUOperator::kProductFieldNumber;
const int GPUOperator::kSingleFieldNumber;
const int GPUOperator::kDifferenceFieldNumber;
const int GPUOperator::kJoinFieldNumber;
const int GPUOperator::kMapfilterFieldNumber;
const int GPUOperator::kAggFieldNumber;
#endif  // !_MSC_VER

GPUOperator::GPUOperator()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUOperator::InitAsDefaultInstance() {
  unionop_ = const_cast< ::blox::compiler::gpu::GPUUnion*>(&::blox::compiler::gpu::GPUUnion::default_instance());
  intersection_ = const_cast< ::blox::compiler::gpu::GPUIntersection*>(&::blox::compiler::gpu::GPUIntersection::default_instance());
  product_ = const_cast< ::blox::compiler::gpu::GPUProduct*>(&::blox::compiler::gpu::GPUProduct::default_instance());
  single_ = const_cast< ::blox::compiler::gpu::GPUSingle*>(&::blox::compiler::gpu::GPUSingle::default_instance());
  difference_ = const_cast< ::blox::compiler::gpu::GPUDifference*>(&::blox::compiler::gpu::GPUDifference::default_instance());
  join_ = const_cast< ::blox::compiler::gpu::GPUJoin*>(&::blox::compiler::gpu::GPUJoin::default_instance());
  mapfilter_ = const_cast< ::blox::compiler::gpu::GPUMapFilter*>(&::blox::compiler::gpu::GPUMapFilter::default_instance());
  agg_ = const_cast< ::blox::compiler::gpu::GPUAgg*>(&::blox::compiler::gpu::GPUAgg::default_instance());
}

GPUOperator::GPUOperator(const GPUOperator& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUOperator::SharedCtor() {
  _cached_size_ = 0;
  tag_ = 2;
  unionop_ = NULL;
  intersection_ = NULL;
  product_ = NULL;
  single_ = NULL;
  difference_ = NULL;
  join_ = NULL;
  mapfilter_ = NULL;
  agg_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUOperator::~GPUOperator() {
  SharedDtor();
}

void GPUOperator::SharedDtor() {
  if (this != default_instance_) {
    delete unionop_;
    delete intersection_;
    delete product_;
    delete single_;
    delete difference_;
    delete join_;
    delete mapfilter_;
    delete agg_;
  }
}

void GPUOperator::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUOperator::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUOperator_descriptor_;
}

const GPUOperator& GPUOperator::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUOperator* GPUOperator::default_instance_ = NULL;

GPUOperator* GPUOperator::New() const {
  return new GPUOperator;
}

void GPUOperator::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tag_ = 2;
    if (has_unionop()) {
      if (unionop_ != NULL) unionop_->::blox::compiler::gpu::GPUUnion::Clear();
    }
    if (has_intersection()) {
      if (intersection_ != NULL) intersection_->::blox::compiler::gpu::GPUIntersection::Clear();
    }
    if (has_product()) {
      if (product_ != NULL) product_->::blox::compiler::gpu::GPUProduct::Clear();
    }
    if (has_single()) {
      if (single_ != NULL) single_->::blox::compiler::gpu::GPUSingle::Clear();
    }
    if (has_difference()) {
      if (difference_ != NULL) difference_->::blox::compiler::gpu::GPUDifference::Clear();
    }
    if (has_join()) {
      if (join_ != NULL) join_->::blox::compiler::gpu::GPUJoin::Clear();
    }
    if (has_mapfilter()) {
      if (mapfilter_ != NULL) mapfilter_->::blox::compiler::gpu::GPUMapFilter::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_agg()) {
      if (agg_ != NULL) agg_->::blox::compiler::gpu::GPUAgg::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUOperator::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.OperatorTag tag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::OperatorTag_IsValid(value)) {
            set_tag(static_cast< blox::compiler::gpu::OperatorTag >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_unionop;
        break;
      }
      
      // optional .blox.compiler.gpu.GPUUnion unionop = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_unionop:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unionop()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_intersection;
        break;
      }
      
      // optional .blox.compiler.gpu.GPUIntersection intersection = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_intersection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_intersection()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_product;
        break;
      }
      
      // optional .blox.compiler.gpu.GPUProduct product = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_product:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_product()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_single;
        break;
      }
      
      // optional .blox.compiler.gpu.GPUSingle single = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_single:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_single()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_difference;
        break;
      }
      
      // optional .blox.compiler.gpu.GPUDifference difference = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_difference:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_difference()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_join;
        break;
      }
      
      // optional .blox.compiler.gpu.GPUJoin join = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_join:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_join()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_mapfilter;
        break;
      }
      
      // optional .blox.compiler.gpu.GPUMapFilter mapfilter = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mapfilter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mapfilter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_agg;
        break;
      }
      
      // optional .blox.compiler.gpu.GPUAgg agg = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_agg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUOperator::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.OperatorTag tag = 1;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->tag(), output);
  }
  
  // optional .blox.compiler.gpu.GPUUnion unionop = 2;
  if (has_unionop()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->unionop(), output);
  }
  
  // optional .blox.compiler.gpu.GPUIntersection intersection = 3;
  if (has_intersection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->intersection(), output);
  }
  
  // optional .blox.compiler.gpu.GPUProduct product = 4;
  if (has_product()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->product(), output);
  }
  
  // optional .blox.compiler.gpu.GPUSingle single = 5;
  if (has_single()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->single(), output);
  }
  
  // optional .blox.compiler.gpu.GPUDifference difference = 6;
  if (has_difference()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->difference(), output);
  }
  
  // optional .blox.compiler.gpu.GPUJoin join = 7;
  if (has_join()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->join(), output);
  }
  
  // optional .blox.compiler.gpu.GPUMapFilter mapfilter = 10;
  if (has_mapfilter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->mapfilter(), output);
  }
  
  // optional .blox.compiler.gpu.GPUAgg agg = 11;
  if (has_agg()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->agg(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUOperator::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.OperatorTag tag = 1;
  if (has_tag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->tag(), target);
  }
  
  // optional .blox.compiler.gpu.GPUUnion unionop = 2;
  if (has_unionop()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->unionop(), target);
  }
  
  // optional .blox.compiler.gpu.GPUIntersection intersection = 3;
  if (has_intersection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->intersection(), target);
  }
  
  // optional .blox.compiler.gpu.GPUProduct product = 4;
  if (has_product()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->product(), target);
  }
  
  // optional .blox.compiler.gpu.GPUSingle single = 5;
  if (has_single()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->single(), target);
  }
  
  // optional .blox.compiler.gpu.GPUDifference difference = 6;
  if (has_difference()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->difference(), target);
  }
  
  // optional .blox.compiler.gpu.GPUJoin join = 7;
  if (has_join()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->join(), target);
  }
  
  // optional .blox.compiler.gpu.GPUMapFilter mapfilter = 10;
  if (has_mapfilter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->mapfilter(), target);
  }
  
  // optional .blox.compiler.gpu.GPUAgg agg = 11;
  if (has_agg()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->agg(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUOperator::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.OperatorTag tag = 1;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->tag());
    }
    
    // optional .blox.compiler.gpu.GPUUnion unionop = 2;
    if (has_unionop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->unionop());
    }
    
    // optional .blox.compiler.gpu.GPUIntersection intersection = 3;
    if (has_intersection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->intersection());
    }
    
    // optional .blox.compiler.gpu.GPUProduct product = 4;
    if (has_product()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->product());
    }
    
    // optional .blox.compiler.gpu.GPUSingle single = 5;
    if (has_single()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->single());
    }
    
    // optional .blox.compiler.gpu.GPUDifference difference = 6;
    if (has_difference()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->difference());
    }
    
    // optional .blox.compiler.gpu.GPUJoin join = 7;
    if (has_join()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->join());
    }
    
    // optional .blox.compiler.gpu.GPUMapFilter mapfilter = 10;
    if (has_mapfilter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mapfilter());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .blox.compiler.gpu.GPUAgg agg = 11;
    if (has_agg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agg());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUOperator::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUOperator* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUOperator*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUOperator::MergeFrom(const GPUOperator& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tag()) {
      set_tag(from.tag());
    }
    if (from.has_unionop()) {
      mutable_unionop()->::blox::compiler::gpu::GPUUnion::MergeFrom(from.unionop());
    }
    if (from.has_intersection()) {
      mutable_intersection()->::blox::compiler::gpu::GPUIntersection::MergeFrom(from.intersection());
    }
    if (from.has_product()) {
      mutable_product()->::blox::compiler::gpu::GPUProduct::MergeFrom(from.product());
    }
    if (from.has_single()) {
      mutable_single()->::blox::compiler::gpu::GPUSingle::MergeFrom(from.single());
    }
    if (from.has_difference()) {
      mutable_difference()->::blox::compiler::gpu::GPUDifference::MergeFrom(from.difference());
    }
    if (from.has_join()) {
      mutable_join()->::blox::compiler::gpu::GPUJoin::MergeFrom(from.join());
    }
    if (from.has_mapfilter()) {
      mutable_mapfilter()->::blox::compiler::gpu::GPUMapFilter::MergeFrom(from.mapfilter());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_agg()) {
      mutable_agg()->::blox::compiler::gpu::GPUAgg::MergeFrom(from.agg());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUOperator::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUOperator::CopyFrom(const GPUOperator& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUOperator::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_unionop()) {
    if (!this->unionop().IsInitialized()) return false;
  }
  if (has_intersection()) {
    if (!this->intersection().IsInitialized()) return false;
  }
  if (has_product()) {
    if (!this->product().IsInitialized()) return false;
  }
  if (has_single()) {
    if (!this->single().IsInitialized()) return false;
  }
  if (has_difference()) {
    if (!this->difference().IsInitialized()) return false;
  }
  if (has_join()) {
    if (!this->join().IsInitialized()) return false;
  }
  if (has_mapfilter()) {
    if (!this->mapfilter().IsInitialized()) return false;
  }
  if (has_agg()) {
    if (!this->agg().IsInitialized()) return false;
  }
  return true;
}

void GPUOperator::Swap(GPUOperator* other) {
  if (other != this) {
    std::swap(tag_, other->tag_);
    std::swap(unionop_, other->unionop_);
    std::swap(intersection_, other->intersection_);
    std::swap(product_, other->product_);
    std::swap(single_, other->single_);
    std::swap(difference_, other->difference_);
    std::swap(join_, other->join_);
    std::swap(mapfilter_, other->mapfilter_);
    std::swap(agg_, other->agg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUOperator::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUOperator_descriptor_;
  metadata.reflection = GPUOperator_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUAssign::kDestFieldNumber;
const int GPUAssign::kOpFieldNumber;
#endif  // !_MSC_VER

GPUAssign::GPUAssign()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUAssign::InitAsDefaultInstance() {
  op_ = const_cast< ::blox::compiler::gpu::GPUOperator*>(&::blox::compiler::gpu::GPUOperator::default_instance());
}

GPUAssign::GPUAssign(const GPUAssign& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUAssign::SharedCtor() {
  _cached_size_ = 0;
  dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  op_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUAssign::~GPUAssign() {
  SharedDtor();
}

void GPUAssign::SharedDtor() {
  if (dest_ != &::google::protobuf::internal::kEmptyString) {
    delete dest_;
  }
  if (this != default_instance_) {
    delete op_;
  }
}

void GPUAssign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUAssign::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUAssign_descriptor_;
}

const GPUAssign& GPUAssign::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUAssign* GPUAssign::default_instance_ = NULL;

GPUAssign* GPUAssign::New() const {
  return new GPUAssign;
}

void GPUAssign::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_dest()) {
      if (dest_ != &::google::protobuf::internal::kEmptyString) {
        dest_->clear();
      }
    }
    if (has_op()) {
      if (op_ != NULL) op_->::blox::compiler::gpu::GPUOperator::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUAssign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string dest = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dest()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->dest().data(), this->dest().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_op;
        break;
      }
      
      // required .blox.compiler.gpu.GPUOperator op = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_op:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_op()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUAssign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string dest = 1;
  if (has_dest()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->dest().data(), this->dest().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->dest(), output);
  }
  
  // required .blox.compiler.gpu.GPUOperator op = 2;
  if (has_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->op(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUAssign::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string dest = 1;
  if (has_dest()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->dest().data(), this->dest().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->dest(), target);
  }
  
  // required .blox.compiler.gpu.GPUOperator op = 2;
  if (has_op()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->op(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUAssign::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string dest = 1;
    if (has_dest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dest());
    }
    
    // required .blox.compiler.gpu.GPUOperator op = 2;
    if (has_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->op());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUAssign::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUAssign* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUAssign*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUAssign::MergeFrom(const GPUAssign& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dest()) {
      set_dest(from.dest());
    }
    if (from.has_op()) {
      mutable_op()->::blox::compiler::gpu::GPUOperator::MergeFrom(from.op());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUAssign::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUAssign::CopyFrom(const GPUAssign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUAssign::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_op()) {
    if (!this->op().IsInitialized()) return false;
  }
  return true;
}

void GPUAssign::Swap(GPUAssign* other) {
  if (other != this) {
    std::swap(dest_, other->dest_);
    std::swap(op_, other->op_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUAssign::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUAssign_descriptor_;
  metadata.reflection = GPUAssign_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUCond::kSrc1FieldNumber;
const int GPUCond::kSrc2FieldNumber;
const int GPUCond::kYesFieldNumber;
const int GPUCond::kNoFieldNumber;
#endif  // !_MSC_VER

GPUCond::GPUCond()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUCond::InitAsDefaultInstance() {
}

GPUCond::GPUCond(const GPUCond& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUCond::SharedCtor() {
  _cached_size_ = 0;
  src1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  src2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  yes_ = 0;
  no_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUCond::~GPUCond() {
  SharedDtor();
}

void GPUCond::SharedDtor() {
  if (src1_ != &::google::protobuf::internal::kEmptyString) {
    delete src1_;
  }
  if (src2_ != &::google::protobuf::internal::kEmptyString) {
    delete src2_;
  }
  if (this != default_instance_) {
  }
}

void GPUCond::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUCond::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUCond_descriptor_;
}

const GPUCond& GPUCond::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUCond* GPUCond::default_instance_ = NULL;

GPUCond* GPUCond::New() const {
  return new GPUCond;
}

void GPUCond::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_src1()) {
      if (src1_ != &::google::protobuf::internal::kEmptyString) {
        src1_->clear();
      }
    }
    if (has_src2()) {
      if (src2_ != &::google::protobuf::internal::kEmptyString) {
        src2_->clear();
      }
    }
    yes_ = 0;
    no_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUCond::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string src1 = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_src1()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->src1().data(), this->src1().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_src2;
        break;
      }
      
      // required string src2 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_src2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_src2()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->src2().data(), this->src2().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_yes;
        break;
      }
      
      // required int32 yes = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_yes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &yes_)));
          set_has_yes();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_no;
        break;
      }
      
      // required int32 no = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_no:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &no_)));
          set_has_no();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUCond::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string src1 = 1;
  if (has_src1()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->src1().data(), this->src1().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->src1(), output);
  }
  
  // required string src2 = 2;
  if (has_src2()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->src2().data(), this->src2().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->src2(), output);
  }
  
  // required int32 yes = 3;
  if (has_yes()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->yes(), output);
  }
  
  // required int32 no = 4;
  if (has_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->no(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUCond::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string src1 = 1;
  if (has_src1()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->src1().data(), this->src1().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->src1(), target);
  }
  
  // required string src2 = 2;
  if (has_src2()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->src2().data(), this->src2().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->src2(), target);
  }
  
  // required int32 yes = 3;
  if (has_yes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->yes(), target);
  }
  
  // required int32 no = 4;
  if (has_no()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->no(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUCond::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string src1 = 1;
    if (has_src1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->src1());
    }
    
    // required string src2 = 2;
    if (has_src2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->src2());
    }
    
    // required int32 yes = 3;
    if (has_yes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->yes());
    }
    
    // required int32 no = 4;
    if (has_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->no());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUCond::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUCond* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUCond*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUCond::MergeFrom(const GPUCond& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_src1()) {
      set_src1(from.src1());
    }
    if (from.has_src2()) {
      set_src2(from.src2());
    }
    if (from.has_yes()) {
      set_yes(from.yes());
    }
    if (from.has_no()) {
      set_no(from.no());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUCond::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUCond::CopyFrom(const GPUCond& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUCond::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

void GPUCond::Swap(GPUCond* other) {
  if (other != this) {
    std::swap(src1_, other->src1_);
    std::swap(src2_, other->src2_);
    std::swap(yes_, other->yes_);
    std::swap(no_, other->no_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUCond::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUCond_descriptor_;
  metadata.reflection = GPUCond_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUGoto::kTargetFieldNumber;
#endif  // !_MSC_VER

GPUGoto::GPUGoto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUGoto::InitAsDefaultInstance() {
}

GPUGoto::GPUGoto(const GPUGoto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUGoto::SharedCtor() {
  _cached_size_ = 0;
  target_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUGoto::~GPUGoto() {
  SharedDtor();
}

void GPUGoto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GPUGoto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUGoto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUGoto_descriptor_;
}

const GPUGoto& GPUGoto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUGoto* GPUGoto::default_instance_ = NULL;

GPUGoto* GPUGoto::New() const {
  return new GPUGoto;
}

void GPUGoto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    target_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUGoto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 target = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &target_)));
          set_has_target();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUGoto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 target = 1;
  if (has_target()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->target(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUGoto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 target = 1;
  if (has_target()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->target(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUGoto::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 target = 1;
    if (has_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->target());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUGoto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUGoto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUGoto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUGoto::MergeFrom(const GPUGoto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target()) {
      set_target(from.target());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUGoto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUGoto::CopyFrom(const GPUGoto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUGoto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GPUGoto::Swap(GPUGoto* other) {
  if (other != this) {
    std::swap(target_, other->target_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUGoto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUGoto_descriptor_;
  metadata.reflection = GPUGoto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUMove::kDestFieldNumber;
const int GPUMove::kSrc1FieldNumber;
#endif  // !_MSC_VER

GPUMove::GPUMove()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUMove::InitAsDefaultInstance() {
}

GPUMove::GPUMove(const GPUMove& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUMove::SharedCtor() {
  _cached_size_ = 0;
  dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  src1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUMove::~GPUMove() {
  SharedDtor();
}

void GPUMove::SharedDtor() {
  if (dest_ != &::google::protobuf::internal::kEmptyString) {
    delete dest_;
  }
  if (src1_ != &::google::protobuf::internal::kEmptyString) {
    delete src1_;
  }
  if (this != default_instance_) {
  }
}

void GPUMove::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUMove::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUMove_descriptor_;
}

const GPUMove& GPUMove::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUMove* GPUMove::default_instance_ = NULL;

GPUMove* GPUMove::New() const {
  return new GPUMove;
}

void GPUMove::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_dest()) {
      if (dest_ != &::google::protobuf::internal::kEmptyString) {
        dest_->clear();
      }
    }
    if (has_src1()) {
      if (src1_ != &::google::protobuf::internal::kEmptyString) {
        src1_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUMove::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string dest = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dest()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->dest().data(), this->dest().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_src1;
        break;
      }
      
      // required string src1 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_src1:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_src1()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->src1().data(), this->src1().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUMove::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string dest = 1;
  if (has_dest()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->dest().data(), this->dest().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->dest(), output);
  }
  
  // required string src1 = 2;
  if (has_src1()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->src1().data(), this->src1().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->src1(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUMove::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string dest = 1;
  if (has_dest()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->dest().data(), this->dest().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->dest(), target);
  }
  
  // required string src1 = 2;
  if (has_src1()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->src1().data(), this->src1().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->src1(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUMove::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string dest = 1;
    if (has_dest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dest());
    }
    
    // required string src1 = 2;
    if (has_src1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->src1());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUMove::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUMove* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUMove*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUMove::MergeFrom(const GPUMove& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dest()) {
      set_dest(from.dest());
    }
    if (from.has_src1()) {
      set_src1(from.src1());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUMove::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUMove::CopyFrom(const GPUMove& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUMove::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void GPUMove::Swap(GPUMove* other) {
  if (other != this) {
    std::swap(dest_, other->dest_);
    std::swap(src1_, other->src1_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUMove::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUMove_descriptor_;
  metadata.reflection = GPUMove_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUCommand::kTagFieldNumber;
const int GPUCommand::kAssignFieldNumber;
const int GPUCommand::kCondFieldNumber;
const int GPUCommand::kJumpFieldNumber;
const int GPUCommand::kMoveFieldNumber;
const int GPUCommand::kHaltFieldNumber;
#endif  // !_MSC_VER

GPUCommand::GPUCommand()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUCommand::InitAsDefaultInstance() {
  assign_ = const_cast< ::blox::compiler::gpu::GPUAssign*>(&::blox::compiler::gpu::GPUAssign::default_instance());
  cond_ = const_cast< ::blox::compiler::gpu::GPUCond*>(&::blox::compiler::gpu::GPUCond::default_instance());
  jump_ = const_cast< ::blox::compiler::gpu::GPUGoto*>(&::blox::compiler::gpu::GPUGoto::default_instance());
  move_ = const_cast< ::blox::compiler::gpu::GPUMove*>(&::blox::compiler::gpu::GPUMove::default_instance());
}

GPUCommand::GPUCommand(const GPUCommand& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUCommand::SharedCtor() {
  _cached_size_ = 0;
  tag_ = 2;
  assign_ = NULL;
  cond_ = NULL;
  jump_ = NULL;
  move_ = NULL;
  halt_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUCommand::~GPUCommand() {
  SharedDtor();
}

void GPUCommand::SharedDtor() {
  if (this != default_instance_) {
    delete assign_;
    delete cond_;
    delete jump_;
    delete move_;
  }
}

void GPUCommand::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUCommand::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUCommand_descriptor_;
}

const GPUCommand& GPUCommand::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUCommand* GPUCommand::default_instance_ = NULL;

GPUCommand* GPUCommand::New() const {
  return new GPUCommand;
}

void GPUCommand::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tag_ = 2;
    if (has_assign()) {
      if (assign_ != NULL) assign_->::blox::compiler::gpu::GPUAssign::Clear();
    }
    if (has_cond()) {
      if (cond_ != NULL) cond_->::blox::compiler::gpu::GPUCond::Clear();
    }
    if (has_jump()) {
      if (jump_ != NULL) jump_->::blox::compiler::gpu::GPUGoto::Clear();
    }
    if (has_move()) {
      if (move_ != NULL) move_->::blox::compiler::gpu::GPUMove::Clear();
    }
    halt_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUCommand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.CommandTag tag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::CommandTag_IsValid(value)) {
            set_tag(static_cast< blox::compiler::gpu::CommandTag >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_assign;
        break;
      }
      
      // optional .blox.compiler.gpu.GPUAssign assign = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_assign:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_assign()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_cond;
        break;
      }
      
      // optional .blox.compiler.gpu.GPUCond cond = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cond:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cond()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_jump;
        break;
      }
      
      // optional .blox.compiler.gpu.GPUGoto jump = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_jump:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_jump()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_move;
        break;
      }
      
      // optional .blox.compiler.gpu.GPUMove move = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_move:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_move()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_halt;
        break;
      }
      
      // optional int32 halt = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_halt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &halt_)));
          set_has_halt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUCommand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.CommandTag tag = 1;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->tag(), output);
  }
  
  // optional .blox.compiler.gpu.GPUAssign assign = 2;
  if (has_assign()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->assign(), output);
  }
  
  // optional .blox.compiler.gpu.GPUCond cond = 3;
  if (has_cond()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->cond(), output);
  }
  
  // optional .blox.compiler.gpu.GPUGoto jump = 4;
  if (has_jump()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->jump(), output);
  }
  
  // optional .blox.compiler.gpu.GPUMove move = 5;
  if (has_move()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->move(), output);
  }
  
  // optional int32 halt = 6;
  if (has_halt()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->halt(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUCommand::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.CommandTag tag = 1;
  if (has_tag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->tag(), target);
  }
  
  // optional .blox.compiler.gpu.GPUAssign assign = 2;
  if (has_assign()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->assign(), target);
  }
  
  // optional .blox.compiler.gpu.GPUCond cond = 3;
  if (has_cond()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->cond(), target);
  }
  
  // optional .blox.compiler.gpu.GPUGoto jump = 4;
  if (has_jump()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->jump(), target);
  }
  
  // optional .blox.compiler.gpu.GPUMove move = 5;
  if (has_move()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->move(), target);
  }
  
  // optional int32 halt = 6;
  if (has_halt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->halt(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUCommand::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.CommandTag tag = 1;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->tag());
    }
    
    // optional .blox.compiler.gpu.GPUAssign assign = 2;
    if (has_assign()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->assign());
    }
    
    // optional .blox.compiler.gpu.GPUCond cond = 3;
    if (has_cond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cond());
    }
    
    // optional .blox.compiler.gpu.GPUGoto jump = 4;
    if (has_jump()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->jump());
    }
    
    // optional .blox.compiler.gpu.GPUMove move = 5;
    if (has_move()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->move());
    }
    
    // optional int32 halt = 6;
    if (has_halt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->halt());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUCommand::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUCommand* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUCommand*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUCommand::MergeFrom(const GPUCommand& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tag()) {
      set_tag(from.tag());
    }
    if (from.has_assign()) {
      mutable_assign()->::blox::compiler::gpu::GPUAssign::MergeFrom(from.assign());
    }
    if (from.has_cond()) {
      mutable_cond()->::blox::compiler::gpu::GPUCond::MergeFrom(from.cond());
    }
    if (from.has_jump()) {
      mutable_jump()->::blox::compiler::gpu::GPUGoto::MergeFrom(from.jump());
    }
    if (from.has_move()) {
      mutable_move()->::blox::compiler::gpu::GPUMove::MergeFrom(from.move());
    }
    if (from.has_halt()) {
      set_halt(from.halt());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUCommand::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUCommand::CopyFrom(const GPUCommand& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUCommand::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_assign()) {
    if (!this->assign().IsInitialized()) return false;
  }
  if (has_cond()) {
    if (!this->cond().IsInitialized()) return false;
  }
  if (has_jump()) {
    if (!this->jump().IsInitialized()) return false;
  }
  if (has_move()) {
    if (!this->move().IsInitialized()) return false;
  }
  return true;
}

void GPUCommand::Swap(GPUCommand* other) {
  if (other != this) {
    std::swap(tag_, other->tag_);
    std::swap(assign_, other->assign_);
    std::swap(cond_, other->cond_);
    std::swap(jump_, other->jump_);
    std::swap(move_, other->move_);
    std::swap(halt_, other->halt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUCommand::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUCommand_descriptor_;
  metadata.reflection = GPUCommand_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Address::kTagFieldNumber;
const int Address::kVaraddrFieldNumber;
const int Address::kConstaddrFieldNumber;
#endif  // !_MSC_VER

Address::Address()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Address::InitAsDefaultInstance() {
  constaddr_ = const_cast< ::blox::common::protocol::Constant*>(&::blox::common::protocol::Constant::default_instance());
}

Address::Address(const Address& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Address::SharedCtor() {
  _cached_size_ = 0;
  tag_ = 2;
  varaddr_ = 0;
  constaddr_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Address::~Address() {
  SharedDtor();
}

void Address::SharedDtor() {
  if (this != default_instance_) {
    delete constaddr_;
  }
}

void Address::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Address::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Address_descriptor_;
}

const Address& Address::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Address* Address::default_instance_ = NULL;

Address* Address::New() const {
  return new Address;
}

void Address::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tag_ = 2;
    varaddr_ = 0;
    if (has_constaddr()) {
      if (constaddr_ != NULL) constaddr_->::blox::common::protocol::Constant::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Address::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.AddressTag tag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::AddressTag_IsValid(value)) {
            set_tag(static_cast< blox::compiler::gpu::AddressTag >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_varaddr;
        break;
      }
      
      // optional int32 varaddr = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_varaddr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &varaddr_)));
          set_has_varaddr();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_constaddr;
        break;
      }
      
      // optional .blox.common.protocol.Constant constaddr = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_constaddr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_constaddr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Address::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.AddressTag tag = 1;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->tag(), output);
  }
  
  // optional int32 varaddr = 2;
  if (has_varaddr()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->varaddr(), output);
  }
  
  // optional .blox.common.protocol.Constant constaddr = 3;
  if (has_constaddr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->constaddr(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Address::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.AddressTag tag = 1;
  if (has_tag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->tag(), target);
  }
  
  // optional int32 varaddr = 2;
  if (has_varaddr()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->varaddr(), target);
  }
  
  // optional .blox.common.protocol.Constant constaddr = 3;
  if (has_constaddr()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->constaddr(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Address::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.AddressTag tag = 1;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->tag());
    }
    
    // optional int32 varaddr = 2;
    if (has_varaddr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->varaddr());
    }
    
    // optional .blox.common.protocol.Constant constaddr = 3;
    if (has_constaddr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->constaddr());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Address::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Address* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Address*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Address::MergeFrom(const Address& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tag()) {
      set_tag(from.tag());
    }
    if (from.has_varaddr()) {
      set_varaddr(from.varaddr());
    }
    if (from.has_constaddr()) {
      mutable_constaddr()->::blox::common::protocol::Constant::MergeFrom(from.constaddr());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Address::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Address::CopyFrom(const Address& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Address::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_constaddr()) {
    if (!this->constaddr().IsInitialized()) return false;
  }
  return true;
}

void Address::Swap(Address* other) {
  if (other != this) {
    std::swap(tag_, other->tag_);
    std::swap(varaddr_, other->varaddr_);
    std::swap(constaddr_, other->constaddr_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Address::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Address_descriptor_;
  metadata.reflection = Address_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUCompare::kComparisonFieldNumber;
const int GPUCompare::kOptypeFieldNumber;
const int GPUCompare::kAddr1FieldNumber;
const int GPUCompare::kAddr2FieldNumber;
#endif  // !_MSC_VER

GPUCompare::GPUCompare()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUCompare::InitAsDefaultInstance() {
  optype_ = const_cast< ::blox::common::protocol::PrimitiveType*>(&::blox::common::protocol::PrimitiveType::default_instance());
  addr1_ = const_cast< ::blox::compiler::gpu::Address*>(&::blox::compiler::gpu::Address::default_instance());
  addr2_ = const_cast< ::blox::compiler::gpu::Address*>(&::blox::compiler::gpu::Address::default_instance());
}

GPUCompare::GPUCompare(const GPUCompare& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUCompare::SharedCtor() {
  _cached_size_ = 0;
  comparison_ = 0;
  optype_ = NULL;
  addr1_ = NULL;
  addr2_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUCompare::~GPUCompare() {
  SharedDtor();
}

void GPUCompare::SharedDtor() {
  if (this != default_instance_) {
    delete optype_;
    delete addr1_;
    delete addr2_;
  }
}

void GPUCompare::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUCompare::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUCompare_descriptor_;
}

const GPUCompare& GPUCompare::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUCompare* GPUCompare::default_instance_ = NULL;

GPUCompare* GPUCompare::New() const {
  return new GPUCompare;
}

void GPUCompare::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    comparison_ = 0;
    if (has_optype()) {
      if (optype_ != NULL) optype_->::blox::common::protocol::PrimitiveType::Clear();
    }
    if (has_addr1()) {
      if (addr1_ != NULL) addr1_->::blox::compiler::gpu::Address::Clear();
    }
    if (has_addr2()) {
      if (addr2_ != NULL) addr2_->::blox::compiler::gpu::Address::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUCompare::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.Comparison comparison = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::Comparison_IsValid(value)) {
            set_comparison(static_cast< blox::compiler::gpu::Comparison >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_optype;
        break;
      }
      
      // required .blox.common.protocol.PrimitiveType optype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_optype:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_optype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_addr1;
        break;
      }
      
      // required .blox.compiler.gpu.Address addr1 = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_addr1:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_addr1()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_addr2;
        break;
      }
      
      // required .blox.compiler.gpu.Address addr2 = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_addr2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_addr2()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUCompare::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.Comparison comparison = 1;
  if (has_comparison()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->comparison(), output);
  }
  
  // required .blox.common.protocol.PrimitiveType optype = 2;
  if (has_optype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->optype(), output);
  }
  
  // required .blox.compiler.gpu.Address addr1 = 3;
  if (has_addr1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->addr1(), output);
  }
  
  // required .blox.compiler.gpu.Address addr2 = 4;
  if (has_addr2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->addr2(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUCompare::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.Comparison comparison = 1;
  if (has_comparison()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->comparison(), target);
  }
  
  // required .blox.common.protocol.PrimitiveType optype = 2;
  if (has_optype()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->optype(), target);
  }
  
  // required .blox.compiler.gpu.Address addr1 = 3;
  if (has_addr1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->addr1(), target);
  }
  
  // required .blox.compiler.gpu.Address addr2 = 4;
  if (has_addr2()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->addr2(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUCompare::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.Comparison comparison = 1;
    if (has_comparison()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->comparison());
    }
    
    // required .blox.common.protocol.PrimitiveType optype = 2;
    if (has_optype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->optype());
    }
    
    // required .blox.compiler.gpu.Address addr1 = 3;
    if (has_addr1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->addr1());
    }
    
    // required .blox.compiler.gpu.Address addr2 = 4;
    if (has_addr2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->addr2());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUCompare::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUCompare* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUCompare*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUCompare::MergeFrom(const GPUCompare& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_comparison()) {
      set_comparison(from.comparison());
    }
    if (from.has_optype()) {
      mutable_optype()->::blox::common::protocol::PrimitiveType::MergeFrom(from.optype());
    }
    if (from.has_addr1()) {
      mutable_addr1()->::blox::compiler::gpu::Address::MergeFrom(from.addr1());
    }
    if (from.has_addr2()) {
      mutable_addr2()->::blox::compiler::gpu::Address::MergeFrom(from.addr2());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUCompare::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUCompare::CopyFrom(const GPUCompare& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUCompare::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_optype()) {
    if (!this->optype().IsInitialized()) return false;
  }
  if (has_addr1()) {
    if (!this->addr1().IsInitialized()) return false;
  }
  if (has_addr2()) {
    if (!this->addr2().IsInitialized()) return false;
  }
  return true;
}

void GPUCompare::Swap(GPUCompare* other) {
  if (other != this) {
    std::swap(comparison_, other->comparison_);
    std::swap(optype_, other->optype_);
    std::swap(addr1_, other->addr1_);
    std::swap(addr2_, other->addr2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUCompare::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUCompare_descriptor_;
  metadata.reflection = GPUCompare_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPUSequence::kUniqueIdentifierFieldNumber;
const int GPUSequence::kOperatorsFieldNumber;
#endif  // !_MSC_VER

GPUSequence::GPUSequence()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GPUSequence::InitAsDefaultInstance() {
}

GPUSequence::GPUSequence(const GPUSequence& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GPUSequence::SharedCtor() {
  _cached_size_ = 0;
  uniqueidentifier_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUSequence::~GPUSequence() {
  SharedDtor();
}

void GPUSequence::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GPUSequence::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPUSequence::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPUSequence_descriptor_;
}

const GPUSequence& GPUSequence::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

GPUSequence* GPUSequence::default_instance_ = NULL;

GPUSequence* GPUSequence::New() const {
  return new GPUSequence;
}

void GPUSequence::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uniqueidentifier_ = 0;
  }
  operators_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPUSequence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uniqueIdentifier = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uniqueidentifier_)));
          set_has_uniqueidentifier();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_operators;
        break;
      }
      
      // repeated .blox.compiler.gpu.GPUCommand operators = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_operators:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_operators()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_operators;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUSequence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uniqueIdentifier = 1;
  if (has_uniqueidentifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uniqueidentifier(), output);
  }
  
  // repeated .blox.compiler.gpu.GPUCommand operators = 2;
  for (int i = 0; i < this->operators_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->operators(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GPUSequence::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uniqueIdentifier = 1;
  if (has_uniqueidentifier()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uniqueidentifier(), target);
  }
  
  // repeated .blox.compiler.gpu.GPUCommand operators = 2;
  for (int i = 0; i < this->operators_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->operators(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GPUSequence::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uniqueIdentifier = 1;
    if (has_uniqueidentifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uniqueidentifier());
    }
    
  }
  // repeated .blox.compiler.gpu.GPUCommand operators = 2;
  total_size += 1 * this->operators_size();
  for (int i = 0; i < this->operators_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->operators(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUSequence::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPUSequence* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPUSequence*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPUSequence::MergeFrom(const GPUSequence& from) {
  GOOGLE_CHECK_NE(&from, this);
  operators_.MergeFrom(from.operators_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uniqueidentifier()) {
      set_uniqueidentifier(from.uniqueidentifier());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPUSequence::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPUSequence::CopyFrom(const GPUSequence& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUSequence::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < operators_size(); i++) {
    if (!this->operators(i).IsInitialized()) return false;
  }
  return true;
}

void GPUSequence::Swap(GPUSequence* other) {
  if (other != this) {
    std::swap(uniqueidentifier_, other->uniqueidentifier_);
    operators_.Swap(&other->operators_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPUSequence::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPUSequence_descriptor_;
  metadata.reflection = GPUSequence_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NumType::kTypFieldNumber;
const int NumType::kSizeFieldNumber;
#endif  // !_MSC_VER

NumType::NumType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NumType::InitAsDefaultInstance() {
}

NumType::NumType(const NumType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NumType::SharedCtor() {
  _cached_size_ = 0;
  typ_ = 0;
  size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NumType::~NumType() {
  SharedDtor();
}

void NumType::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NumType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NumType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NumType_descriptor_;
}

const NumType& NumType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

NumType* NumType::default_instance_ = NULL;

NumType* NumType::New() const {
  return new NumType;
}

void NumType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    typ_ = 0;
    size_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NumType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.Numeric typ = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::Numeric_IsValid(value)) {
            set_typ(static_cast< blox::compiler::gpu::Numeric >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_size;
        break;
      }
      
      // required int32 size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NumType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.Numeric typ = 1;
  if (has_typ()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->typ(), output);
  }
  
  // required int32 size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->size(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NumType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.Numeric typ = 1;
  if (has_typ()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->typ(), target);
  }
  
  // required int32 size = 2;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->size(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NumType::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.Numeric typ = 1;
    if (has_typ()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->typ());
    }
    
    // required int32 size = 2;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->size());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NumType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NumType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NumType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NumType::MergeFrom(const NumType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_typ()) {
      set_typ(from.typ());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NumType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NumType::CopyFrom(const NumType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NumType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void NumType::Swap(NumType* other) {
  if (other != this) {
    std::swap(typ_, other->typ_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NumType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NumType_descriptor_;
  metadata.reflection = NumType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Univ::kTagFieldNumber;
const int Univ::kNFieldNumber;
const int Univ::kFFieldNumber;
#endif  // !_MSC_VER

Univ::Univ()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Univ::InitAsDefaultInstance() {
  n_ = const_cast< ::blox::compiler::gpu::NumType*>(&::blox::compiler::gpu::NumType::default_instance());
}

Univ::Univ(const Univ& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Univ::SharedCtor() {
  _cached_size_ = 0;
  tag_ = 0;
  n_ = NULL;
  f_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Univ::~Univ() {
  SharedDtor();
}

void Univ::SharedDtor() {
  if (this != default_instance_) {
    delete n_;
  }
}

void Univ::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Univ::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Univ_descriptor_;
}

const Univ& Univ::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Univ* Univ::default_instance_ = NULL;

Univ* Univ::New() const {
  return new Univ;
}

void Univ::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tag_ = 0;
    if (has_n()) {
      if (n_ != NULL) n_->::blox::compiler::gpu::NumType::Clear();
    }
    f_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Univ::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.UnivTag tag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::UnivTag_IsValid(value)) {
            set_tag(static_cast< blox::compiler::gpu::UnivTag >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_n;
        break;
      }
      
      // optional .blox.compiler.gpu.NumType n = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_n:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_n()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_f;
        break;
      }
      
      // optional .blox.compiler.gpu.Fixed f = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_f:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::Fixed_IsValid(value)) {
            set_f(static_cast< blox::compiler::gpu::Fixed >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Univ::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.UnivTag tag = 1;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->tag(), output);
  }
  
  // optional .blox.compiler.gpu.NumType n = 2;
  if (has_n()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->n(), output);
  }
  
  // optional .blox.compiler.gpu.Fixed f = 3;
  if (has_f()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->f(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Univ::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.UnivTag tag = 1;
  if (has_tag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->tag(), target);
  }
  
  // optional .blox.compiler.gpu.NumType n = 2;
  if (has_n()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->n(), target);
  }
  
  // optional .blox.compiler.gpu.Fixed f = 3;
  if (has_f()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->f(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Univ::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.UnivTag tag = 1;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->tag());
    }
    
    // optional .blox.compiler.gpu.NumType n = 2;
    if (has_n()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->n());
    }
    
    // optional .blox.compiler.gpu.Fixed f = 3;
    if (has_f()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->f());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Univ::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Univ* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Univ*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Univ::MergeFrom(const Univ& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tag()) {
      set_tag(from.tag());
    }
    if (from.has_n()) {
      mutable_n()->::blox::compiler::gpu::NumType::MergeFrom(from.n());
    }
    if (from.has_f()) {
      set_f(from.f());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Univ::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Univ::CopyFrom(const Univ& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Univ::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_n()) {
    if (!this->n().IsInitialized()) return false;
  }
  return true;
}

void Univ::Swap(Univ* other) {
  if (other != this) {
    std::swap(tag_, other->tag_);
    std::swap(n_, other->n_);
    std::swap(f_, other->f_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Univ::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Univ_descriptor_;
  metadata.reflection = Univ_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ConstExp::kLiteralFieldNumber;
#endif  // !_MSC_VER

ConstExp::ConstExp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ConstExp::InitAsDefaultInstance() {
  literal_ = const_cast< ::blox::common::protocol::Constant*>(&::blox::common::protocol::Constant::default_instance());
}

ConstExp::ConstExp(const ConstExp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ConstExp::SharedCtor() {
  _cached_size_ = 0;
  literal_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConstExp::~ConstExp() {
  SharedDtor();
}

void ConstExp::SharedDtor() {
  if (this != default_instance_) {
    delete literal_;
  }
}

void ConstExp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConstExp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConstExp_descriptor_;
}

const ConstExp& ConstExp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

ConstExp* ConstExp::default_instance_ = NULL;

ConstExp* ConstExp::New() const {
  return new ConstExp;
}

void ConstExp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_literal()) {
      if (literal_ != NULL) literal_->::blox::common::protocol::Constant::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ConstExp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.common.protocol.Constant literal = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_literal()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ConstExp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.common.protocol.Constant literal = 1;
  if (has_literal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->literal(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ConstExp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.common.protocol.Constant literal = 1;
  if (has_literal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->literal(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ConstExp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.common.protocol.Constant literal = 1;
    if (has_literal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->literal());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConstExp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ConstExp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ConstExp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConstExp::MergeFrom(const ConstExp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_literal()) {
      mutable_literal()->::blox::common::protocol::Constant::MergeFrom(from.literal());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ConstExp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConstExp::CopyFrom(const ConstExp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConstExp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_literal()) {
    if (!this->literal().IsInitialized()) return false;
  }
  return true;
}

void ConstExp::Swap(ConstExp* other) {
  if (other != this) {
    std::swap(literal_, other->literal_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ConstExp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConstExp_descriptor_;
  metadata.reflection = ConstExp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Name::kEnameFieldNumber;
const int Name::kEtypeFieldNumber;
#endif  // !_MSC_VER

Name::Name()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Name::InitAsDefaultInstance() {
  etype_ = const_cast< ::blox::common::protocol::Type*>(&::blox::common::protocol::Type::default_instance());
}

Name::Name(const Name& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Name::SharedCtor() {
  _cached_size_ = 0;
  ename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  etype_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Name::~Name() {
  SharedDtor();
}

void Name::SharedDtor() {
  if (ename_ != &::google::protobuf::internal::kEmptyString) {
    delete ename_;
  }
  if (this != default_instance_) {
    delete etype_;
  }
}

void Name::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Name::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Name_descriptor_;
}

const Name& Name::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Name* Name::default_instance_ = NULL;

Name* Name::New() const {
  return new Name;
}

void Name::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ename()) {
      if (ename_ != &::google::protobuf::internal::kEmptyString) {
        ename_->clear();
      }
    }
    if (has_etype()) {
      if (etype_ != NULL) etype_->::blox::common::protocol::Type::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Name::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ename = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ename().data(), this->ename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_etype;
        break;
      }
      
      // required .blox.common.protocol.Type etype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_etype:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_etype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Name::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string ename = 1;
  if (has_ename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ename().data(), this->ename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->ename(), output);
  }
  
  // required .blox.common.protocol.Type etype = 2;
  if (has_etype()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->etype(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Name::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string ename = 1;
  if (has_ename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ename().data(), this->ename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->ename(), target);
  }
  
  // required .blox.common.protocol.Type etype = 2;
  if (has_etype()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->etype(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Name::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string ename = 1;
    if (has_ename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ename());
    }
    
    // required .blox.common.protocol.Type etype = 2;
    if (has_etype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->etype());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Name::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Name* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Name*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Name::MergeFrom(const Name& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ename()) {
      set_ename(from.ename());
    }
    if (from.has_etype()) {
      mutable_etype()->::blox::common::protocol::Type::MergeFrom(from.etype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Name::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Name::CopyFrom(const Name& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Name::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_etype()) {
    if (!this->etype().IsInitialized()) return false;
  }
  return true;
}

void Name::Swap(Name* other) {
  if (other != this) {
    std::swap(ename_, other->ename_);
    std::swap(etype_, other->etype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Name::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Name_descriptor_;
  metadata.reflection = Name_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Index::kOffsetFieldNumber;
const int Index::kEtypFieldNumber;
#endif  // !_MSC_VER

Index::Index()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Index::InitAsDefaultInstance() {
  etyp_ = const_cast< ::blox::common::protocol::Type*>(&::blox::common::protocol::Type::default_instance());
}

Index::Index(const Index& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Index::SharedCtor() {
  _cached_size_ = 0;
  offset_ = 0;
  etyp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Index::~Index() {
  SharedDtor();
}

void Index::SharedDtor() {
  if (this != default_instance_) {
    delete etyp_;
  }
}

void Index::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Index::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Index_descriptor_;
}

const Index& Index::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Index* Index::default_instance_ = NULL;

Index* Index::New() const {
  return new Index;
}

void Index::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    offset_ = 0;
    if (has_etyp()) {
      if (etyp_ != NULL) etyp_->::blox::common::protocol::Type::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Index::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 offset = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_etyp;
        break;
      }
      
      // required .blox.common.protocol.Type etyp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_etyp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_etyp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Index::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 offset = 1;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->offset(), output);
  }
  
  // required .blox.common.protocol.Type etyp = 2;
  if (has_etyp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->etyp(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Index::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 offset = 1;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->offset(), target);
  }
  
  // required .blox.common.protocol.Type etyp = 2;
  if (has_etyp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->etyp(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Index::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 offset = 1;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->offset());
    }
    
    // required .blox.common.protocol.Type etyp = 2;
    if (has_etyp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->etyp());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Index::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Index* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Index*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Index::MergeFrom(const Index& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_etyp()) {
      mutable_etyp()->::blox::common::protocol::Type::MergeFrom(from.etyp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Index::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Index::CopyFrom(const Index& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Index::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_etyp()) {
    if (!this->etyp().IsInitialized()) return false;
  }
  return true;
}

void Index::Swap(Index* other) {
  if (other != this) {
    std::swap(offset_, other->offset_);
    std::swap(etyp_, other->etyp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Index::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Index_descriptor_;
  metadata.reflection = Index_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ArithExp::kDomainFieldNumber;
const int ArithExp::kOpFieldNumber;
const int ArithExp::kExp1FieldNumber;
const int ArithExp::kExp2FieldNumber;
#endif  // !_MSC_VER

ArithExp::ArithExp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ArithExp::InitAsDefaultInstance() {
  domain_ = const_cast< ::blox::compiler::gpu::NumType*>(&::blox::compiler::gpu::NumType::default_instance());
  exp1_ = const_cast< ::blox::compiler::gpu::Exp*>(&::blox::compiler::gpu::Exp::default_instance());
  exp2_ = const_cast< ::blox::compiler::gpu::Exp*>(&::blox::compiler::gpu::Exp::default_instance());
}

ArithExp::ArithExp(const ArithExp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ArithExp::SharedCtor() {
  _cached_size_ = 0;
  domain_ = NULL;
  op_ = 0;
  exp1_ = NULL;
  exp2_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ArithExp::~ArithExp() {
  SharedDtor();
}

void ArithExp::SharedDtor() {
  if (this != default_instance_) {
    delete domain_;
    delete exp1_;
    delete exp2_;
  }
}

void ArithExp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ArithExp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ArithExp_descriptor_;
}

const ArithExp& ArithExp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

ArithExp* ArithExp::default_instance_ = NULL;

ArithExp* ArithExp::New() const {
  return new ArithExp;
}

void ArithExp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_domain()) {
      if (domain_ != NULL) domain_->::blox::compiler::gpu::NumType::Clear();
    }
    op_ = 0;
    if (has_exp1()) {
      if (exp1_ != NULL) exp1_->::blox::compiler::gpu::Exp::Clear();
    }
    if (has_exp2()) {
      if (exp2_ != NULL) exp2_->::blox::compiler::gpu::Exp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ArithExp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.NumType domain = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_domain()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_op;
        break;
      }
      
      // required .blox.compiler.gpu.ArithmeticOp op = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_op:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::ArithmeticOp_IsValid(value)) {
            set_op(static_cast< blox::compiler::gpu::ArithmeticOp >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_exp1;
        break;
      }
      
      // required .blox.compiler.gpu.Exp exp1 = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exp1:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp1()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_exp2;
        break;
      }
      
      // required .blox.compiler.gpu.Exp exp2 = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exp2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp2()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ArithExp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.NumType domain = 1;
  if (has_domain()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->domain(), output);
  }
  
  // required .blox.compiler.gpu.ArithmeticOp op = 2;
  if (has_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->op(), output);
  }
  
  // required .blox.compiler.gpu.Exp exp1 = 3;
  if (has_exp1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->exp1(), output);
  }
  
  // required .blox.compiler.gpu.Exp exp2 = 4;
  if (has_exp2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->exp2(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ArithExp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.NumType domain = 1;
  if (has_domain()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->domain(), target);
  }
  
  // required .blox.compiler.gpu.ArithmeticOp op = 2;
  if (has_op()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->op(), target);
  }
  
  // required .blox.compiler.gpu.Exp exp1 = 3;
  if (has_exp1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->exp1(), target);
  }
  
  // required .blox.compiler.gpu.Exp exp2 = 4;
  if (has_exp2()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->exp2(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ArithExp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.NumType domain = 1;
    if (has_domain()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->domain());
    }
    
    // required .blox.compiler.gpu.ArithmeticOp op = 2;
    if (has_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->op());
    }
    
    // required .blox.compiler.gpu.Exp exp1 = 3;
    if (has_exp1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp1());
    }
    
    // required .blox.compiler.gpu.Exp exp2 = 4;
    if (has_exp2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp2());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ArithExp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ArithExp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ArithExp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ArithExp::MergeFrom(const ArithExp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_domain()) {
      mutable_domain()->::blox::compiler::gpu::NumType::MergeFrom(from.domain());
    }
    if (from.has_op()) {
      set_op(from.op());
    }
    if (from.has_exp1()) {
      mutable_exp1()->::blox::compiler::gpu::Exp::MergeFrom(from.exp1());
    }
    if (from.has_exp2()) {
      mutable_exp2()->::blox::compiler::gpu::Exp::MergeFrom(from.exp2());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ArithExp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ArithExp::CopyFrom(const ArithExp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArithExp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_domain()) {
    if (!this->domain().IsInitialized()) return false;
  }
  if (has_exp1()) {
    if (!this->exp1().IsInitialized()) return false;
  }
  if (has_exp2()) {
    if (!this->exp2().IsInitialized()) return false;
  }
  return true;
}

void ArithExp::Swap(ArithExp* other) {
  if (other != this) {
    std::swap(domain_, other->domain_);
    std::swap(op_, other->op_);
    std::swap(exp1_, other->exp1_);
    std::swap(exp2_, other->exp2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ArithExp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ArithExp_descriptor_;
  metadata.reflection = ArithExp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Convert::kConvDomFieldNumber;
const int Convert::kConvRngFieldNumber;
const int Convert::kExp2FieldNumber;
#endif  // !_MSC_VER

Convert::Convert()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Convert::InitAsDefaultInstance() {
  convdom_ = const_cast< ::blox::compiler::gpu::Univ*>(&::blox::compiler::gpu::Univ::default_instance());
  convrng_ = const_cast< ::blox::compiler::gpu::Univ*>(&::blox::compiler::gpu::Univ::default_instance());
  exp2_ = const_cast< ::blox::compiler::gpu::Exp*>(&::blox::compiler::gpu::Exp::default_instance());
}

Convert::Convert(const Convert& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Convert::SharedCtor() {
  _cached_size_ = 0;
  convdom_ = NULL;
  convrng_ = NULL;
  exp2_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Convert::~Convert() {
  SharedDtor();
}

void Convert::SharedDtor() {
  if (this != default_instance_) {
    delete convdom_;
    delete convrng_;
    delete exp2_;
  }
}

void Convert::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Convert::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Convert_descriptor_;
}

const Convert& Convert::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Convert* Convert::default_instance_ = NULL;

Convert* Convert::New() const {
  return new Convert;
}

void Convert::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_convdom()) {
      if (convdom_ != NULL) convdom_->::blox::compiler::gpu::Univ::Clear();
    }
    if (has_convrng()) {
      if (convrng_ != NULL) convrng_->::blox::compiler::gpu::Univ::Clear();
    }
    if (has_exp2()) {
      if (exp2_ != NULL) exp2_->::blox::compiler::gpu::Exp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Convert::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.Univ convDom = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_convdom()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_convRng;
        break;
      }
      
      // required .blox.compiler.gpu.Univ convRng = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_convRng:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_convrng()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_exp2;
        break;
      }
      
      // required .blox.compiler.gpu.Exp exp2 = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exp2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp2()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Convert::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.Univ convDom = 1;
  if (has_convdom()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->convdom(), output);
  }
  
  // required .blox.compiler.gpu.Univ convRng = 2;
  if (has_convrng()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->convrng(), output);
  }
  
  // required .blox.compiler.gpu.Exp exp2 = 3;
  if (has_exp2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->exp2(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Convert::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.Univ convDom = 1;
  if (has_convdom()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->convdom(), target);
  }
  
  // required .blox.compiler.gpu.Univ convRng = 2;
  if (has_convrng()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->convrng(), target);
  }
  
  // required .blox.compiler.gpu.Exp exp2 = 3;
  if (has_exp2()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->exp2(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Convert::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.Univ convDom = 1;
    if (has_convdom()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->convdom());
    }
    
    // required .blox.compiler.gpu.Univ convRng = 2;
    if (has_convrng()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->convrng());
    }
    
    // required .blox.compiler.gpu.Exp exp2 = 3;
    if (has_exp2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp2());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Convert::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Convert* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Convert*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Convert::MergeFrom(const Convert& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_convdom()) {
      mutable_convdom()->::blox::compiler::gpu::Univ::MergeFrom(from.convdom());
    }
    if (from.has_convrng()) {
      mutable_convrng()->::blox::compiler::gpu::Univ::MergeFrom(from.convrng());
    }
    if (from.has_exp2()) {
      mutable_exp2()->::blox::compiler::gpu::Exp::MergeFrom(from.exp2());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Convert::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Convert::CopyFrom(const Convert& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Convert::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_convdom()) {
    if (!this->convdom().IsInitialized()) return false;
  }
  if (has_convrng()) {
    if (!this->convrng().IsInitialized()) return false;
  }
  if (has_exp2()) {
    if (!this->exp2().IsInitialized()) return false;
  }
  return true;
}

void Convert::Swap(Convert* other) {
  if (other != this) {
    std::swap(convdom_, other->convdom_);
    std::swap(convrng_, other->convrng_);
    std::swap(exp2_, other->exp2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Convert::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Convert_descriptor_;
  metadata.reflection = Convert_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Mixed::kDomainFieldNumber;
const int Mixed::kRangeFieldNumber;
const int Mixed::kExp1FieldNumber;
#endif  // !_MSC_VER

Mixed::Mixed()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Mixed::InitAsDefaultInstance() {
  domain_ = const_cast< ::blox::compiler::gpu::NumType*>(&::blox::compiler::gpu::NumType::default_instance());
  range_ = const_cast< ::blox::compiler::gpu::NumType*>(&::blox::compiler::gpu::NumType::default_instance());
  exp1_ = const_cast< ::blox::compiler::gpu::Exp*>(&::blox::compiler::gpu::Exp::default_instance());
}

Mixed::Mixed(const Mixed& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Mixed::SharedCtor() {
  _cached_size_ = 0;
  domain_ = NULL;
  range_ = NULL;
  exp1_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Mixed::~Mixed() {
  SharedDtor();
}

void Mixed::SharedDtor() {
  if (this != default_instance_) {
    delete domain_;
    delete range_;
    delete exp1_;
  }
}

void Mixed::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Mixed::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Mixed_descriptor_;
}

const Mixed& Mixed::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Mixed* Mixed::default_instance_ = NULL;

Mixed* Mixed::New() const {
  return new Mixed;
}

void Mixed::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_domain()) {
      if (domain_ != NULL) domain_->::blox::compiler::gpu::NumType::Clear();
    }
    if (has_range()) {
      if (range_ != NULL) range_->::blox::compiler::gpu::NumType::Clear();
    }
    if (has_exp1()) {
      if (exp1_ != NULL) exp1_->::blox::compiler::gpu::Exp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Mixed::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.NumType domain = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_domain()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_range;
        break;
      }
      
      // required .blox.compiler.gpu.NumType range = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_exp1;
        break;
      }
      
      // required .blox.compiler.gpu.Exp exp1 = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exp1:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp1()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Mixed::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.NumType domain = 1;
  if (has_domain()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->domain(), output);
  }
  
  // required .blox.compiler.gpu.NumType range = 2;
  if (has_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->range(), output);
  }
  
  // required .blox.compiler.gpu.Exp exp1 = 3;
  if (has_exp1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->exp1(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Mixed::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.NumType domain = 1;
  if (has_domain()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->domain(), target);
  }
  
  // required .blox.compiler.gpu.NumType range = 2;
  if (has_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->range(), target);
  }
  
  // required .blox.compiler.gpu.Exp exp1 = 3;
  if (has_exp1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->exp1(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Mixed::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.NumType domain = 1;
    if (has_domain()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->domain());
    }
    
    // required .blox.compiler.gpu.NumType range = 2;
    if (has_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->range());
    }
    
    // required .blox.compiler.gpu.Exp exp1 = 3;
    if (has_exp1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp1());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Mixed::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Mixed* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Mixed*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Mixed::MergeFrom(const Mixed& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_domain()) {
      mutable_domain()->::blox::compiler::gpu::NumType::MergeFrom(from.domain());
    }
    if (from.has_range()) {
      mutable_range()->::blox::compiler::gpu::NumType::MergeFrom(from.range());
    }
    if (from.has_exp1()) {
      mutable_exp1()->::blox::compiler::gpu::Exp::MergeFrom(from.exp1());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Mixed::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Mixed::CopyFrom(const Mixed& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Mixed::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_domain()) {
    if (!this->domain().IsInitialized()) return false;
  }
  if (has_range()) {
    if (!this->range().IsInitialized()) return false;
  }
  if (has_exp1()) {
    if (!this->exp1().IsInitialized()) return false;
  }
  return true;
}

void Mixed::Swap(Mixed* other) {
  if (other != this) {
    std::swap(domain_, other->domain_);
    std::swap(range_, other->range_);
    std::swap(exp1_, other->exp1_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Mixed::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Mixed_descriptor_;
  metadata.reflection = Mixed_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Call::kCalltypeFieldNumber;
const int Call::kCallnameFieldNumber;
const int Call::kArgsFieldNumber;
#endif  // !_MSC_VER

Call::Call()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Call::InitAsDefaultInstance() {
}

Call::Call(const Call& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Call::SharedCtor() {
  _cached_size_ = 0;
  calltype_ = 0;
  callname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call::~Call() {
  SharedDtor();
}

void Call::SharedDtor() {
  if (callname_ != &::google::protobuf::internal::kEmptyString) {
    delete callname_;
  }
  if (this != default_instance_) {
  }
}

void Call::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_descriptor_;
}

const Call& Call::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Call* Call::default_instance_ = NULL;

Call* Call::New() const {
  return new Call;
}

void Call::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    calltype_ = 0;
    if (has_callname()) {
      if (callname_ != &::google::protobuf::internal::kEmptyString) {
        callname_->clear();
      }
    }
  }
  args_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.Fixed calltype = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::Fixed_IsValid(value)) {
            set_calltype(static_cast< blox::compiler::gpu::Fixed >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_callname;
        break;
      }
      
      // required string callname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_callname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_callname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->callname().data(), this->callname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_args;
        break;
      }
      
      // repeated .blox.compiler.gpu.Exp args = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_args()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_args;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Call::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.Fixed calltype = 1;
  if (has_calltype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->calltype(), output);
  }
  
  // required string callname = 2;
  if (has_callname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->callname().data(), this->callname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->callname(), output);
  }
  
  // repeated .blox.compiler.gpu.Exp args = 3;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->args(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Call::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.Fixed calltype = 1;
  if (has_calltype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->calltype(), target);
  }
  
  // required string callname = 2;
  if (has_callname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->callname().data(), this->callname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->callname(), target);
  }
  
  // repeated .blox.compiler.gpu.Exp args = 3;
  for (int i = 0; i < this->args_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->args(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Call::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.Fixed calltype = 1;
    if (has_calltype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->calltype());
    }
    
    // required string callname = 2;
    if (has_callname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->callname());
    }
    
  }
  // repeated .blox.compiler.gpu.Exp args = 3;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->args(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call::MergeFrom(const Call& from) {
  GOOGLE_CHECK_NE(&from, this);
  args_.MergeFrom(from.args_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_calltype()) {
      set_calltype(from.calltype());
    }
    if (from.has_callname()) {
      set_callname(from.callname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call::CopyFrom(const Call& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  for (int i = 0; i < args_size(); i++) {
    if (!this->args(i).IsInitialized()) return false;
  }
  return true;
}

void Call::Swap(Call* other) {
  if (other != this) {
    std::swap(calltype_, other->calltype_);
    std::swap(callname_, other->callname_);
    args_.Swap(&other->args_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_descriptor_;
  metadata.reflection = Call_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Exp::kTagFieldNumber;
const int Exp::kConstExpFieldNumber;
const int Exp::kIndexFieldNumber;
const int Exp::kNameFieldNumber;
const int Exp::kArithexpFieldNumber;
const int Exp::kConvertFieldNumber;
const int Exp::kMixedFieldNumber;
const int Exp::kCallFieldNumber;
#endif  // !_MSC_VER

Exp::Exp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Exp::InitAsDefaultInstance() {
  constexp_ = const_cast< ::blox::compiler::gpu::ConstExp*>(&::blox::compiler::gpu::ConstExp::default_instance());
  index_ = const_cast< ::blox::compiler::gpu::Index*>(&::blox::compiler::gpu::Index::default_instance());
  name_ = const_cast< ::blox::compiler::gpu::Name*>(&::blox::compiler::gpu::Name::default_instance());
  arithexp_ = const_cast< ::blox::compiler::gpu::ArithExp*>(&::blox::compiler::gpu::ArithExp::default_instance());
  convert_ = const_cast< ::blox::compiler::gpu::Convert*>(&::blox::compiler::gpu::Convert::default_instance());
  mixed_ = const_cast< ::blox::compiler::gpu::Mixed*>(&::blox::compiler::gpu::Mixed::default_instance());
  call_ = const_cast< ::blox::compiler::gpu::Call*>(&::blox::compiler::gpu::Call::default_instance());
}

Exp::Exp(const Exp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Exp::SharedCtor() {
  _cached_size_ = 0;
  tag_ = 0;
  constexp_ = NULL;
  index_ = NULL;
  name_ = NULL;
  arithexp_ = NULL;
  convert_ = NULL;
  mixed_ = NULL;
  call_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Exp::~Exp() {
  SharedDtor();
}

void Exp::SharedDtor() {
  if (this != default_instance_) {
    delete constexp_;
    delete index_;
    delete name_;
    delete arithexp_;
    delete convert_;
    delete mixed_;
    delete call_;
  }
}

void Exp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Exp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Exp_descriptor_;
}

const Exp& Exp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Exp* Exp::default_instance_ = NULL;

Exp* Exp::New() const {
  return new Exp;
}

void Exp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tag_ = 0;
    if (has_constexp()) {
      if (constexp_ != NULL) constexp_->::blox::compiler::gpu::ConstExp::Clear();
    }
    if (has_index()) {
      if (index_ != NULL) index_->::blox::compiler::gpu::Index::Clear();
    }
    if (has_name()) {
      if (name_ != NULL) name_->::blox::compiler::gpu::Name::Clear();
    }
    if (has_arithexp()) {
      if (arithexp_ != NULL) arithexp_->::blox::compiler::gpu::ArithExp::Clear();
    }
    if (has_convert()) {
      if (convert_ != NULL) convert_->::blox::compiler::gpu::Convert::Clear();
    }
    if (has_mixed()) {
      if (mixed_ != NULL) mixed_->::blox::compiler::gpu::Mixed::Clear();
    }
    if (has_call()) {
      if (call_ != NULL) call_->::blox::compiler::gpu::Call::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Exp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.ExpTag tag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::ExpTag_IsValid(value)) {
            set_tag(static_cast< blox::compiler::gpu::ExpTag >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_constExp;
        break;
      }
      
      // optional .blox.compiler.gpu.ConstExp constExp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_constExp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_constexp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_index;
        break;
      }
      
      // optional .blox.compiler.gpu.Index index = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_index:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_index()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_name;
        break;
      }
      
      // optional .blox.compiler.gpu.Name name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_arithexp;
        break;
      }
      
      // optional .blox.compiler.gpu.ArithExp arithexp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_arithexp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_arithexp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_convert;
        break;
      }
      
      // optional .blox.compiler.gpu.Convert convert = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_convert:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_convert()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_mixed;
        break;
      }
      
      // optional .blox.compiler.gpu.Mixed mixed = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mixed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mixed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_call;
        break;
      }
      
      // optional .blox.compiler.gpu.Call call = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_call:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_call()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Exp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.ExpTag tag = 1;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->tag(), output);
  }
  
  // optional .blox.compiler.gpu.ConstExp constExp = 2;
  if (has_constexp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->constexp(), output);
  }
  
  // optional .blox.compiler.gpu.Index index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->index(), output);
  }
  
  // optional .blox.compiler.gpu.Name name = 4;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->name(), output);
  }
  
  // optional .blox.compiler.gpu.ArithExp arithexp = 5;
  if (has_arithexp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->arithexp(), output);
  }
  
  // optional .blox.compiler.gpu.Convert convert = 6;
  if (has_convert()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->convert(), output);
  }
  
  // optional .blox.compiler.gpu.Mixed mixed = 7;
  if (has_mixed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->mixed(), output);
  }
  
  // optional .blox.compiler.gpu.Call call = 8;
  if (has_call()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->call(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Exp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.ExpTag tag = 1;
  if (has_tag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->tag(), target);
  }
  
  // optional .blox.compiler.gpu.ConstExp constExp = 2;
  if (has_constexp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->constexp(), target);
  }
  
  // optional .blox.compiler.gpu.Index index = 3;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->index(), target);
  }
  
  // optional .blox.compiler.gpu.Name name = 4;
  if (has_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->name(), target);
  }
  
  // optional .blox.compiler.gpu.ArithExp arithexp = 5;
  if (has_arithexp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->arithexp(), target);
  }
  
  // optional .blox.compiler.gpu.Convert convert = 6;
  if (has_convert()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->convert(), target);
  }
  
  // optional .blox.compiler.gpu.Mixed mixed = 7;
  if (has_mixed()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->mixed(), target);
  }
  
  // optional .blox.compiler.gpu.Call call = 8;
  if (has_call()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->call(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Exp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.ExpTag tag = 1;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->tag());
    }
    
    // optional .blox.compiler.gpu.ConstExp constExp = 2;
    if (has_constexp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->constexp());
    }
    
    // optional .blox.compiler.gpu.Index index = 3;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->index());
    }
    
    // optional .blox.compiler.gpu.Name name = 4;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->name());
    }
    
    // optional .blox.compiler.gpu.ArithExp arithexp = 5;
    if (has_arithexp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->arithexp());
    }
    
    // optional .blox.compiler.gpu.Convert convert = 6;
    if (has_convert()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->convert());
    }
    
    // optional .blox.compiler.gpu.Mixed mixed = 7;
    if (has_mixed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mixed());
    }
    
    // optional .blox.compiler.gpu.Call call = 8;
    if (has_call()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->call());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Exp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Exp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Exp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Exp::MergeFrom(const Exp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tag()) {
      set_tag(from.tag());
    }
    if (from.has_constexp()) {
      mutable_constexp()->::blox::compiler::gpu::ConstExp::MergeFrom(from.constexp());
    }
    if (from.has_index()) {
      mutable_index()->::blox::compiler::gpu::Index::MergeFrom(from.index());
    }
    if (from.has_name()) {
      mutable_name()->::blox::compiler::gpu::Name::MergeFrom(from.name());
    }
    if (from.has_arithexp()) {
      mutable_arithexp()->::blox::compiler::gpu::ArithExp::MergeFrom(from.arithexp());
    }
    if (from.has_convert()) {
      mutable_convert()->::blox::compiler::gpu::Convert::MergeFrom(from.convert());
    }
    if (from.has_mixed()) {
      mutable_mixed()->::blox::compiler::gpu::Mixed::MergeFrom(from.mixed());
    }
    if (from.has_call()) {
      mutable_call()->::blox::compiler::gpu::Call::MergeFrom(from.call());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Exp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Exp::CopyFrom(const Exp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Exp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_constexp()) {
    if (!this->constexp().IsInitialized()) return false;
  }
  if (has_index()) {
    if (!this->index().IsInitialized()) return false;
  }
  if (has_name()) {
    if (!this->name().IsInitialized()) return false;
  }
  if (has_arithexp()) {
    if (!this->arithexp().IsInitialized()) return false;
  }
  if (has_convert()) {
    if (!this->convert().IsInitialized()) return false;
  }
  if (has_mixed()) {
    if (!this->mixed().IsInitialized()) return false;
  }
  if (has_call()) {
    if (!this->call().IsInitialized()) return false;
  }
  return true;
}

void Exp::Swap(Exp* other) {
  if (other != this) {
    std::swap(tag_, other->tag_);
    std::swap(constexp_, other->constexp_);
    std::swap(index_, other->index_);
    std::swap(name_, other->name_);
    std::swap(arithexp_, other->arithexp_);
    std::swap(convert_, other->convert_);
    std::swap(mixed_, other->mixed_);
    std::swap(call_, other->call_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Exp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Exp_descriptor_;
  metadata.reflection = Exp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Comp::kComparisonFieldNumber;
const int Comp::kOp1FieldNumber;
const int Comp::kOp2FieldNumber;
#endif  // !_MSC_VER

Comp::Comp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Comp::InitAsDefaultInstance() {
  op1_ = const_cast< ::blox::compiler::gpu::Exp*>(&::blox::compiler::gpu::Exp::default_instance());
  op2_ = const_cast< ::blox::compiler::gpu::Exp*>(&::blox::compiler::gpu::Exp::default_instance());
}

Comp::Comp(const Comp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Comp::SharedCtor() {
  _cached_size_ = 0;
  comparison_ = 0;
  op1_ = NULL;
  op2_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Comp::~Comp() {
  SharedDtor();
}

void Comp::SharedDtor() {
  if (this != default_instance_) {
    delete op1_;
    delete op2_;
  }
}

void Comp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Comp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Comp_descriptor_;
}

const Comp& Comp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Comp* Comp::default_instance_ = NULL;

Comp* Comp::New() const {
  return new Comp;
}

void Comp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    comparison_ = 0;
    if (has_op1()) {
      if (op1_ != NULL) op1_->::blox::compiler::gpu::Exp::Clear();
    }
    if (has_op2()) {
      if (op2_ != NULL) op2_->::blox::compiler::gpu::Exp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Comp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.Comparison comparison = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::Comparison_IsValid(value)) {
            set_comparison(static_cast< blox::compiler::gpu::Comparison >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_op1;
        break;
      }
      
      // required .blox.compiler.gpu.Exp op1 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_op1:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_op1()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_op2;
        break;
      }
      
      // required .blox.compiler.gpu.Exp op2 = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_op2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_op2()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Comp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.Comparison comparison = 1;
  if (has_comparison()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->comparison(), output);
  }
  
  // required .blox.compiler.gpu.Exp op1 = 2;
  if (has_op1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->op1(), output);
  }
  
  // required .blox.compiler.gpu.Exp op2 = 3;
  if (has_op2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->op2(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Comp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.Comparison comparison = 1;
  if (has_comparison()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->comparison(), target);
  }
  
  // required .blox.compiler.gpu.Exp op1 = 2;
  if (has_op1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->op1(), target);
  }
  
  // required .blox.compiler.gpu.Exp op2 = 3;
  if (has_op2()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->op2(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Comp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.Comparison comparison = 1;
    if (has_comparison()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->comparison());
    }
    
    // required .blox.compiler.gpu.Exp op1 = 2;
    if (has_op1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->op1());
    }
    
    // required .blox.compiler.gpu.Exp op2 = 3;
    if (has_op2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->op2());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Comp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Comp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Comp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Comp::MergeFrom(const Comp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_comparison()) {
      set_comparison(from.comparison());
    }
    if (from.has_op1()) {
      mutable_op1()->::blox::compiler::gpu::Exp::MergeFrom(from.op1());
    }
    if (from.has_op2()) {
      mutable_op2()->::blox::compiler::gpu::Exp::MergeFrom(from.op2());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Comp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Comp::CopyFrom(const Comp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Comp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_op1()) {
    if (!this->op1().IsInitialized()) return false;
  }
  if (has_op2()) {
    if (!this->op2().IsInitialized()) return false;
  }
  return true;
}

void Comp::Swap(Comp* other) {
  if (other != this) {
    std::swap(comparison_, other->comparison_);
    std::swap(op1_, other->op1_);
    std::swap(op2_, other->op2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Comp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Comp_descriptor_;
  metadata.reflection = Comp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Test::kTesttypeFieldNumber;
const int Test::kTestnameFieldNumber;
const int Test::kOpsFieldNumber;
#endif  // !_MSC_VER

Test::Test()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Test::InitAsDefaultInstance() {
}

Test::Test(const Test& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Test::SharedCtor() {
  _cached_size_ = 0;
  testtype_ = 0;
  testname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test::~Test() {
  SharedDtor();
}

void Test::SharedDtor() {
  if (testname_ != &::google::protobuf::internal::kEmptyString) {
    delete testname_;
  }
  if (this != default_instance_) {
  }
}

void Test::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Test::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Test_descriptor_;
}

const Test& Test::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Test* Test::default_instance_ = NULL;

Test* Test::New() const {
  return new Test;
}

void Test::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    testtype_ = 0;
    if (has_testname()) {
      if (testname_ != &::google::protobuf::internal::kEmptyString) {
        testname_->clear();
      }
    }
  }
  ops_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Test::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.Fixed testtype = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::Fixed_IsValid(value)) {
            set_testtype(static_cast< blox::compiler::gpu::Fixed >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_testname;
        break;
      }
      
      // required string testname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_testname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_testname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->testname().data(), this->testname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ops;
        break;
      }
      
      // repeated .blox.compiler.gpu.Exp ops = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ops:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ops()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ops;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Test::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.Fixed testtype = 1;
  if (has_testtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->testtype(), output);
  }
  
  // required string testname = 2;
  if (has_testname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->testname().data(), this->testname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->testname(), output);
  }
  
  // repeated .blox.compiler.gpu.Exp ops = 3;
  for (int i = 0; i < this->ops_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->ops(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Test::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.Fixed testtype = 1;
  if (has_testtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->testtype(), target);
  }
  
  // required string testname = 2;
  if (has_testname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->testname().data(), this->testname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->testname(), target);
  }
  
  // repeated .blox.compiler.gpu.Exp ops = 3;
  for (int i = 0; i < this->ops_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->ops(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Test::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.Fixed testtype = 1;
    if (has_testtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->testtype());
    }
    
    // required string testname = 2;
    if (has_testname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->testname());
    }
    
  }
  // repeated .blox.compiler.gpu.Exp ops = 3;
  total_size += 1 * this->ops_size();
  for (int i = 0; i < this->ops_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ops(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Test* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Test*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Test::MergeFrom(const Test& from) {
  GOOGLE_CHECK_NE(&from, this);
  ops_.MergeFrom(from.ops_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_testtype()) {
      set_testtype(from.testtype());
    }
    if (from.has_testname()) {
      set_testname(from.testname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Test::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Test::CopyFrom(const Test& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  for (int i = 0; i < ops_size(); i++) {
    if (!this->ops(i).IsInitialized()) return false;
  }
  return true;
}

void Test::Swap(Test* other) {
  if (other != this) {
    std::swap(testtype_, other->testtype_);
    std::swap(testname_, other->testname_);
    ops_.Swap(&other->ops_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Test::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Test_descriptor_;
  metadata.reflection = Test_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int And::kAnd1FieldNumber;
const int And::kAnd2FieldNumber;
#endif  // !_MSC_VER

And::And()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void And::InitAsDefaultInstance() {
  and1_ = const_cast< ::blox::compiler::gpu::Compare*>(&::blox::compiler::gpu::Compare::default_instance());
  and2_ = const_cast< ::blox::compiler::gpu::Compare*>(&::blox::compiler::gpu::Compare::default_instance());
}

And::And(const And& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void And::SharedCtor() {
  _cached_size_ = 0;
  and1_ = NULL;
  and2_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

And::~And() {
  SharedDtor();
}

void And::SharedDtor() {
  if (this != default_instance_) {
    delete and1_;
    delete and2_;
  }
}

void And::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* And::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return And_descriptor_;
}

const And& And::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

And* And::default_instance_ = NULL;

And* And::New() const {
  return new And;
}

void And::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_and1()) {
      if (and1_ != NULL) and1_->::blox::compiler::gpu::Compare::Clear();
    }
    if (has_and2()) {
      if (and2_ != NULL) and2_->::blox::compiler::gpu::Compare::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool And::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.Compare and1 = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_and1()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_and2;
        break;
      }
      
      // required .blox.compiler.gpu.Compare and2 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_and2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_and2()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void And::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.Compare and1 = 1;
  if (has_and1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->and1(), output);
  }
  
  // required .blox.compiler.gpu.Compare and2 = 2;
  if (has_and2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->and2(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* And::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.Compare and1 = 1;
  if (has_and1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->and1(), target);
  }
  
  // required .blox.compiler.gpu.Compare and2 = 2;
  if (has_and2()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->and2(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int And::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.Compare and1 = 1;
    if (has_and1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->and1());
    }
    
    // required .blox.compiler.gpu.Compare and2 = 2;
    if (has_and2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->and2());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void And::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const And* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const And*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void And::MergeFrom(const And& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_and1()) {
      mutable_and1()->::blox::compiler::gpu::Compare::MergeFrom(from.and1());
    }
    if (from.has_and2()) {
      mutable_and2()->::blox::compiler::gpu::Compare::MergeFrom(from.and2());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void And::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void And::CopyFrom(const And& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool And::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_and1()) {
    if (!this->and1().IsInitialized()) return false;
  }
  if (has_and2()) {
    if (!this->and2().IsInitialized()) return false;
  }
  return true;
}

void And::Swap(And* other) {
  if (other != this) {
    std::swap(and1_, other->and1_);
    std::swap(and2_, other->and2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata And::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = And_descriptor_;
  metadata.reflection = And_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Compare::kTagFieldNumber;
const int Compare::kCompFieldNumber;
const int Compare::kTestFieldNumber;
const int Compare::kAndCompFieldNumber;
#endif  // !_MSC_VER

Compare::Compare()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Compare::InitAsDefaultInstance() {
  comp_ = const_cast< ::blox::compiler::gpu::Comp*>(&::blox::compiler::gpu::Comp::default_instance());
  test_ = const_cast< ::blox::compiler::gpu::Test*>(&::blox::compiler::gpu::Test::default_instance());
  andcomp_ = const_cast< ::blox::compiler::gpu::And*>(&::blox::compiler::gpu::And::default_instance());
}

Compare::Compare(const Compare& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Compare::SharedCtor() {
  _cached_size_ = 0;
  tag_ = 0;
  comp_ = NULL;
  test_ = NULL;
  andcomp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Compare::~Compare() {
  SharedDtor();
}

void Compare::SharedDtor() {
  if (this != default_instance_) {
    delete comp_;
    delete test_;
    delete andcomp_;
  }
}

void Compare::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Compare::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Compare_descriptor_;
}

const Compare& Compare::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Compare* Compare::default_instance_ = NULL;

Compare* Compare::New() const {
  return new Compare;
}

void Compare::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tag_ = 0;
    if (has_comp()) {
      if (comp_ != NULL) comp_->::blox::compiler::gpu::Comp::Clear();
    }
    if (has_test()) {
      if (test_ != NULL) test_->::blox::compiler::gpu::Test::Clear();
    }
    if (has_andcomp()) {
      if (andcomp_ != NULL) andcomp_->::blox::compiler::gpu::And::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Compare::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.CompareTag tag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::CompareTag_IsValid(value)) {
            set_tag(static_cast< blox::compiler::gpu::CompareTag >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_comp;
        break;
      }
      
      // optional .blox.compiler.gpu.Comp comp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_comp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_comp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_test;
        break;
      }
      
      // optional .blox.compiler.gpu.Test test = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_test:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_test()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_andComp;
        break;
      }
      
      // optional .blox.compiler.gpu.And andComp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_andComp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_andcomp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Compare::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.CompareTag tag = 1;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->tag(), output);
  }
  
  // optional .blox.compiler.gpu.Comp comp = 2;
  if (has_comp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->comp(), output);
  }
  
  // optional .blox.compiler.gpu.Test test = 3;
  if (has_test()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->test(), output);
  }
  
  // optional .blox.compiler.gpu.And andComp = 4;
  if (has_andcomp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->andcomp(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Compare::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.CompareTag tag = 1;
  if (has_tag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->tag(), target);
  }
  
  // optional .blox.compiler.gpu.Comp comp = 2;
  if (has_comp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->comp(), target);
  }
  
  // optional .blox.compiler.gpu.Test test = 3;
  if (has_test()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->test(), target);
  }
  
  // optional .blox.compiler.gpu.And andComp = 4;
  if (has_andcomp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->andcomp(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Compare::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.CompareTag tag = 1;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->tag());
    }
    
    // optional .blox.compiler.gpu.Comp comp = 2;
    if (has_comp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->comp());
    }
    
    // optional .blox.compiler.gpu.Test test = 3;
    if (has_test()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->test());
    }
    
    // optional .blox.compiler.gpu.And andComp = 4;
    if (has_andcomp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->andcomp());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Compare::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Compare* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Compare*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Compare::MergeFrom(const Compare& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tag()) {
      set_tag(from.tag());
    }
    if (from.has_comp()) {
      mutable_comp()->::blox::compiler::gpu::Comp::MergeFrom(from.comp());
    }
    if (from.has_test()) {
      mutable_test()->::blox::compiler::gpu::Test::MergeFrom(from.test());
    }
    if (from.has_andcomp()) {
      mutable_andcomp()->::blox::compiler::gpu::And::MergeFrom(from.andcomp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Compare::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Compare::CopyFrom(const Compare& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Compare::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_comp()) {
    if (!this->comp().IsInitialized()) return false;
  }
  if (has_test()) {
    if (!this->test().IsInitialized()) return false;
  }
  if (has_andcomp()) {
    if (!this->andcomp().IsInitialized()) return false;
  }
  return true;
}

void Compare::Swap(Compare* other) {
  if (other != this) {
    std::swap(tag_, other->tag_);
    std::swap(comp_, other->comp_);
    std::swap(test_, other->test_);
    std::swap(andcomp_, other->andcomp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Compare::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Compare_descriptor_;
  metadata.reflection = Compare_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Count::kAggrngFieldNumber;
#endif  // !_MSC_VER

Count::Count()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Count::InitAsDefaultInstance() {
}

Count::Count(const Count& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Count::SharedCtor() {
  _cached_size_ = 0;
  aggrng_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Count::~Count() {
  SharedDtor();
}

void Count::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Count::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Count::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Count_descriptor_;
}

const Count& Count::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Count* Count::default_instance_ = NULL;

Count* Count::New() const {
  return new Count;
}

void Count::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    aggrng_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Count::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 aggrng = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &aggrng_)));
          set_has_aggrng();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Count::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 aggrng = 1;
  if (has_aggrng()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->aggrng(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Count::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 aggrng = 1;
  if (has_aggrng()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->aggrng(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Count::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 aggrng = 1;
    if (has_aggrng()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->aggrng());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Count::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Count* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Count*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Count::MergeFrom(const Count& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_aggrng()) {
      set_aggrng(from.aggrng());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Count::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Count::CopyFrom(const Count& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Count::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Count::Swap(Count* other) {
  if (other != this) {
    std::swap(aggrng_, other->aggrng_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Count::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Count_descriptor_;
  metadata.reflection = Count_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Total::kAggdomFieldNumber;
const int Total::kAggrngFieldNumber;
#endif  // !_MSC_VER

Total::Total()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Total::InitAsDefaultInstance() {
}

Total::Total(const Total& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Total::SharedCtor() {
  _cached_size_ = 0;
  aggdom_ = 0;
  aggrng_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Total::~Total() {
  SharedDtor();
}

void Total::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Total::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Total::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Total_descriptor_;
}

const Total& Total::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Total* Total::default_instance_ = NULL;

Total* Total::New() const {
  return new Total;
}

void Total::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    aggdom_ = 0;
    aggrng_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Total::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 aggdom = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &aggdom_)));
          set_has_aggdom();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_aggrng;
        break;
      }
      
      // required int32 aggrng = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_aggrng:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &aggrng_)));
          set_has_aggrng();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Total::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 aggdom = 1;
  if (has_aggdom()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->aggdom(), output);
  }
  
  // required int32 aggrng = 2;
  if (has_aggrng()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->aggrng(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Total::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 aggdom = 1;
  if (has_aggdom()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->aggdom(), target);
  }
  
  // required int32 aggrng = 2;
  if (has_aggrng()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->aggrng(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Total::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 aggdom = 1;
    if (has_aggdom()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->aggdom());
    }
    
    // required int32 aggrng = 2;
    if (has_aggrng()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->aggrng());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Total::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Total* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Total*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Total::MergeFrom(const Total& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_aggdom()) {
      set_aggdom(from.aggdom());
    }
    if (from.has_aggrng()) {
      set_aggrng(from.aggrng());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Total::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Total::CopyFrom(const Total& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Total::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Total::Swap(Total* other) {
  if (other != this) {
    std::swap(aggdom_, other->aggdom_);
    std::swap(aggrng_, other->aggrng_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Total::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Total_descriptor_;
  metadata.reflection = Total_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Min::kAggdomFieldNumber;
const int Min::kAggrngFieldNumber;
#endif  // !_MSC_VER

Min::Min()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Min::InitAsDefaultInstance() {
}

Min::Min(const Min& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Min::SharedCtor() {
  _cached_size_ = 0;
  aggdom_ = 0;
  aggrng_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Min::~Min() {
  SharedDtor();
}

void Min::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Min::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Min::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Min_descriptor_;
}

const Min& Min::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Min* Min::default_instance_ = NULL;

Min* Min::New() const {
  return new Min;
}

void Min::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    aggdom_ = 0;
    aggrng_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Min::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 aggdom = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &aggdom_)));
          set_has_aggdom();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_aggrng;
        break;
      }
      
      // required int32 aggrng = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_aggrng:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &aggrng_)));
          set_has_aggrng();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Min::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 aggdom = 1;
  if (has_aggdom()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->aggdom(), output);
  }
  
  // required int32 aggrng = 2;
  if (has_aggrng()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->aggrng(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Min::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 aggdom = 1;
  if (has_aggdom()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->aggdom(), target);
  }
  
  // required int32 aggrng = 2;
  if (has_aggrng()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->aggrng(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Min::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 aggdom = 1;
    if (has_aggdom()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->aggdom());
    }
    
    // required int32 aggrng = 2;
    if (has_aggrng()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->aggrng());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Min::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Min* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Min*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Min::MergeFrom(const Min& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_aggdom()) {
      set_aggdom(from.aggdom());
    }
    if (from.has_aggrng()) {
      set_aggrng(from.aggrng());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Min::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Min::CopyFrom(const Min& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Min::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Min::Swap(Min* other) {
  if (other != this) {
    std::swap(aggdom_, other->aggdom_);
    std::swap(aggrng_, other->aggrng_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Min::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Min_descriptor_;
  metadata.reflection = Min_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Max::kAggdomFieldNumber;
const int Max::kAggrngFieldNumber;
#endif  // !_MSC_VER

Max::Max()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Max::InitAsDefaultInstance() {
}

Max::Max(const Max& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Max::SharedCtor() {
  _cached_size_ = 0;
  aggdom_ = 0;
  aggrng_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Max::~Max() {
  SharedDtor();
}

void Max::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Max::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Max::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Max_descriptor_;
}

const Max& Max::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Max* Max::default_instance_ = NULL;

Max* Max::New() const {
  return new Max;
}

void Max::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    aggdom_ = 0;
    aggrng_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Max::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 aggdom = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &aggdom_)));
          set_has_aggdom();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_aggrng;
        break;
      }
      
      // required int32 aggrng = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_aggrng:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &aggrng_)));
          set_has_aggrng();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Max::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 aggdom = 1;
  if (has_aggdom()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->aggdom(), output);
  }
  
  // required int32 aggrng = 2;
  if (has_aggrng()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->aggrng(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Max::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 aggdom = 1;
  if (has_aggdom()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->aggdom(), target);
  }
  
  // required int32 aggrng = 2;
  if (has_aggrng()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->aggrng(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Max::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 aggdom = 1;
    if (has_aggdom()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->aggdom());
    }
    
    // required int32 aggrng = 2;
    if (has_aggrng()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->aggrng());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Max::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Max* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Max*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Max::MergeFrom(const Max& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_aggdom()) {
      set_aggdom(from.aggdom());
    }
    if (from.has_aggrng()) {
      set_aggrng(from.aggrng());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Max::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Max::CopyFrom(const Max& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Max::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Max::Swap(Max* other) {
  if (other != this) {
    std::swap(aggdom_, other->aggdom_);
    std::swap(aggrng_, other->aggrng_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Max::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Max_descriptor_;
  metadata.reflection = Max_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Agg::kTagFieldNumber;
const int Agg::kCountFieldNumber;
const int Agg::kTotalFieldNumber;
const int Agg::kMinFieldNumber;
const int Agg::kMaxFieldNumber;
#endif  // !_MSC_VER

Agg::Agg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Agg::InitAsDefaultInstance() {
  count_ = const_cast< ::blox::compiler::gpu::Count*>(&::blox::compiler::gpu::Count::default_instance());
  total_ = const_cast< ::blox::compiler::gpu::Total*>(&::blox::compiler::gpu::Total::default_instance());
  min_ = const_cast< ::blox::compiler::gpu::Min*>(&::blox::compiler::gpu::Min::default_instance());
  max_ = const_cast< ::blox::compiler::gpu::Max*>(&::blox::compiler::gpu::Max::default_instance());
}

Agg::Agg(const Agg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Agg::SharedCtor() {
  _cached_size_ = 0;
  tag_ = 0;
  count_ = NULL;
  total_ = NULL;
  min_ = NULL;
  max_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Agg::~Agg() {
  SharedDtor();
}

void Agg::SharedDtor() {
  if (this != default_instance_) {
    delete count_;
    delete total_;
    delete min_;
    delete max_;
  }
}

void Agg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Agg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Agg_descriptor_;
}

const Agg& Agg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RelationalAlgebra_2eproto();  return *default_instance_;
}

Agg* Agg::default_instance_ = NULL;

Agg* Agg::New() const {
  return new Agg;
}

void Agg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tag_ = 0;
    if (has_count()) {
      if (count_ != NULL) count_->::blox::compiler::gpu::Count::Clear();
    }
    if (has_total()) {
      if (total_ != NULL) total_->::blox::compiler::gpu::Total::Clear();
    }
    if (has_min()) {
      if (min_ != NULL) min_->::blox::compiler::gpu::Min::Clear();
    }
    if (has_max()) {
      if (max_ != NULL) max_->::blox::compiler::gpu::Max::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Agg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .blox.compiler.gpu.AggTag tag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (blox::compiler::gpu::AggTag_IsValid(value)) {
            set_tag(static_cast< blox::compiler::gpu::AggTag >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_count;
        break;
      }
      
      // optional .blox.compiler.gpu.Count count = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_count:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_count()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_total;
        break;
      }
      
      // optional .blox.compiler.gpu.Total total = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_total:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_total()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_min;
        break;
      }
      
      // optional .blox.compiler.gpu.Min min = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_min()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_max;
        break;
      }
      
      // optional .blox.compiler.gpu.Max max = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Agg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .blox.compiler.gpu.AggTag tag = 1;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->tag(), output);
  }
  
  // optional .blox.compiler.gpu.Count count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->count(), output);
  }
  
  // optional .blox.compiler.gpu.Total total = 3;
  if (has_total()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->total(), output);
  }
  
  // optional .blox.compiler.gpu.Min min = 4;
  if (has_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->min(), output);
  }
  
  // optional .blox.compiler.gpu.Max max = 5;
  if (has_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->max(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Agg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .blox.compiler.gpu.AggTag tag = 1;
  if (has_tag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->tag(), target);
  }
  
  // optional .blox.compiler.gpu.Count count = 2;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->count(), target);
  }
  
  // optional .blox.compiler.gpu.Total total = 3;
  if (has_total()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->total(), target);
  }
  
  // optional .blox.compiler.gpu.Min min = 4;
  if (has_min()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->min(), target);
  }
  
  // optional .blox.compiler.gpu.Max max = 5;
  if (has_max()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->max(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Agg::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .blox.compiler.gpu.AggTag tag = 1;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->tag());
    }
    
    // optional .blox.compiler.gpu.Count count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->count());
    }
    
    // optional .blox.compiler.gpu.Total total = 3;
    if (has_total()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->total());
    }
    
    // optional .blox.compiler.gpu.Min min = 4;
    if (has_min()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->min());
    }
    
    // optional .blox.compiler.gpu.Max max = 5;
    if (has_max()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->max());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Agg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Agg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Agg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Agg::MergeFrom(const Agg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tag()) {
      set_tag(from.tag());
    }
    if (from.has_count()) {
      mutable_count()->::blox::compiler::gpu::Count::MergeFrom(from.count());
    }
    if (from.has_total()) {
      mutable_total()->::blox::compiler::gpu::Total::MergeFrom(from.total());
    }
    if (from.has_min()) {
      mutable_min()->::blox::compiler::gpu::Min::MergeFrom(from.min());
    }
    if (from.has_max()) {
      mutable_max()->::blox::compiler::gpu::Max::MergeFrom(from.max());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Agg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Agg::CopyFrom(const Agg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Agg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_count()) {
    if (!this->count().IsInitialized()) return false;
  }
  if (has_total()) {
    if (!this->total().IsInitialized()) return false;
  }
  if (has_min()) {
    if (!this->min().IsInitialized()) return false;
  }
  if (has_max()) {
    if (!this->max().IsInitialized()) return false;
  }
  return true;
}

void Agg::Swap(Agg* other) {
  if (other != this) {
    std::swap(tag_, other->tag_);
    std::swap(count_, other->count_);
    std::swap(total_, other->total_);
    std::swap(min_, other->min_);
    std::swap(max_, other->max_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Agg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Agg_descriptor_;
  metadata.reflection = Agg_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gpu
}  // namespace compiler
}  // namespace blox

// @@protoc_insertion_point(global_scope)
